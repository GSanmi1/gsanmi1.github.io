<!DOCTYPE html>
<html lang="en">
<!-- Beautiful Jekyll 5.0.0 | Copyright Dean Attali 2020 -->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  <title>Integer Overflow/Underflow.</title>

  
  <meta name="author" content="German">
  

  <meta name="description" content="Notes from Integer Overflow course from OST2.">

  

  

  
  <link rel="alternate" type="application/rss+xml" title="Home" href="http://localhost:4000/feed.xml">
  

  

  

  

  


  
    
      
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/assets/css/beautifuljekyll.css">
    
  

  
    
      <link rel="stylesheet" href="/assets/css/custom-dark.css">
    
  

  
  
  

  

  
  <meta property="og:site_name" content="Home">
  <meta property="og:title" content="Integer Overflow/Underflow.">
  <meta property="og:description" content="Notes from Integer Overflow course from OST2.">

  

  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="German">
  <meta property="og:article:published_time" content="2025-12-05T00:00:00-05:00">
  <meta property="og:url" content="http://localhost:4000/2025-12-05-IntegerOverflow-Underflow/">
  <link rel="canonical" href="http://localhost:4000/2025-12-05-IntegerOverflow-Underflow/">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@Qvintvs1">
  <meta name="twitter:creator" content="@Qvintvs1">

  <meta property="twitter:title" content="Integer Overflow/Underflow.">
  <meta property="twitter:description" content="Notes from Integer Overflow course from OST2.">

  

  

  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
    document.querySelectorAll("script[type='math/tex; mode=display']").forEach(function(el) {
      el.outerHTML = "\\[" + el.textContent + "\\]";
    });
    document.querySelectorAll("script[type='math/tex']").forEach(function(el) {
      el.outerHTML = "\\(" + el.textContent + "\\)";
    });
    var script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js';
    script.async = true;
    document.head.appendChild(script);
  });
</script>


  

  

</head>


<body>

  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="http://localhost:4000/">Home</a><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ms-auto">
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Program</a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="/Cpage">C</a>
                  <a class="dropdown-item" href="/DHARMApage">Dharma</a>
                  <a class="dropdown-item" href="/RUSTpage">Rust</a>
            </div>
          </li>
        
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Web2</a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="/BURPSUITEpage">Burp</a>
                  <a class="dropdown-item" href="/THMpage">Thm</a>
                  <a class="dropdown-item" href="/HackTheBoxpage">Htb</a>
                  <a class="dropdown-item" href="/PEN200page">BasicPentesting</a>
                  <a class="dropdown-item" href="/REDTEAMBASICSpage">RedTeam</a>
                  <a class="dropdown-item" href="/BLUETEAMBASICSpage">Blueteam</a>
                  <a class="dropdown-item" href="/REDESpage">Net</a>
                  <a class="dropdown-item" href="/2022-11-17-GitBasics">Git</a>
                  <a class="dropdown-item" href="/CSOFTpage">MemCorrupt</a>
            </div>
          </li>
        
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">ZKP</a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="/MATHpage">Math</a>
                  <a class="dropdown-item" href="/RUSTpage">Rust</a>
                  <a class="dropdown-item" href="/NOIRpage">Noir</a>
            </div>
          </li>
        
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Assembly</a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="/ASSEMpage">x86</a>
            </div>
          </li>
        
        <li class="nav-item">
          <a class="nav-link" id="nav-search-link" href="#" title="Search">
            <span id="nav-search-icon" class="fa fa-search"></span>
            <span id="nav-search-text">Search</span>
          </a>
        </li></ul>
  </div>

  

  

</nav>



<div id="beautifuljekyll-search-overlay">

  <div id="nav-search-exit" title="Exit search">✕</div>
  <input type="text" id="nav-search-input" placeholder="Search">
  <ul id="search-results-container"></ul>
  
  <script src="https://unpkg.com/simple-jekyll-search@latest/dest/simple-jekyll-search.min.js"></script>
  <script>
    var searchjson = '[ \
       \
        { \
          "title"    : "P vs NP.", \
          "category" : "math", \
          "url"      : "/2026-01-11-PvsNP/", \
          "date"     : "January 11, 2026" \
        }, \
       \
        { \
          "title"    : "Race Conditions.", \
          "category" : "csoft", \
          "url"      : "/2025-12-28-RaceCondition/", \
          "date"     : "December 28, 2025" \
        }, \
       \
        { \
          "title"    : "Introducción al Cálculo", \
          "category" : "matemáticas", \
          "url"      : "/2025-12-25-MathTest/", \
          "date"     : "December 25, 2025" \
        }, \
       \
        { \
          "title"    : "Uninitialize Data Access.", \
          "category" : "csoft", \
          "url"      : "/2025-12-23-UDA/", \
          "date"     : "December 23, 2025" \
        }, \
       \
        { \
          "title"    : "Control Flow.", \
          "category" : "assem", \
          "url"      : "/2025-12-12-ControlFlow/", \
          "date"     : "December 12, 2025" \
        }, \
       \
        { \
          "title"    : "Other Integer Issues.", \
          "category" : "csoft", \
          "url"      : "/2025-12-05-OtherIntegerIssues/", \
          "date"     : "December  5, 2025" \
        }, \
       \
        { \
          "title"    : "Integer Overflow/Underflow.", \
          "category" : "csoft", \
          "url"      : "/2025-12-05-IntegerOverflow-Underflow/", \
          "date"     : "December  5, 2025" \
        }, \
       \
        { \
          "title"    : "Passing Parameters.", \
          "category" : "assem", \
          "url"      : "/2025-12-04-Passing-Parameters/", \
          "date"     : "December  4, 2025" \
        }, \
       \
        { \
          "title"    : "Stackframe; Local variables, Arrays and Structures.", \
          "category" : "assem", \
          "url"      : "/2025-12-01-LocalVars_Arrays_structs/", \
          "date"     : "December  1, 2025" \
        }, \
       \
        { \
          "title"    : "Out-Of-Bounds Write.", \
          "category" : "csoft", \
          "url"      : "/2025-11-26-Out-Of-Bounds-Write/", \
          "date"     : "November 26, 2025" \
        }, \
       \
        { \
          "title"    : "Calling Functions.", \
          "category" : "assem", \
          "url"      : "/2025-11-21-CallingFunctions/", \
          "date"     : "November 21, 2025" \
        }, \
       \
        { \
          "title"    : "(Linear) Heap Buffer Overflow.", \
          "category" : "csoft", \
          "url"      : "/2025-11-18-HBO/", \
          "date"     : "November 18, 2025" \
        }, \
       \
        { \
          "title"    : "Basic Instructions.", \
          "category" : "assem", \
          "url"      : "/2025-11-17-AssemblyBasicRegisters/", \
          "date"     : "November 17, 2025" \
        }, \
       \
        { \
          "title"    : "Computer Registers.", \
          "category" : "assem", \
          "url"      : "/2025-11-08-ComputerRegisters/", \
          "date"     : "November  8, 2025" \
        }, \
       \
        { \
          "title"    : "CVE-2021-20294.", \
          "category" : "csoft", \
          "url"      : "/2025-11-07-CVE-2021-20294/", \
          "date"     : "November  7, 2025" \
        }, \
       \
        { \
          "title"    : "(Linear) Stack Buffer Overflow.", \
          "category" : "csoft", \
          "url"      : "/2025-11-06-LSBO/", \
          "date"     : "November  6, 2025" \
        }, \
       \
        { \
          "title"    : "Text Editor.", \
          "category" : "C", \
          "url"      : "/2025-08-11-Text-Editor/", \
          "date"     : "August 11, 2025" \
        }, \
       \
        { \
          "title"    : "Garbage Collector.", \
          "category" : "C", \
          "url"      : "/2025-07-11-GarbageCollector/", \
          "date"     : "July 11, 2025" \
        }, \
       \
        { \
          "title"    : "Hashtables.", \
          "category" : "C", \
          "url"      : "/2025-06-13-HashTable/", \
          "date"     : "June 13, 2025" \
        }, \
       \
        { \
          "title"    : "Building my own malloc in C.", \
          "category" : "C", \
          "url"      : "/2025-06-09-BuildingOwnMalloc/", \
          "date"     : "June  9, 2025" \
        }, \
       \
        { \
          "title"    : "Malloc Tutorial", \
          "category" : "C", \
          "url"      : "/2025-06-06-MallocTutorial/", \
          "date"     : "June  6, 2025" \
        }, \
       \
        { \
          "title"    : "SharedLibraries&amp;FunctionHooking", \
          "category" : "C", \
          "url"      : "/2025-04-26-SharedLibraries&FunctionHooking/", \
          "date"     : "April 26, 2025" \
        }, \
       \
        { \
          "title"    : "File Descritors", \
          "category" : "C", \
          "url"      : "/2025-03-04-FileDescriptors/", \
          "date"     : "March  4, 2025" \
        }, \
       \
        { \
          "title"    : "Network Programming", \
          "category" : "C", \
          "url"      : "/2025-02-22-Network_Programming/", \
          "date"     : "February 22, 2025" \
        }, \
       \
        { \
          "title"    : "2. Constants and Literals in C.", \
          "category" : "C", \
          "url"      : "/2024-12-10-2.ConstantsinC-copy/", \
          "date"     : "December 10, 2024" \
        }, \
       \
        { \
          "title"    : "1. Basics of C", \
          "category" : "C", \
          "url"      : "/2024-12-02-1.BasicsOfC/", \
          "date"     : "December  2, 2024" \
        }, \
       \
        { \
          "title"    : "Gramáticas en Dharma", \
          "category" : "DHA", \
          "url"      : "/2024-09-24-Dharma_Tutorial/", \
          "date"     : "September 24, 2024" \
        }, \
       \
        { \
          "title"    : "Gramáticas en Dharma", \
          "category" : "fuzz", \
          "url"      : "/2024-03-22-Dharma_Tutorial-copy/", \
          "date"     : "March 22, 2024" \
        }, \
       \
        { \
          "title"    : "Mi experiencia con el OSCP", \
          "category" : "pen", \
          "url"      : "/2023-11-19-PEN200_Experience/", \
          "date"     : "November 19, 2023" \
        }, \
       \
        { \
          "title"    : "Client Side", \
          "category" : "pen", \
          "url"      : "/2023-11-17-17.Client_Side_Attacks/", \
          "date"     : "November 17, 2023" \
        }, \
       \
        { \
          "title"    : "Deep Packet Tunneling", \
          "category" : "pen", \
          "url"      : "/2023-11-16-16.Tunneling_Through_Deep_Packet_Inspection/", \
          "date"     : "November 16, 2023" \
        }, \
       \
        { \
          "title"    : "Report", \
          "category" : "pen", \
          "url"      : "/2023-11-15-15.Making_Reports/", \
          "date"     : "November 15, 2023" \
        }, \
       \
        { \
          "title"    : "Metasploit", \
          "category" : "pen", \
          "url"      : "/2023-11-14-14.Metasploit/", \
          "date"     : "November 14, 2023" \
        }, \
       \
        { \
          "title"    : "Password Attacks", \
          "category" : "pen", \
          "url"      : "/2023-11-13-13.Password_Attacks/", \
          "date"     : "November 13, 2023" \
        }, \
       \
        { \
          "title"    : "Active Directory Attacks", \
          "category" : "pen", \
          "url"      : "/2023-11-12-12.Active_Directory_Attacks/", \
          "date"     : "November 12, 2023" \
        }, \
       \
        { \
          "title"    : "Port Forwarding", \
          "category" : "pen", \
          "url"      : "/2023-11-11-11.Port_Forwarding/", \
          "date"     : "November 11, 2023" \
        }, \
       \
        { \
          "title"    : "Privilege Escalation", \
          "category" : "pen", \
          "url"      : "/2023-11-10-10.Privilege_Escalation/", \
          "date"     : "November 10, 2023" \
        }, \
       \
        { \
          "title"    : "File Transfers", \
          "category" : "pen", \
          "url"      : "/2023-11-09-9.File_Tranfers/", \
          "date"     : "November  9, 2023" \
        }, \
       \
        { \
          "title"    : "Buffer Overflows", \
          "category" : "pen", \
          "url"      : "/2023-11-08-8.Buffer_Overflows/", \
          "date"     : "November  8, 2023" \
        }, \
       \
        { \
          "title"    : "Vulnerability Scanning.", \
          "category" : "pen", \
          "url"      : "/2023-11-07-7.Vulnerability_Scanning/", \
          "date"     : "November  7, 2023" \
        }, \
       \
        { \
          "title"    : "Information Gathering", \
          "category" : "pen", \
          "url"      : "/2023-11-06-6.Active_Information_Gathering/", \
          "date"     : "November  6, 2023" \
        }, \
       \
        { \
          "title"    : "Windows", \
          "category" : "pen", \
          "url"      : "/2023-11-05-5.Windows/", \
          "date"     : "November  5, 2023" \
        }, \
       \
        { \
          "title"    : "Networking", \
          "category" : "pen", \
          "url"      : "/2023-11-04-4.Networking/", \
          "date"     : "November  4, 2023" \
        }, \
       \
        { \
          "title"    : "Scripting", \
          "category" : "pen", \
          "url"      : "/2023-11-03-3.Scripting/", \
          "date"     : "November  3, 2023" \
        }, \
       \
        { \
          "title"    : "Practical Tools", \
          "category" : "pen", \
          "url"      : "/2023-11-02-2.PracticalTools/", \
          "date"     : "November  2, 2023" \
        }, \
       \
        { \
          "title"    : "Linux", \
          "category" : "pen", \
          "url"      : "/2023-11-01-1.Linux/", \
          "date"     : "November  1, 2023" \
        }, \
       \
        { \
          "title"    : "Easy", \
          "category" : "hack", \
          "url"      : "/2022-12-01-Easy/", \
          "date"     : "December  1, 2022" \
        }, \
       \
        { \
          "title"    : "Git Basics", \
          "category" : "", \
          "url"      : "/2022-11-17-GitBasics/", \
          "date"     : "November 17, 2022" \
        }, \
       \
        { \
          "title"    : "Tier I", \
          "category" : "hack", \
          "url"      : "/2022-11-10-Tier_1/", \
          "date"     : "November 10, 2022" \
        }, \
       \
        { \
          "title"    : "Tier 0", \
          "category" : "hack", \
          "url"      : "/2022-11-09-Tier_0/", \
          "date"     : "November  9, 2022" \
        }, \
       \
        { \
          "title"    : "7.BufferOverflow.", \
          "category" : "thm", \
          "url"      : "/2022-11-02-7.BufferOverflow/", \
          "date"     : "November  2, 2022" \
        }, \
       \
        { \
          "title"    : "6.Offensive Pentesting", \
          "category" : "thm", \
          "url"      : "/2022-11-01-6.OffensivePentesting/", \
          "date"     : "November  1, 2022" \
        }, \
       \
        { \
          "title"    : "5.RedTeam", \
          "category" : "thm", \
          "url"      : "/2022-10-30-5.RedTeam/", \
          "date"     : "October 30, 2022" \
        }, \
       \
        { \
          "title"    : "4.Windows", \
          "category" : "thm", \
          "url"      : "/2022-10-22-4.Windows/", \
          "date"     : "October 22, 2022" \
        }, \
       \
        { \
          "title"    : "3.Junior Penetrationtester path", \
          "category" : "thm", \
          "url"      : "/2022-09-02-3.JRPenetrationTester/", \
          "date"     : "September  2, 2022" \
        }, \
       \
        { \
          "title"    : "2.Complete Begginer path.", \
          "category" : "thm", \
          "url"      : "/2022-08-07-2.CompleteBegginer/", \
          "date"     : "August  7, 2022" \
        }, \
       \
        { \
          "title"    : "1.Pre-Security path.", \
          "category" : "thm", \
          "url"      : "/2022-07-11-1Pre-Security/", \
          "date"     : "July 11, 2022" \
        }, \
       \
        { \
          "title"    : "0.Scripting for pentesters.", \
          "category" : "thm", \
          "url"      : "/2022-07-10-0.Scripting_for_pentesters/", \
          "date"     : "July 10, 2022" \
        }, \
       \
        { \
          "title"    : "Burp Certified Practitioner Practice Exam.", \
          "category" : "burp", \
          "url"      : "/2022-03-30-PracticeExam/", \
          "date"     : "March 30, 2022" \
        }, \
       \
        { \
          "title"    : "22. OAuth Authentication.", \
          "category" : "burp", \
          "url"      : "/2022-03-27-22.OAuth_authentication/", \
          "date"     : "March 27, 2022" \
        }, \
       \
        { \
          "title"    : "21. HTTP Request Smuggling.", \
          "category" : "burp", \
          "url"      : "/2022-03-26-21.HTTP_request_smuggling/", \
          "date"     : "March 26, 2022" \
        }, \
       \
        { \
          "title"    : "20. HTTP Host Header Attacks.", \
          "category" : "burp", \
          "url"      : "/2022-03-25-20.HTTP_Host_header_attacks/", \
          "date"     : "March 25, 2022" \
        }, \
       \
        { \
          "title"    : "19. Web Cache Poisoning.", \
          "category" : "burp", \
          "url"      : "/2022-03-24-19.Web_cache_poisoning/", \
          "date"     : "March 24, 2022" \
        }, \
       \
        { \
          "title"    : "18. Server-Side Template Injection.", \
          "category" : "burp", \
          "url"      : "/2022-03-23-18.Serve-side_template_injection/", \
          "date"     : "March 23, 2022" \
        }, \
       \
        { \
          "title"    : "17. Insecure Deserialization.", \
          "category" : "burp", \
          "url"      : "/2022-03-22-17.Insecure_deserialization/", \
          "date"     : "March 22, 2022" \
        }, \
       \
        { \
          "title"    : "16. WebSockets.", \
          "category" : "burp", \
          "url"      : "/2022-03-21-16.WebSockets/", \
          "date"     : "March 21, 2022" \
        }, \
       \
        { \
          "title"    : "15.DOM-based XSS vulnerabilities.", \
          "category" : "burp", \
          "url"      : "/2022-03-20-15-DOM-based_vulnerabilities/", \
          "date"     : "March 20, 2022" \
        }, \
       \
        { \
          "title"    : "14. Clickjacking.", \
          "category" : "burp", \
          "url"      : "/2022-03-19-14.Clickjacking/", \
          "date"     : "March 19, 2022" \
        }, \
       \
        { \
          "title"    : "13. Cross-Origin Resource Sharing.", \
          "category" : "burp", \
          "url"      : "/2022-03-18-13.Cross-origin_resource_sharing_(CORS)/", \
          "date"     : "March 18, 2022" \
        }, \
       \
        { \
          "title"    : "12. Cross-Site Request Forgery.", \
          "category" : "burp", \
          "url"      : "/2022-03-17-12.Cross-site_request_forgery_(CSRF)/", \
          "date"     : "March 17, 2022" \
        }, \
       \
        { \
          "title"    : "11. Cross-Site Scripting.", \
          "category" : "burp", \
          "url"      : "/2022-03-16-11.Cross-site_scripting_(XSS)/", \
          "date"     : "March 16, 2022" \
        }, \
       \
        { \
          "title"    : "10. XXE Injection.", \
          "category" : "burp", \
          "url"      : "/2022-03-15-10.XXE_injection/", \
          "date"     : "March 15, 2022" \
        }, \
       \
        { \
          "title"    : "9. Server-Side Request Forgery.", \
          "category" : "burp", \
          "url"      : "/2022-03-14-9.Server-side_request_forgery/", \
          "date"     : "March 14, 2022" \
        }, \
       \
        { \
          "title"    : "8. File Upload.", \
          "category" : "burp", \
          "url"      : "/2022-03-13-8.File_upload_vulnerabilities/", \
          "date"     : "March 13, 2022" \
        }, \
       \
        { \
          "title"    : "7. Access Control.", \
          "category" : "burp", \
          "url"      : "/2022-03-12-7.Access_control/", \
          "date"     : "March 12, 2022" \
        }, \
       \
        { \
          "title"    : "6. Information Disclosure.", \
          "category" : "burp", \
          "url"      : "/2022-03-11-6.Information_disclosure/", \
          "date"     : "March 11, 2022" \
        }, \
       \
        { \
          "title"    : "5. Bussiness Logic Vulnerabilities.", \
          "category" : "burp", \
          "url"      : "/2022-03-10-5.Business_logic_vulnerabilities/", \
          "date"     : "March 10, 2022" \
        }, \
       \
        { \
          "title"    : "4. Command Injection.", \
          "category" : "burp", \
          "url"      : "/2022-03-09-4.Command_Injection/", \
          "date"     : "March  9, 2022" \
        }, \
       \
        { \
          "title"    : "3. Directory Traversal.", \
          "category" : "burp", \
          "url"      : "/2022-03-08-3.Directory_Traversal/", \
          "date"     : "March  8, 2022" \
        }, \
       \
        { \
          "title"    : "2. Authentication.", \
          "category" : "burp", \
          "url"      : "/2022-03-07-2.Authentication/", \
          "date"     : "March  7, 2022" \
        }, \
       \
        { \
          "title"    : "1. SQLInjection", \
          "category" : "burp", \
          "url"      : "/2022-03-06-1.SQLInjection/", \
          "date"     : "March  6, 2022" \
        }, \
       \
        { \
          "title"    : "Seguridad Perimetral", \
          "category" : "blueteam", \
          "url"      : "/2022-02-09-Seguridad_Perimetral/", \
          "date"     : "February  9, 2022" \
        }, \
       \
        { \
          "title"    : "Hardening de sistemas", \
          "category" : "blueteam", \
          "url"      : "/2022-02-09-Hardening_de_sistemas/", \
          "date"     : "February  9, 2022" \
        }, \
       \
        { \
          "title"    : "Bandit", \
          "category" : "otw", \
          "url"      : "/2022-02-08-Bandit/", \
          "date"     : "February  8, 2022" \
        }, \
       \
        { \
          "title"    : "Proxy", \
          "category" : "redes", \
          "url"      : "/2022-02-07-Proxys/", \
          "date"     : "February  7, 2022" \
        }, \
       \
        { \
          "title"    : "Protocolos Relevantes", \
          "category" : "redes", \
          "url"      : "/2022-02-07-Protocolos_Importantes/", \
          "date"     : "February  7, 2022" \
        }, \
       \
        { \
          "title"    : "Curso Básico Redes", \
          "category" : "redes", \
          "url"      : "/2022-02-07-Precurso_Redes/", \
          "date"     : "February  7, 2022" \
        }, \
       \
        { \
          "title"    : "IPs", \
          "category" : "redes", \
          "url"      : "/2022-02-07-IPs/", \
          "date"     : "February  7, 2022" \
        }, \
       \
        { \
          "title"    : "Movimientos Laterales", \
          "category" : "redteam", \
          "url"      : "/2022-02-06-Introducci%C3%B3n_a_movimientos_laterales/", \
          "date"     : "February  6, 2022" \
        }, \
       \
        { \
          "title"    : "Evasión de Defensas", \
          "category" : "redteam", \
          "url"      : "/2022-02-05-Evasi%C3%B3n_de_Defensas/", \
          "date"     : "February  5, 2022" \
        }, \
       \
        { \
          "title"    : "Escalada de privilegios", \
          "category" : "redteam", \
          "url"      : "/2022-02-05-Escalada_de_privilegios/", \
          "date"     : "February  5, 2022" \
        }, \
       \
        { \
          "title"    : "Metasploit", \
          "category" : "redteam", \
          "url"      : "/2022-02-04-Metasploit_B%C3%A1sico/", \
          "date"     : "February  4, 2022" \
        }, \
       \
        { \
          "title"    : "Ataques a aplicaciones Android", \
          "category" : "redteam", \
          "url"      : "/2022-02-03-Ataques_aplicaciones_android/", \
          "date"     : "February  3, 2022" \
        }, \
       \
        { \
          "title"    : "Ataque a aplicaciones web.", \
          "category" : "redteam", \
          "url"      : "/2022-02-02-Ataques_a_aplicaciones_web/", \
          "date"     : "February  2, 2022" \
        }, \
       \
        { \
          "title"    : "Ataques a Infraestructuras y Redes", \
          "category" : "redteam", \
          "url"      : "/2022-02-01-Ataques_a_Infraestructuras_y_Redes/", \
          "date"     : "February  1, 2022" \
        }, \
       \
        { \
          "title"    : "Análisis de Objetivos", \
          "category" : "redteam", \
          "url"      : "/2022-01-28-An%C3%A1lisis_de_Objetivos/", \
          "date"     : "January 28, 2022" \
        }, \
       \
       \
        { \
          "title"    : "Assembly and Architecture Introduction.", \
          "category" : "page", \
          "url"      : "/ASSEMpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Blueteam Basics", \
          "category" : "page", \
          "url"      : "/BLUETEAMBASICSpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "PortSwigger BurpSuite Course", \
          "category" : "page", \
          "url"      : "/BURPSUITEpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "C-Family Software Memory Corruption Vulnerabilities", \
          "category" : "page", \
          "url"      : "/CSOFTpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "C &amp; Systems Fundamentals.", \
          "category" : "page", \
          "url"      : "/Cpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Dharma Fuzzer language", \
          "category" : "page", \
          "url"      : "/DHARMApage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Exploiting &amp; Reversing", \
          "category" : "page", \
          "url"      : "/EXPREVpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Fuzzing JavaScript Engine", \
          "category" : "page", \
          "url"      : "/Fuzzpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "HackTheBox", \
          "category" : "page", \
          "url"      : "/HackTheBoxpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "TryHackMe", \
          "category" : "page", \
          "url"      : "/MATHpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "PEN200 notes", \
          "category" : "page", \
          "url"      : "/PEN200page/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Proyectos", \
          "category" : "page", \
          "url"      : "/PROJECTSpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Networking Basics", \
          "category" : "page", \
          "url"      : "/REDESpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "RedTeam Basics", \
          "category" : "page", \
          "url"      : "/REDTEAMBASICSpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Retired Machines", \
          "category" : "page", \
          "url"      : "/RetiredMachinespage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "TryHackMe", \
          "category" : "page", \
          "url"      : "/THMpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "About me", \
          "category" : "page", \
          "url"      : "/aboutme/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "THM", \
          "category" : "page", \
          "url"      : "/preOSCPpage/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Tag Index", \
          "category" : "page", \
          "url"      : "/tags/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page2/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page3/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page4/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page5/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page6/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page7/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page8/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page9/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page10/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page11/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page12/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page13/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page14/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page15/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page16/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page17/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page18/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page19/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "", \
          "category" : "page", \
          "url"      : "/page20/", \
          "date"     : "January 1, 1970" \
        } \
       \
    ]';
    searchjson = JSON.parse(searchjson);

    var sjs = SimpleJekyllSearch({
      searchInput: document.getElementById('nav-search-input'),
      resultsContainer: document.getElementById('search-results-container'),
      json: searchjson
    });
  </script>
</div>





  <!-- TODO this file has become a mess, refactor it -->







<header class="header-section ">

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>Integer Overflow/Underflow.</h1>
          
            
              <h2 class="post-subheading">Notes from Integer Overflow course from OST2.</h2>
            
          

          
            <span class="post-meta">Posted on December 5, 2025</span>
            
            
          
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <article role="main" class="blog-post">
        <h3 id="1-integer-overflowunderflow-vulnerabilities-introduction">1. Integer Overflow/Underflow vulnerabilities introduction.</h3>

<p>Integer Overflow/Undwerflow vulnerabilities referer a vulnerability form in which an attacker leverage cases in which is possible that signed and unsigned integers exceeds their positive and negative value ranges due to egdy math cases.</p>

<p>Before enter in a further explanation, let’s take a reminder on how signed and unsigned data types works in C.</p>

<p><br /></p>

<h4 id="11-values-and-datatypes">1.1. Values and Datatypes.</h4>

<p><strong>Value and Datatypes definition</strong></p>

<p>Let’s start in the beginning, building the idea of <em>value</em> and <em>datatype</em>.</p>

<ul>
  <li>
    <p>A <em>value</em> is nothing but an abstraction of a piece of information stored in memory in form of binary bits waiting to be processed by the CPU.</p>
  </li>
  <li>
    <p>A <em>datatype</em> tells the compiler how to interpret and store that value in memory. It defines two critical things:</p>

    <ol>
      <li>
        <p>The size of the value; this is <em>how many bytes to allocate</em>; (char, short, integer, …, array, struct,…).</p>
      </li>
      <li>
        <p>The sign of the value; or <em>how to interpret the bit pattern stored there</em> (signed/unsigned). The same bit pattern 0xFF could mean 255 or -1 depending on how the compiler interprets it.</p>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<p><strong>Signed vs Unsigned</strong></p>

<p>The sign of a value is also related with the datatype it self, because there are datatypes in which make a signed/unsigned distinction does not make sense. <em>The signed/unsigned distinction only applies to integer types</em> (char, short, int, long, etc.) because it’s about how to interpret a fixed sequence of bits as a number. Floating-point types, structs, pointers does not have an unsigned version.</p>

<ul>
  <li>
    <p><em>Unsigned integers</em> use all bits to represent magnitude. An 8-bit unsigned value ranges from 0 to 255 (2⁸ - 1). Every bit pattern maps directly to a non-negative number.</p>
  </li>
  <li>
    <p><em>Signed integers</em> uses the most significant bit to encode sign information, is called the sign bit. Using two’s complement representation (which is universal on modern systems), an 8-bit signed value ranges from -128 to 127. The bit pattern 0xFF becomes -1 rather than 255.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="12-twos-complement-signed-numbers">1.2. Two’s Complement Signed Numbers.</h4>

<p>Two’s complement is the standard way that C (and most modern computers) represents signed integers (positive and negative whole numbers).</p>

<p>In this representation, the leftmost (or more significant bit) serves also as an indicator to notice the sign of the value:</p>

<ul>
  <li>‘0’ to positive numbers; 01111111b = 127</li>
  <li>‘1’ to negative numbers. 10000000b = -128</li>
</ul>

<p>Thus, let’s suppose we have a binary number, lets say <em>x</em>, the complement’s convention says that in order to represent <em>-x</em> we have to flip all the bits (0→1, 1→0) this is called the one’s complement and then add 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Positive number: 5

- 00000101b 

Negative number: -5

- Step 1: Start with 5:     00000101
- Step 2: Flip all bits:     11111010  (one's complement)
- Step 3: Add 1:             11111011  = -5 (two's complement)
</code></pre></div></div>

<p>The formula to obtain the decimal value from a signed integer binary number is applying a negative sign to sign bit in the standard base system operation, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11111011 = -1*2^7 + 1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 = -128 + 123 = -5
</code></pre></div></div>

<p><br /></p>

<h4 id="13-range-of-a-datatype">1.3. Range of a datatype.</h4>

<p>A word about the range. A <em>range</em> is simply the set of all possible values a datatype can represent and is not an arbitrary decision but a direct consequence of having finite storage capacity. Memory is organized into units of 8-bits each (also called byte), and CPUs have registers of fixed widths: 8, 16, 32, or 64 bits on modern systems. This means that, often, you only have at most 64 bits (possibles 0 or 1) to store a binary value which represents data, this also means that every datatype has a finite range.</p>

<p>For signed integers, the absolute value decrements in a half compared with the unsigned type and, for example, to a 8 bits value, the maximum unsigned value is 11111111b, which in decimal is 255. But, for the signed type, by convention, since the leftmost bit is consider the sign bit, then the further value from zero is 1111111b = 127.</p>

<p>It happens that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n-bit signed integer --&gt; the range is: -2^(n-1) to 2^(n-1) - 1
</code></pre></div></div>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>binary</th>
      <th>hex</th>
      <th>unsigned decimal</th>
      <th>signed decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00000000</td>
      <td>00</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>00000001</td>
      <td>01</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>00000010</td>
      <td>02</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>00000011</td>
      <td>03</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>01111110</td>
      <td>7E</td>
      <td>126</td>
      <td>126</td>
    </tr>
    <tr>
      <td>01111111</td>
      <td>7F</td>
      <td>127</td>
      <td>127</td>
    </tr>
    <tr>
      <td>10000000</td>
      <td>80</td>
      <td>128</td>
      <td>-128</td>
    </tr>
    <tr>
      <td>10000001</td>
      <td>81</td>
      <td>129</td>
      <td>-127</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>11111110</td>
      <td>FE</td>
      <td>254</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>11111111</td>
      <td>FF</td>
      <td>255</td>
      <td>-1</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>This exact principle showed with 8-bits can be extended also to 16,32 and 64 bits numbers:</p>

<ul>
  <li>8-bit signed (char): -128 to 127</li>
  <li>16-bit signed (short): -32,768 to 32,767</li>
  <li>32-bit signed (int): -2,147,483,648 to 2,147,483,647</li>
</ul>

<p><br /></p>

<h3 id="2-integer-overflow-definition">2. Integer Overflow Definition.</h3>

<p>At this moment, with the having introduced the previous terms, we are now in conditions to provide a definition.</p>

<p><br /></p>

<h4 id="21-unsigned-overflowunderflow">2.1. Unsigned Overflow/Underflow.</h4>

<p>Let’s consider the following trivial code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div>

<p>In the code above, an unsigned char gets defined with value 0 and then a while loop starts increasing the value of <em>i</em> once at a time.</p>

<p>As de loops iterates, i value increases but since char size is one byte, it only can store 8-bits, so eventually:</p>

<table>
  <thead>
    <tr>
      <th>iteration</th>
      <th>uchar (binary)</th>
      <th>uchar (hex)</th>
      <th>uchar (decimal)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>254</td>
      <td>11111110</td>
      <td>FE</td>
      <td>254</td>
    </tr>
    <tr>
      <td>255</td>
      <td>11111111</td>
      <td>FF</td>
      <td>255 (Upper-top range)</td>
    </tr>
    <tr>
      <td>256</td>
      <td>1(00000000)</td>
      <td>1(00)</td>
      <td>0</td>
    </tr>
    <tr>
      <td>257</td>
      <td>000000001</td>
      <td>01</td>
      <td>1</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<p>What is happenning is that the CPU is perfoming the correct calculation which is 11111111 + 1 = 100000000 (a 9-bit value) and is storing it in a 8-bit size chunk, so as the result, the most significant bit is left out and what is stored at the chunk is the value 00000000, restarting the value of <em>i</em>. This is what we call <em>Unsigned Overflow</em>.</p>

<p>This can be resumed as the following rule: <strong>All the operations performed over an unsigned datatype are modular operations with module 2^N where N is the bit-width of the type</strong>.</p>

<p><em>Unsigned overflow</em> is well-defined in C. The standard explicitly says unsigned arithmetic wraps modulo 2^n. If you add 1 to UINT_MAX, you get 0. This is guaranteed, portable behavior. The opposite case, going behind 0 to obtain instantetly the biggest value posible is what we call <em>Signed Underflow</em>.</p>

<p><br /></p>

<h4 id="22-signed-overflowunderflow">2.2. Signed Overflow/Underflow.</h4>

<p>Signed Integers, as discussed before, have a different design than unsigned datatypes. Since both entities are confined within a finite storage capacity both share range boundaries and the overflow type related to the range boundaries discussed above.</p>

<p>But signed integers also leads to another type of overflow dealing with the change of sign. Let’s start saying negativity is a decimal-level abstraction. At the binary level, you just have rings of integers mod 2^n, and two’s complement is the isomorphism that maps the upper half of that ring onto negative numbers in a way that preserves additive structure.</p>

<p>Lets dive on how this isomorphism works. By definition, if we have a value ‘x’ in a set o numbers, his negative is that number in the set which add to 0 with ‘x’:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x + (-x) = 0
</code></pre></div></div>

<p>Let’s consider a binary value of 8-bit wide, 00000011 (3) if we calculate the negative through the two’s complement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = 1 --&gt; -x = 11111110 + 1 = 11111111 = 255
x = 2 --&gt; -x = 11111101 + 1 = 11111110 = 254
x = 3 --&gt; -x = 11111100 + 1 = 11111101 = 253
x = 4 --&gt; -x = 11111011 + 1 = 11111100 = 252
...
</code></pre></div></div>

<p>We can see a clear pattern, as we go on the values from the lower limit of the range (0), his negative correspondient value is the homologous value startint from te upper limit (256) and the flow of both values advance to opposite directions so they are meant to encounter each other at the half of the track.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = 126 --&gt; -x = 10000001 + 1 = 10000010 = 130
x = 127 --&gt; -x = 10000000 + 1 = 10000001 = 129
x = 128 --&gt; -x = 01111111 + 1 = 10000000 = 128 &lt;-- Inflection point
x = 129 --&gt; -x = 01111110 + 1 = 01111111 = 127
x = 130 --&gt; -x = 01111101 + 1 = 01111110 = 126
</code></pre></div></div>

<p>Thus, we can assume the convention that from 127 all the numbers above are the negative counter part of the half below 127.</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>binary</th>
      <th>unsigned decimal</th>
      <th>signed decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00000000</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>00000001</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>00000010</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>00000011</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>01111110</td>
      <td>126</td>
      <td>126</td>
    </tr>
    <tr>
      <td>01111111</td>
      <td>127</td>
      <td>127</td>
    </tr>
    <tr>
      <td>10000000</td>
      <td>128</td>
      <td>-128</td>
    </tr>
    <tr>
      <td>10000001</td>
      <td>129</td>
      <td>-127</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>11111110</td>
      <td>254</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>11111111</td>
      <td>255</td>
      <td>-1</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>Thus, in any modular 2^N ring the values increases until some threshold is reached (the half of the ring) and then the value goes from being the highest value to the smallest one, this is what we call <em>Signed Overflow</em>. The opposite case, when the values decreases until goes from the smallest value to the highest one is called <em>Signed Underflow</em>. Signed overflow is undefined behavior in C. The standard says the compiler can assume it never happens, which means if your code allows it to happen, the compiler is free to do anything: wrap around, saturate, crash, optimize away your bounds check, or summon demons. In practice, most compilers on most platforms will wrap using two’s complement (so INT_MAX + 1 becomes INT_MIN).</p>

<p>Let’s note again that negativity is just a convention, we explain how positive and negative values are relate between them using the ‘negative’ and two’s complement definitions only in behalf of clarity. Negative and substraction are concepts tightly related and is easier to think about them because we are made to an infinite set of numbers. In fact, in modular rings as 8-bit width binary values negativness is a direct consecuence of the modular nature of the ring:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127 + (-127) = 01111111 + 10000001 = 1(00000000)
</code></pre></div></div>

<p>Also the risk of this effect and the reason why this leads into a vulnerability is also a consecuence of the modular nature of the set of numbers.</p>

<p><br /></p>

<h4 id="23-conclusion-and-explaning-the-risk">2.3. Conclusion and explaning the risk.</h4>

<p>Integer overflows shows them selfs as vulnerabilties due to “under-allocation” and “over-copy”, for examples:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Assume var is user-controlled</span>
<span class="n">malloc</span><span class="p">(</span><span class="n">var1</span> <span class="o">+</span> <span class="k">const</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="n">var1</span> <span class="o">+</span> <span class="n">var2</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="n">var1</span> <span class="o">*</span> <span class="k">const</span><span class="p">)</span>
</code></pre></div></div>

<p>All of this allocations present issues of having underallocation.</p>

<p>If again this number is used to copy data with checking the memory chunk allocated:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">var1</span><span class="p">)</span>
</code></pre></div></div>

<p>This can be an over-copy.</p>

<p><br /></p>

<h3 id="3-examples">3. Examples.</h3>

<h4 id="31-trivial-example">3.1. Trivial Example:</h4>

<p>Let’s check the following code.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">my_header</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_header_t</span><span class="p">;</span>

<span class="c1">// Under-allocate, over-copy – uaoc.c</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="n">my_header_t</span> <span class="n">header</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_size</span><span class="p">;</span>

    <span class="n">header</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x6f6e6558</span><span class="p">;</span>
    <span class="n">header</span><span class="p">.</span><span class="n">size</span>  <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">alloc_size</span>   <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"String self-reported size = 0x%08lX</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Allocation size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"buf points to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"memcpy()ing 0x%08lX bytes into buf of size 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"We copied input string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we check the code, we can see that some user-controlled data <em>argv[1}</em> is being stored on <em>size</em> field of <em>header</em> struct and inmediately without sanitization, this same value is used to allocate memory space:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">header</span><span class="p">.</span><span class="n">size</span>  <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="n">alloc_size</span>   <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
</code></pre></div></div>

<p>Thus, let’s observe that, since <em>header.size</em> is arbitrary and <em>my_header_t</em> struct have two fields (two longs), <em>then sizeof(my_header_t)</em> in x64 is 16 bytes and the unsigned int in x64 has 4 bytes in size, so is a value within a range between 0 and 2^(4<em>8) = 2^32 (4 bytes, 8 bits each byte) = 4294967296, thus if the user enters 4294967280 (4294967296 - 16) *alloc_size</em> would be overflow an turn 0, this means that this code can easily turns into an underallocation.</p>

<p>Later, the pointer is used as a destination in a <em>memcpy()</em> operation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<p>The reuslt is overcopying:</p>

<pre><code class="language-less">OUTPUT:
$ ./test 4294967280 hello
String self-reported size = 0xFFFFFFF0
Allocation size = 0x00000000
buf points to 0x58449e0336b0
memcpy()ing 0xFFFFFFF0 bytes into buf of size 0x00000000
Segmentation fault (core dumped)
</code></pre>

<p><br /></p>

<h4 id="32-freertos">3.2. FreeRTOS.</h4>

<p>Lets consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pvPortMalloc</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">xWantedSize</span> <span class="p">)</span> <span class="p">{</span><span class="n">v</span><span class="c1">//user-controlled - xWantedSize </span>
    <span class="n">BlockLink_t</span> <span class="o">*</span><span class="n">pxBlock</span><span class="p">,</span> <span class="o">*</span><span class="n">pxPreviousBlock</span><span class="p">,</span> <span class="o">*</span><span class="n">pxNewBlockLink</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">BaseType_t</span> <span class="n">xHeapHasBeenInitialised</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">pvReturn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">vTaskSuspendAll</span><span class="p">();</span>
    <span class="p">{</span>
        <span class="cm">/* If this is the first call to malloc then the heap
         * initialisation to setup the list of free blocks. */</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">xHeapHasBeenInitialised</span> <span class="o">==</span> <span class="n">pdFALSE</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">prvHeapInit</span><span class="p">();</span>
            <span class="n">xHeapHasBeenInitialised</span> <span class="o">=</span> <span class="n">pdTRUE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* The wanted size is increased so it can contain a BlockLink_t
         * structure in addition to the requested amount of bytes. */</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">xWantedSize</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">xWantedSize</span> <span class="o">+=</span> <span class="n">heapSTRUCT_SIZE</span><span class="p">;</span>

            <span class="cm">/* Ensure that blocks are always aligned to the required number of bytes. */</span>
            <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">xWantedSize</span> <span class="o">&amp;</span> <span class="n">portBYTE_ALIGNMENT_MASK</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="cm">/* Byte alignment required. */</span>
                <span class="n">xWantedSize</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">portBYTE_ALIGNMENT</span> <span class="o">-</span> <span class="p">(</span> <span class="n">xWantedSize</span> <span class="o">&amp;</span> <span class="n">portBYTE_ALIGNMENT_MASK</span> <span class="p">)</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can see that <em>xWantedSize</em>, which is a <em>size_t</em> datatype (unsigned integer) is user-controlled and used within an if statement performing a math operation with <em>heapSTRUCT_SIZE</em> without validation, thus as we proceed in the case before, we could perform an unsigned overflow.</p>

<p><br /></p>

<h3 id="4-exercises">4. Exercises.</h3>

<h4 id="41-cve-2020-0796-smbghost">4.1. CVE-2020-0796 “SMBGhost”.</h4>

<p>CVE-2020-0796, commonly known as SMBGhost, is a critical remote code execution vulnerability discovered in March 2020 that affects Microsoft’s SMBv3 (Server Message Block version 3) protocol implementation in Windows 10 and Windows Server versions 1903 and later.</p>

<p>SMB3 supports message compression to reduce network traffic load, message decompression takes place in the srv2.sys kernel driver.</p>

<p><br /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////ACID: The data pointed to by request-&gt;pNetRawBuffer</span>
<span class="kt">signed</span> <span class="n">__int64</span> <span class="kr">__fastcall</span> <span class="nf">Srv2DecompressData</span><span class="p">(</span><span class="n">SRV2_WORKITEM</span> <span class="o">*</span><span class="n">workitem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// declarations omitted</span>
    <span class="p">...</span>
    <span class="n">request</span> <span class="o">=</span> <span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">dwMsgSize</span> <span class="o">&lt;</span> <span class="mh">0x10</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mh">0xC000090B</span><span class="p">;</span>
    <span class="n">compressHeader</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">CompressionTransformHeader</span> <span class="o">*</span><span class="p">)</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">;</span>
    <span class="p">...</span>
   
    <span class="n">newHeader</span> <span class="o">=</span> <span class="n">SrvNetAllocateBuffer</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">compressHeader</span><span class="p">.</span><span class="n">originalCompressedSegSize</span> <span class="o">+</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">newHeader</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mh">0xC000009A</span><span class="p">;</span>
   
    <span class="k">if</span> <span class="p">(</span> <span class="n">SmbCompressionDecompress</span><span class="p">(</span>
                <span class="n">compressHeader</span><span class="p">.</span><span class="n">compressionType</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">[</span><span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span>
                <span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="o">-&gt;</span><span class="n">dwMsgSize</span> <span class="o">-</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="o">-</span> <span class="mi">16</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">newHeader</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">[</span><span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">],</span>
                <span class="n">compressHeader</span><span class="p">.</span><span class="n">OriginalCompressedSegSize</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">finalDecompressedSize</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="o">||</span> <span class="n">finalDecompressedSize</span> <span class="o">!=</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">originalCompressedSegSize</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">SrvNetFreeBuffer</span><span class="p">(</span><span class="n">newHeader</span><span class="p">);</span>
        <span class="k">return</span> <span class="mh">0xC000090B</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memmove</span><span class="p">(</span><span class="n">newHeader</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">,</span> <span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">newHeader</span><span class="o">-&gt;</span><span class="n">dwMsgSize</span> <span class="o">=</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">OffsetOrLength</span> <span class="o">+</span> <span class="n">fianlDecompressedSize</span><span class="p">;</span>
    <span class="n">Srv2ReplaceReceiveBuffer</span><span class="p">(</span><span class="n">workitem</span><span class="p">,</span> <span class="n">newHeader</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, let’s go carefully, checking the code, the user controlled data is pointed by <em>request-&gt;pNetRawBuffer</em>, thus:</p>

<ul>
  <li>
    <p>First, <em>compressHeader</em> gets the dereferenced contents of <em>request-&gt;pNetRawBuffer</em>, then some fields of this structure gets used to allocate a buffer presumibly inside the heap:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">compressHeader</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">CompressionTransformHeader</span> <span class="o">*</span><span class="p">)</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">;</span>
   
  <span class="n">newHeader</span> <span class="o">=</span> <span class="n">SrvNetAllocateBuffer</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">compressHeader</span><span class="p">.</span><span class="n">originalCompressedSegSize</span> <span class="o">+</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>This essentially could lead to an underallocation since no check is done after or before the allocation.</p>
  </li>
  <li>
    <p>Later, <em>offsetOrLength</em> field is used to copy memory to the previos allocated buffer which could lead to an overcopy:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="p">){</span>
      <span class="n">memmove</span><span class="p">(</span><span class="n">newHeader</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">,</span> <span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>As a summary, an addition of two user-controlled terms could be used to perform an underallocation due to an unsigned integer overflow, for example if <em>compressHeader.originalCompressedSegSize</em> is small and <em>compressHeader.offsetOrLength</em> was huge always being:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">compressHeader</span><span class="p">.</span><span class="n">originalCompressedSegSize</span> <span class="o">+</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">32</span>
</code></pre></div>    </div>

    <p>Then, on the second line, a huge amountn of bytes would be used to write over an small buffer provoking an overcopy resulting in a bufffer overflow.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="42-cve-2019-5105">4.2. CVE-2019-5105.</h4>

<p>CVE-2019-5105 is a critical memory corruption vulnerability affecting 3S-Smart Software Solutions’ CODESYS industrial automation platform, specifically in the GatewayService component. While primarily classified as an out-of-bounds write vulnerability, it’s related to integer overflow issues in buffer size calculations.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">////ACID: param_1</span>
<span class="kt">void</span> <span class="nf">FUN_00677d70</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">param_1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_5</span> <span class="p">,</span><span class="n">uint</span> <span class="o">*</span><span class="n">param_6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">header_length</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">_Size</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iVar1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iVar2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">receiver_length</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">sender_length</span><span class="p">;</span>
  <span class="cm">/* Omitted code  */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">blkDrvPDUdata</span><span class="p">;</span>
  <span class="cm">/* Omitted code */</span>
  <span class="n">iVar2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_2</span> <span class="o">+</span> <span class="mh">0x128</span><span class="p">)</span> <span class="o">+</span>  <span class="n">DAT_007a3534</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">iVar2</span> <span class="o">&lt;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>
     <span class="cm">/* Omitted code */</span>
    <span class="n">blkDrvPDUdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_1</span><span class="p">;</span>
    <span class="n">header_length</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">sender_length</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
    <span class="n">receiver_length</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">pvVar3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">sender_length</span> <span class="o">+</span> <span class="n">receiver_length</span> <span class="o">+</span> <span class="n">header_length</span><span class="p">);</span>
    <span class="n">local_20c</span> <span class="o">=</span> <span class="n">header_length</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pvVar3</span> <span class="o">&lt;</span> <span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="n">pvVar3</span> <span class="o">==</span> <span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">pvVar3</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="n">header_length</span> <span class="o">+</span> <span class="p">(</span><span class="n">sender_length</span> <span class="o">+</span> <span class="n">receiver_length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">param_6</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_6</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_Size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="o">*</span><span class="n">param_6</span><span class="p">;</span>

        <span class="cm">/* Omitted  code*/</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">local_220</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">local_244</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">))</span> <span class="p">{</span>      
          <span class="cm">/* Omitted  Code*/</span>              
          <span class="k">if</span> <span class="p">(</span><span class="n">local_20c</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">_Size</span> <span class="o">&lt;</span> <span class="mh">0x201</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">local_208</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">local_20c</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">param_1</span> <span class="o">+</span> <span class="o">*</span><span class="n">param_6</span><span class="p">),</span> <span class="n">_Size</span> <span class="p">);</span>
            <span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">local_20c</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">_Size</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">param_1</span><span class="p">,</span><span class="n">local_208</span><span class="p">,(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_5</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">param_1</span> <span class="o">+</span> <span class="n">local_20c</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_4</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_5</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_5</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
            <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="n">local_20c</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">iVar1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">param_6</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_6</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">FUN_006ce8f9</span><span class="p">();</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s review the code carefully, user-controlled data lies on <em>param_1</em>.</p>

<ul>
  <li>
    <p>First, some declaration are perfomed:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">header_length</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">_Size</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iVar1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iVar2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">receiver_length</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">sender_length</span><span class="p">;</span>
  <span class="cm">/* Omitted code  */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">blkDrvPDUdata</span><span class="p">;</span>
  <span class="cm">/* Omitted code */</span>
  <span class="n">iVar2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_2</span> <span class="o">+</span> <span class="mh">0x128</span><span class="p">)</span> <span class="o">+</span>  <span class="n">DAT_007a3534</span><span class="p">;</span>
  <span class="c1">//...</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Then, comes the assignation, in which some variables in the function receives user-controlled data:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">blkDrvPDUdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_1</span><span class="p">;</span>
  <span class="n">header_length</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">sender_length</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
  <span class="n">receiver_length</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">pvVar3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">sender_length</span> <span class="o">+</span> <span class="n">receiver_length</span> <span class="o">+</span> <span class="n">header_length</span><span class="p">);</span>
  <span class="n">local_20c</span> <span class="o">=</span> <span class="n">header_length</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Essentially, is not hard to see that all of this variables are user-controlled</p>
  </li>
  <li>
    <p>Now, this variables are used to define the copy size, the source and the destination of a memcpy() operation:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="n">header_length</span> <span class="o">+</span> <span class="p">(</span><span class="n">sender_length</span> <span class="o">+</span> <span class="n">receiver_length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//User-controlled</span>
  <span class="c1">//...</span>
  <span class="n">_Size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="o">*</span><span class="n">param_6</span><span class="p">;</span> <span class="c1">//Underflow</span>
  <span class="c1">//...</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">local_208</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">local_20c</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">param_1</span> <span class="o">+</span> <span class="o">*</span><span class="n">param_6</span><span class="p">),</span> <span class="n">_Size</span> <span class="p">);</span> <span class="c1">//Overcopy</span>
  <span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">local_20c</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">_Size</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">param_1</span><span class="p">,</span><span class="n">local_208</span><span class="p">,(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></div>    </div>

    <p>Let’s observe carefully that when _Size filled, if  <em>*param_6</em> &gt; than <em>(int)param_1[1]</em> then, it could result in a negative value that, when cast to unsigned it will transform in a huge positive value leading to an overcopy</p>
  </li>
</ul>

<p><br /></p>

<h4 id="43-cve-2019-14192">4.3. CVE-2019-14192.</h4>

<p>CVE-2019-14192 is an integer overflow vulnerability discovered in U-Boot (Universal Boot Loader), which is one of the most widely used boot loaders for embedded systems.</p>

<p>Firmware fetch the bootloader which in this case is u-boot and this devices loads the OS and this one the rest of the applications.</p>

<p>Let’s check the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////ACID: in_packet</span>
<span class="kt">void</span> <span class="nf">net_process_received_packet</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">in_packet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethernet_hdr</span> <span class="o">*</span><span class="n">et</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_udp_hdr</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">dst_ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">src_ip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eth_proto</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ip_udp_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_packet</span> <span class="o">+</span> <span class="n">E802_HDR_SIZE</span><span class="p">);</span>
	<span class="c1">// ...</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">eth_proto</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// ...</span>
	<span class="k">case</span> <span class="n">PROT_IP</span><span class="p">:</span>
		<span class="n">debug_cond</span><span class="p">(</span><span class="n">DEBUG_NET_PKT</span><span class="p">,</span> <span class="s">"Got IP</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="cm">/* Before we start poking the header, make sure it is there */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debug</span><span class="p">(</span><span class="s">"len bad %d &lt; %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">IP_UDP_HDR_SIZE</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Check the packet length */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">debug</span><span class="p">(</span><span class="s">"len bad %d &lt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_len</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_len</span><span class="p">);</span>
		<span class="c1">// ...</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">net_defragment</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ip</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="c1">// ...</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_p</span> <span class="o">==</span> <span class="n">IPPROTO_ICMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">receive_icmp</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">et</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_p</span> <span class="o">!=</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Only UDP packets */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// ...</span>
<span class="cp">#if defined(CONFIG_NETCONSOLE) &amp;&amp; !defined(CONFIG_SPL_BUILD)
</span>		<span class="n">nc_input_packet</span><span class="p">((</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_dst</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_src</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UDP_HDR_SIZE</span><span class="p">);</span>
<span class="cp">#endif
</span>		<span class="cm">/*
		 * IP header OK.  Pass the packet to the current handler.
		 */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">udp_packet_handler</span><span class="p">)((</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_dst</span><span class="p">),</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_src</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UDP_HDR_SIZE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="c1">// ...</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s note the following line:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//...</span>
<span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ip_udp_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_packet</span> <span class="o">+</span> <span class="n">E802_HDR_SIZE</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="cp">#if defined(CONFIG_NETCONSOLE) &amp;&amp; !defined(CONFIG_SPL_BUILD)
</span>		<span class="n">nc_input_packet</span><span class="p">((</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_dst</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_src</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UDP_HDR_SIZE</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>We can see that, the last parameter of the calling of <em>nc_input_packet()</em> function is math operation without validation of any type. We don’t need to understand what the function does with that value in order to be able to see that is dangerous and is in fact a vulnerbility.</p>

<p>The same is done just below in the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    * IP header OK.  Pass the packet to the current handler.
    */</span>
<span class="p">(</span><span class="o">*</span><span class="n">udp_packet_handler</span><span class="p">)((</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_dst</span><span class="p">),</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_src</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UDP_HDR_SIZE</span><span class="p">);</span>
<span class="k">break</span><span class="p">;</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<p>A function is being called thorugh a function pointer and the last parameter is also a math operation without any validation.</p>

<p>(This is not in fact so dangerous as it seems, perhaps the function holds some validation for edgy values?)</p>

<p><br /></p>

<h4 id="44-cve-2020-11901-part-of-ripple20-grab-bag">4.4. CVE-2020-11901. Part of “Ripple20” grab-bag.</h4>

<p>CVE-2020-11901 is really 4 vulnerabilities that got lumped into the same CVE (/ didn’t get assigned their own CVEs), this was discussed before on Linear Stack Buffer Overflow.</p>

<p>This pertains to the parsing of compressed DNS packets. DNS packets have a formatting for hostname strings that breaks them into “labels”, that are prefixed by a label length byte. Multiple labels are separated by a period, the total hostname string is considered complete when a 0 is found for a label length. The DNS spec states that the max label length should be 63 bytes and the hostname length should be 255 bytes.</p>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ACID: RDLENGTH, resourceRecordAfterNamePtr, dnsHeaderPtr</span>
<span class="k">if</span> <span class="p">(</span><span class="n">RDLENGTH</span> <span class="o">&lt;=</span> <span class="n">remaining_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* compute the next resource record pointer based on the RDLENGTH */</span>
	<span class="n">labelEndPtr</span> <span class="o">=</span> <span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">RDLENGTH</span><span class="p">;</span>
	<span class="cm">/* type: MX */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cacheEntryQueryType</span> <span class="o">==</span> <span class="n">DNS_TYPE_MX</span> <span class="o">&amp;&amp;</span> <span class="n">rrtype</span> <span class="o">==</span> <span class="n">DNS_TYPE_MX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr_info</span> <span class="o">=</span> <span class="n">tfDnsAllocAddrInfo</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr_info</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">RDLENGTH</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* copy preference value of MX record */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr_info</span><span class="o">-&gt;</span><span class="n">ai_mxpref</span><span class="p">,</span><span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="cm">/* compute the length of the MX hostname */</span>
			<span class="n">labelLength</span> <span class="o">=</span> <span class="n">tfDnsExpLabelLength</span><span class="p">(</span><span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">,</span> <span class="n">dnsHeaderPtr</span><span class="p">,</span> <span class="n">labelEndPtr</span><span class="p">);</span>
			<span class="n">addr_info</span><span class="o">-&gt;</span><span class="n">ai_mxhostname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">labelLength</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* allocate buffer for the expanded name */</span>
				<span class="n">asciiPtr</span> <span class="o">=</span> <span class="n">tfGetRawBuffer</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">labelLength</span><span class="p">);</span>
				<span class="n">addr_info</span><span class="o">-&gt;</span><span class="n">ai_mxhostname</span> <span class="o">=</span> <span class="n">asciiPtr</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">asciiPtr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* copy MX hostname to `asciiPtr` as ASCII */</span>
					<span class="n">tfDnsLabelToAscii</span><span class="p">(</span><span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">,</span> <span class="n">asciiPtr</span><span class="p">,</span> <span class="n">dnsHeaderPtr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="cm">/* ... */</span>
				<span class="p">}</span>
				<span class="cm">/* ... */</span>
			<span class="p">}</span>
			<span class="cm">/* ... */</span>
		<span class="p">}</span>
	<span class="cm">/* ... */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">tt16Bit</span> <span class="nf">tfDnsExpLabelLength</span><span class="p">(</span><span class="n">tt8BitPtr</span> <span class="n">labelPtr</span><span class="p">,</span> <span class="n">tt8BitPtr</span> <span class="n">pktDataPtr</span><span class="p">,</span> <span class="n">tt8BitPtr</span> <span class="n">labelEndPtr</span><span class="p">){</span>
	<span class="n">tt8Bit</span> <span class="n">currLabelLength</span><span class="p">;</span>
	<span class="n">tt16Bit</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">totalLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tt8BitPtr</span> <span class="n">newLabelPtr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">labelEndPtr</span> <span class="o">&amp;&amp;</span> <span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">currLabelLength</span> <span class="o">=</span> <span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">currLabelLength</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">totalLength</span> <span class="o">+=</span> <span class="n">currLabelLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">currLabelLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">labelEndPtr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">newLabelPtr</span> <span class="o">=</span> <span class="n">pktDataPtr</span> <span class="o">+</span> <span class="p">(((</span><span class="n">currLabelLength</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">newLabelPtr</span> <span class="o">&lt;</span> <span class="n">labelPtr</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">labelPtr</span> <span class="o">=</span> <span class="n">newLabelPtr</span><span class="p">;</span>
					<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">totalLength</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>First of all, we understand by the name that <em>resourceRecordAfterNamePtr</em> and <em>dnsHeaderPtr</em> are both pointers and that <em>RDLENGTH</em> since is a length is most likely an unsigned integer.</p>

<p>Then, <em>labelEndPtr</em> pointer gets formed by adding to <em>resourceRecordAfterNamePtr</em> the term <em>10 + RDLENGTH</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">labelEndPtr</span> <span class="o">=</span> <span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">RDLENGTH</span><span class="p">;</span>
</code></pre></div></div>

<p>Then, below, <em>tfDnsExpLabelLength()</em> is called with <em>resourceRecordAfterNamePtr + 0xc, dnsHeaderPtr, labelEndPtr</em> parameters, all user-controlled.</p>

<p>If we look closer at this code we can see that first memory access from <em>labelPtr</em> (which is user-controlled) is being performed and stored in <em>currLabelLength</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>currLabelLength = labelPtr[i];
</code></pre></div></div>

<p>And then several additions are done to create the value <em>totalLength</em>. Since this operations have no validations and there can as many labels as user wants (or said in other words, labelEndPtr is user-controlled and there can be as many iterations as user wants), an integer overflow can be done, returning small <em>totalLength</em> value.</p>

<p>This value is returned in <em>labelLength</em> which is used to allocate memory for a buffer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* allocate buffer for the expanded name */</span>
<span class="n">asciiPtr</span> <span class="o">=</span> <span class="n">tfGetRawBuffer</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">labelLength</span><span class="p">);</span>
</code></pre></div></div>

<p>Thus, the integer overflow can result in a underallocation which later in <em>tfDnsLabelToAscii</em> results in an overcopying vulnerability o buffer overflows.</p>

<p><br /></p>

<h4 id="45-cve-2020-16225">4.5. CVE-2020-16225.</h4>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">////ACID: The data read from staFileHandler</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="n">staFileHandler</span><span class="p">;</span> <span class="c1">//File handler is valid and already points to 0x200 location </span>
                      <span class="c1">//in .sta file being loaded.</span>
<span class="kt">size_t</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">y</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">allocSize</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">memoryAllocation</span><span class="p">;</span>

<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">staFileHandler</span><span class="p">);</span>
<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">staFileHandler</span><span class="p">);</span>
<span class="n">allocSize</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
<span class="n">memoryAllocation</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">allocSize</span><span class="p">,</span> <span class="mh">0x3000</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">fread</span><span class="p">(</span><span class="n">memoryAllocation</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">allocSize</span><span class="p">,</span> <span class="n">staFileHandler</span><span class="p">);</span>
</code></pre></div></div>

<p>Without validation of any type, allocsize is the substraction between two unsigned integer. This can lead to an integer underflow; A huge allocSize value which leads into a huge allocation which later can resultn in an overreading due to the fact that fread() is dumping allocSize bytes from staFileHandler into <em>memoryAllocation + x</em> which is also partially user-controlled.</p>

<p><br /></p>

<h4 id="46-cve-2020-17443">4.6. CVE-2020-17443.</h4>

<p>picoTCP is a lightweight TCP/IP stack designed for embedded systems and IoT devices. The vulnerability exists in the DNS response parsing code, specifically in how the stack handles DNS name compression pointers.</p>

<p>When parsing DNS responses, picoTCP decompresses domain names that use DNS compression (the 0xC0 pointer mechanism). The flaw occurs during length calculation for the decompressed name.</p>

<p>Let’s check the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////ACID: echo</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pico_icmp6_send_echoreply</span><span class="p">(</span><span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="n">echo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pico_icmp6_hdr</span> <span class="o">*</span><span class="n">ehdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rhdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pico_ip6</span> <span class="n">src</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pico_ip6</span> <span class="n">dst</span><span class="p">;</span>

    <span class="n">reply</span> <span class="o">=</span> <span class="n">pico_proto_ipv6</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pico_proto_ipv6</span><span class="p">,</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pico_err</span> <span class="o">=</span> <span class="n">PICO_ERR_ENOMEM</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">echo</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">=</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">+</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">;</span>
    <span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">+</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">;</span>
    <span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span><span class="p">;</span>

    <span class="n">ehdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pico_icmp6_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_hdr</span><span class="p">;</span>
    <span class="n">rhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pico_icmp6_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">transport_hdr</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PICO_ICMP6_ECHO_REPLY</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">echo_reply</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">echo_reply</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">echo_reply</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">echo_request</span><span class="p">.</span><span class="n">seq</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span> <span class="o">-</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">));</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">short_be</span><span class="p">(</span><span class="n">pico_icmp6_checksum</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>
    <span class="cm">/* Get destination and source swapped */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">pico_ipv6_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">net_hdr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">PICO_SIZE_IP6</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">pico_ipv6_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">net_hdr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">PICO_SIZE_IP6</span><span class="p">);</span>
    <span class="n">pico_ipv6_frame_push</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="n">PICO_PROTO_ICMP6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* allocates an IPv6 packet without extension headers. If extension headers are needed,
 * include the len of the extension headers in the size parameter. Once a frame acquired
 * increment net_len and transport_hdr with the len of the extension headers, decrement
 * transport_len with this value.
 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="nf">pico_ipv6_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pico_protocol</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pico_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">IGNORE_PARAMETER</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#ifdef PICO_SUPPORT_6LOWPAN
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PICO_DEV_IS_6LOWPAN</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">pico_proto_6lowpan_ll</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pico_proto_6lowpan_ll</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">));</span>
    <span class="p">}</span>
<span class="cp">#endif
</span>    <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef PICO_SUPPORT_ETH
</span>        <span class="n">f</span> <span class="o">=</span> <span class="n">pico_proto_ethernet</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pico_proto_ethernet</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">));</span>
<span class="cp">#else
</span>        <span class="n">f</span> <span class="o">=</span> <span class="n">pico_frame_alloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span> <span class="o">+</span> <span class="n">PICO_SIZE_ETHHDR</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">f</span><span class="o">-&gt;</span><span class="n">net_len</span> <span class="o">=</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">;</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">net_hdr</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">;</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">transport_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">size</span><span class="p">;</span>

    <span class="cm">/* Datalink size is accounted for in pico_datalink_send (link layer) */</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, lets go part by part:</p>

<ul>
  <li>
    <p>After a few definitions and declarations:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pico_icmp6_hdr</span> <span class="o">*</span><span class="n">ehdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rhdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pico_ip6</span> <span class="n">src</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pico_ip6</span> <span class="n">dst</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Part of the echo contents are dumped on reply structure:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">echo</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">=</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">+</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">;</span>
  <span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">+</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">;</span>
  <span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Thus, this data-piece are user-controlled,</p>
  </li>
  <li>
    <p>Later on the code, and without any previous validation, a memcpy() operation is performed:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">memcpy</span><span class="p">(</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span> <span class="o">-</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">));</span>
</code></pre></div>    </div>

    <p>Observe that, destination, source and the size are essentially user controlled. Since the size is a mathematical operation (a substraction) between a user-controlled data and a constant, potentially leading to an underflow, since the value is casted as an unsigned integer, the underflow would result in basically in a huge value as the size to be copied.</p>

    <p>Thus, this is a what-where-write vulnerability.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="47-cve-2021-30860-forcedentry">4.7. CVE-2021-30860 “FORCEDENTRY”.</h4>

<p>JBIG2 (Joint Bi-level Image Experts Group) is an image compression format. JBIG2 data streams can be embedded into PDF files. PDF files will be automatically processed when delivered to a Mac/iPhone via iMessages</p>

<p>Therefore this is suitable for “zero-click” exploits, where the victim doesn’t need to do anything (like clicking on a file or link) in order to be exploited</p>

<p>Apple had recently introduced a new sandboxing measure (“BlastDoor”) to process ACID in a more restricted environment… but it turns out PDF files were not sandboxed…</p>

<p><br /></p>

<p>Lets check the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">JBIG2SegmentType</span> <span class="p">{</span>
    <span class="n">jbig2SegBitmap</span><span class="p">,</span>
    <span class="n">jbig2SegSymbolDict</span><span class="p">,</span>
    <span class="n">jbig2SegPatternDict</span><span class="p">,</span>
    <span class="n">jbig2SegCodeTable</span>
<span class="p">};</span>

<span class="c1">////ACID: refSegs, nRefSegs</span>
<span class="kt">void</span> <span class="n">JBIG2Stream</span><span class="o">::</span><span class="n">readTextRegionSeg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segNum</span><span class="p">,</span> <span class="n">bool</span> <span class="n">imm</span><span class="p">,</span> <span class="n">bool</span> <span class="n">lossless</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">refSegs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nRefSegs</span><span class="p">){</span>
    <span class="n">JBIG2Segment</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">codeTables</span><span class="p">;</span>
    <span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="n">symbolDict</span><span class="p">;</span>
    <span class="n">JBIG2Bitmap</span> <span class="o">**</span><span class="n">syms</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">huff</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numSyms</span><span class="p">,</span> <span class="n">symCodeLen</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">kk</span><span class="p">;</span>

    <span class="c1">// ...</span>

    <span class="c1">// get symbol dictionaries and tables</span>
    <span class="n">numSyms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRefSegs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">findSegment</span><span class="p">(</span><span class="n">refSegs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegSymbolDict</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">numSyms</span> <span class="o">+=</span> <span class="p">((</span><span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegCodeTable</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">codeTables</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">seg</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">error</span><span class="p">(</span><span class="n">errSyntaxError</span><span class="p">,</span> <span class="n">curStr</span><span class="o">-&gt;</span><span class="n">getPos</span><span class="p">(),</span> <span class="s">"Invalid segment reference in JBIG2 text region"</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>

    <span class="c1">// get the symbol bitmaps</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="p">(</span><span class="n">JBIG2Bitmap</span> <span class="o">**</span><span class="p">)</span><span class="n">gmallocn</span><span class="p">(</span><span class="n">numSyms</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">JBIG2Bitmap</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numSyms</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">syms</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRefSegs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">findSegment</span><span class="p">(</span><span class="n">refSegs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegSymbolDict</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">symbolDict</span> <span class="o">=</span> <span class="p">(</span><span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">symbolDict</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">syms</span><span class="p">[</span><span class="n">kk</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbolDict</span><span class="o">-&gt;</span><span class="n">getBitmap</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can inmediately see that, first an integer’s value (numSyms) is calculated within a for and an if user-controlled statement:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numSyms</span><span class="p">,</span> <span class="n">symCodeLen</span><span class="p">;</span>
<span class="c1">//...</span>
<span class="n">numSyms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRefSegs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">findSegment</span><span class="p">(</span><span class="n">refSegs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegSymbolDict</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">numSyms</span> <span class="o">+=</span> <span class="p">((</span><span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
</code></pre></div></div>

<p>Since there is no validation, this calculation could lead to a integer overflow. Later, this value is used to allocated memory which in combination with the integer overflow risk can lead to an under-allocation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="o">=</span> <span class="p">(</span><span class="n">JBIG2Bitmap</span> <span class="o">**</span><span class="p">)</span><span class="n">gmallocn</span><span class="p">(</span><span class="n">numSyms</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">JBIG2Bitmap</span> <span class="o">*</span><span class="p">));</span>
</code></pre></div></div>

<p>Later, syms pointer gets used in a user-controlled for-loop in which receives data assignation, if an under-allocation gets performed, then this for loop can trigger an overcopying:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRefSegs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">findSegment</span><span class="p">(</span><span class="n">refSegs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegSymbolDict</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">symbolDict</span> <span class="o">=</span> <span class="p">(</span><span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">symbolDict</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">syms</span><span class="p">[</span><span class="n">kk</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbolDict</span><span class="o">-&gt;</span><span class="n">getBitmap</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="48-cve-2021-22636-texas-instruments--freertos-open-source">4.8. CVE-2021-22636. Texas Instruments + FreeRTOS (Open Source).</h4>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int16_t</span> <span class="nf">_BundleCmdSignatureFile_Parse</span><span class="p">(</span>
    <span class="n">OtaArchive_BundleCmdTable_t</span> <span class="o">*</span><span class="n">pBundleCmdTable</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pRecvBuf</span><span class="p">,</span>    <span class="c1">//XENO: ACID: TAR file received over network</span>
    <span class="kt">int16_t</span> <span class="n">RecvBufLen</span><span class="p">,</span>   <span class="c1">//XENO: SACI: Size of TAR file received over network</span>
    <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ProcessedSize</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">SigFileSize</span><span class="p">,</span> <span class="c1">//XENO: ACID: Size from TAR file headers</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pDigest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int16_t</span> <span class="n">retVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span>  <span class="n">pSig</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Get the entire signature file */</span>
    <span class="n">retVal</span> <span class="o">=</span> <span class="n">GetEntireFile</span><span class="p">(</span><span class="n">pRecvBuf</span><span class="p">,</span> <span class="n">RecvBufLen</span><span class="p">,</span> <span class="n">ProcessedSize</span><span class="p">,</span> <span class="n">SigFileSize</span><span class="p">,</span>
                           <span class="o">&amp;</span><span class="n">pSig</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">retVal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">(</span><span class="n">retVal</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">retVal</span> <span class="o">==</span> <span class="n">GET_ENTIRE_FILE_CONTINUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">(</span><span class="n">ARCHIVE_STATUS_BUNDLE_CMD_SIGNATURE_CONTINUE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Verify the signature using ECDSA */</span>
    <span class="n">retVal</span> <span class="o">=</span> <span class="n">verifySignature</span><span class="p">(</span><span class="n">pSig</span><span class="p">,</span> <span class="n">SigFileSize</span><span class="p">,</span> <span class="n">pDigest</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">retVal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_SlOtaLibTrace</span><span class="p">((</span>
                           <span class="s">"[_BundleCmdSignatureFile_Parse] "</span>
                           <span class="s">"signature verification failed!</span><span class="se">\r\n</span><span class="s">"</span><span class="p">));</span>
        <span class="k">return</span><span class="p">(</span><span class="n">retVal</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pBundleCmdTable</span><span class="o">-&gt;</span><span class="n">VerifiedSignature</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">ARCHIVE_STATUS_BUNDLE_CMD_SIGNATURE_DOWNLOAD_DONE</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int16_t</span> <span class="nf">GetEntireFile</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pRecvBuf</span><span class="p">,</span>
                      <span class="kt">int16_t</span> <span class="n">RecvBufLen</span><span class="p">,</span>
                      <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ProcessedSize</span><span class="p">,</span>
                      <span class="kt">uint32_t</span> <span class="n">FileSize</span><span class="p">,</span>
                      <span class="kt">char</span> <span class="o">**</span><span class="n">pFile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int16_t</span> <span class="n">copyLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">bool</span> <span class="n">firstRun</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int16_t</span> <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">firstRun</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="n">RecvBufLen</span><span class="p">;</span>
        <span class="n">firstRun</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">TotalRecvBufLen</span> <span class="o">&lt;</span> <span class="n">FileSize</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Didn't receive the entire file in the first run. */</span>
            <span class="cm">/* Allocate a buffer in the size of the entire file and fill
                it in each round. */</span>
            <span class="n">pTempBuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">pTempBuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="cm">/* Allocation failed, return error. */</span>
                <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">pTempBuf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pRecvBuf</span><span class="p">,</span> <span class="n">RecvBufLen</span><span class="p">);</span>
            <span class="o">*</span><span class="n">ProcessedSize</span> <span class="o">=</span> <span class="n">RecvBufLen</span><span class="p">;</span>

            <span class="cm">/* didn't receive the entire file, try in the next packet */</span>
            <span class="k">return</span><span class="p">(</span><span class="n">GET_ENTIRE_FILE_CONTINUE</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="cm">/* Received the entire file in the first run. */</span>
            <span class="cm">/* No additional memory allocation is needed. */</span>
            <span class="o">*</span><span class="n">ProcessedSize</span> <span class="o">=</span> <span class="n">FileSize</span><span class="p">;</span>
            <span class="o">*</span><span class="n">pFile</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pRecvBuf</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/* Avoid exceeding buffer size (FileSize + 1) */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">RecvBufLen</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">TotalRecvBufLen</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">copyLen</span> <span class="o">=</span> <span class="p">((</span><span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">TotalRecvBufLen</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">copyLen</span> <span class="o">=</span> <span class="n">RecvBufLen</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Copy the received buffer from where we stopped the previous copy */</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pTempBuf</span><span class="p">[</span><span class="n">TotalRecvBufLen</span><span class="p">]),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pRecvBuf</span><span class="p">,</span> <span class="n">copyLen</span><span class="p">);</span>

        <span class="o">*</span><span class="n">ProcessedSize</span> <span class="o">=</span> <span class="n">copyLen</span><span class="p">;</span>
        <span class="n">TotalRecvBufLen</span> <span class="o">+=</span> <span class="n">copyLen</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="n">TotalRecvBufLen</span> <span class="o">&lt;</span> <span class="n">FileSize</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* didn't receive the entire file, try in the next packet */</span>
            <span class="k">return</span><span class="p">(</span><span class="n">GET_ENTIRE_FILE_CONTINUE</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* At this point we have the whole file */</span>
        <span class="o">*</span><span class="n">pFile</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pTempBuf</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Set static variables to initial values to allow retry in 
    case of a warning during the OTA process */</span>
    <span class="n">firstRun</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">GET_ENTIRE_FILE_DONE</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ATTRIBUTE</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Header</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">packet</span> <span class="o">=</span> <span class="p">(</span><span class="n">Header</span> <span class="o">*</span><span class="p">)</span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Header</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">actualBuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">packet</span><span class="p">;</span>
    <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Header</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">packet</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can see that first, pRecvBuf, RecvBufLen and SigFileSize are user-controlled. This values are passed to <em>GetEntireFile()</em> and then they get included in the following code chunk:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int16_t</span> <span class="n">copyLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">firstRun</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int16_t</span> <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">firstRun</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="n">RecvBufLen</span><span class="p">;</span>
    <span class="n">firstRun</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">TotalRecvBufLen</span> <span class="o">&lt;</span> <span class="n">FileSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Didn't receive the entire file in the first run. */</span>
        <span class="cm">/* Allocate a buffer in the size of the entire file and fill
            it in each round. */</span>
        <span class="n">pTempBuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pTempBuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Allocation failed, return error. */</span>
            <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>On it, we can see that firstRun at first gets assgined as TRUE, so the code flow jumps to the second if statement in which it compares TotalRecvBufLen &lt; FileSize, since both values are user-controlled, this statement also is true and then comes malloc with maths over a user-controlled parameter.</p>

<p>Since <em>FileSize</em> is an unsigned integer, this addtion can go to an integer overflow passing from the most bigger value to a small one. Initially, if this was the normal malloc() function, FileSize biggest value should turn the operand 0 and malloc would return to us a NULL pointer, but the current malloc() function is wrapper around pvPortMalloc() function. If we check that implementation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">ATTRIBUTE</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Header</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">packet</span> <span class="o">=</span> <span class="p">(</span><span class="n">Header</span> <span class="o">*</span><span class="p">)</span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Header</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>we can see that in fact is a wrapper around <em>pvPortMalloc()</em> and that if FileSize was a value satisfying:</p>

<pre><code class="language-less">FileSize + 1 + sizeof(Header) = 1
</code></pre>

<p>Assuming that this addition is within the ring of module 32 integers, malloc function should return us a one byte-size pointer. This is, this malloc function is not protected against an underflow provoked by an integer overflow result by the way this function is called.</p>

<p>Automatically below, a memcpy() operation is performed with this underallocated pointer as a destination, using user-controlled values as source and length of the memcpy():</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">pTempBuf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pRecvBuf</span><span class="p">,</span> <span class="n">RecvBufLen</span><span class="p">);</span>
</code></pre></div></div>

<p>Leading to a what-where-write vulnerability.</p>

<p><br /></p>


      </article>

      
        <div class="blog-tags">
          <span>Tags:</span>
          
            <a href="/tags#csoft">csoft</a>
          
        </div>
      

      

      
        <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
    <a href="https://twitter.com/intent/tweet?text=Integer+Overflow%2FUnderflow.&url=http%3A%2F%2Flocalhost%3A4000%2F2025-12-05-IntegerOverflow-Underflow%2F"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fab fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
    <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F2025-12-05-IntegerOverflow-Underflow%2F"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fab fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2F2025-12-05-IntegerOverflow-Underflow%2F"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

  

  

</section>



      

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a class="page-link" href="/2025-12-04-Passing-Parameters/" data-toggle="tooltip" data-placement="top" title="Passing Parameters.">&larr; Previous Post</a>
        </li>
        
        
        <li class="page-item next">
          <a class="page-link" href="/2025-12-05-OtherIntegerIssues/" data-toggle="tooltip" data-placement="top" title="Other Integer Issues.">Next Post &rarr;</a>
        </li>
        
      </ul>
      
  
  
  

  


  



    </div>
  </div>
</div>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="/feed.xml" title="RSS">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">RSS</span>
    </a>
  </li><li class="list-inline-item">
    <a href="mailto:" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/Qv1nTv5" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://twitter.com/Qvintvs1" title="Twitter">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Twitter</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://linkedin.com/in/german-sanmillan-68b308229/" title="LinkedIn">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">LinkedIn</span>
   </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
        German
        &nbsp;&bull;&nbsp;
      
      2026

      

      
      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/assets/js/beautifuljekyll.js"></script>
    
  









</body>
</html>
