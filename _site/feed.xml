<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2026-02-02T18:14:10+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ZKP Research &amp;amp; Notes</title><subtitle>Blog personal sobre Zero-Knowledge Proofs, investigación y apuntes técnicos</subtitle><author><name>German Sanmi</name></author><entry><title type="html">P vs NP.</title><link href="http://localhost:4000/posts/2026/01/11/PvsNP/" rel="alternate" type="text/html" title="P vs NP." /><published>2026-01-11T10:00:00+01:00</published><updated>2026-01-11T10:00:00+01:00</updated><id>http://localhost:4000/posts/2026/01/11/PvsNP</id><content type="html" xml:base="http://localhost:4000/posts/2026/01/11/PvsNP/"><![CDATA[<h2 id="0-index">0. Index.</h2>

<ol>
  <li>
    <p>Introduction: Algorithms and Time Complexity.</p>

    <ul>
      <li>
        <p>1.1. Algorithms.</p>
      </li>
      <li>
        <p>1.2. Time complexity.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Solving problems and verifying solutions.</p>

    <ul>
      <li>
        <p>2.1. Problems.</p>
      </li>
      <li>
        <p>2.2. Definitions. Languages, Decisions Problems, N/DTMs and Time in TMs.</p>

        <ul>
          <li>
            <p>2.2.1. Languages.</p>
          </li>
          <li>
            <p>2.2.2. Decisions Problems and Languages.</p>
          </li>
          <li>
            <p>2.2.3. Turing Machines.</p>
          </li>
          <li>
            <p>2.2.4. Build a Turing machine that accepts a string and increments the number of a's within the string.</p>
          </li>
          <li>
            <p>2.2.5. Time in Turing Machines. Configurations and Computations.</p>
          </li>
          <li>
            <p>2.2.6. Time of a Language: Solvable problems.</p>
          </li>
          <li>
            <p>2.2.7. Time Complexity. Big-O. Efficient algorithms.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Complexity classes: P, NP and PSPACE. PvsNP problem.</p>

    <ul>
      <li>
        <p>3.1 Certificate/verifier characterization of NP. Verification.</p>

        <ul>
          <li>
            <p>3.1.1 Deterministic conception of NP.</p>
          </li>
          <li>
            <p>3.1.2. Formalizing the witness encoding.</p>
          </li>
          <li>
            <p>3.1.3. Generalizating V as a verifier of L.</p>
          </li>
          <li>
            <p>3.1.4. Caracterization of NP. NP deterministic approach.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>3.2. P class: Efficiently solvable problems. Witness.</p>
      </li>
      <li>
        <p>3.3. Problems in PSPACE: Not all problems have solutions that can be efficiently verified.</p>

        <ul>
          <li>
            <p>3.3.1. Space-bounded Turing Machines.</p>
          </li>
          <li>
            <p>3.3.2. Space-problems example.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>3.4. NP. Problems that can be quickly verified but not quickly computed.</p>
      </li>
      <li>
        <p>3.5. Explanation of PvsNP.</p>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h2 id="1-introduction-algorithms-and-time-complexity">1. Introduction: Algorithms and Time Complexity.</h2>

<h3 id="11-algorithms">1.1. Algorithms.</h3>

<p>An algorithm is a finite sequence of well-defined instructions that transforms an input into an output and satisfyies the following three properties:</p>

<ul>
  <li><strong>Definiteness</strong>: Each step has exactly one interpretation.</li>
  <li><strong>Finiteness</strong>: Must terminate after a finite number of steps, not loop infinitely.</li>
  <li><strong>Effectiveness</strong>: Steps are basic enough to be carried out by a computing agent.</li>
</ul>

<p>The following is an example of an algorithm:</p>

<p><br /></p>

<p><strong>Greater Common Divisor</strong></p>

<p>By definition, the greater common divisor of two natural numbers <em>a</em> and <em>b</em> (notated as \(gcd(a,b)\)), is the greater natural that divides those two numbers, this is:</p>

\[g = gcd(a,b) \iff g \in \mathbb{N^*} \ : \begin{cases}
   \ g | a \land g | b \\
   \ \nexists \ d \in \mathbb{N^*} : d | a , d | b  \land   d &gt; g
\end{cases}\]

<p>Note that this is an straight definition but universal and unambiguos declaration would also be:</p>

\[g =  gcd(a,b)\ \Longleftrightarrow\ g \in \mathbb{N}^{*}:\ (g \mid a \wedge g \mid b)\ \wedge\ \forall d \in \mathbb{N}^{*}\big((d \mid a \wedge d \mid b)\Rightarrow d \leq g\big)\]

<p>(We are just saying that for any other integer, being a common divisor of \(a\) and \(b\) implies be smaller or equal than \(g\))</p>

<p><br /></p>

<p>Let's consider \(a,b \in \mathbb{N^*}\) (we can safely assume that is \(a&gt;b\), otherwise \(gcd(a,b) = gcd(a,a) = a\)). Then:</p>

\[\exists (q_1,r_1) \in \mathbb{N^2}: a = bq_1 + r_1 \ \land \ b&gt;r_1 \geq 0\]

<p>For this same reason, it's also true that:</p>

\[\exists (q_2,r_2) \in \mathbb{N}^2 : b = r_1q_2 + r_2 \ \land \ b &gt; r_1 &gt; r_2 &gt;=0\]

<p>Aware that this process is finite, the sequence \(b, r_1, r_2\), and so on are strictly positive and decremental, this means that \(\exists \ n : r_n = 0\).</p>

<p>Since this is just an approach, we don't gonna demonstrate the generic case, although is also easy to extrapolate from a concrete case. Let's suppose that \(r_3 = 0\), thus we would have:</p>

\[a = b·q_1 + r_1 = (r_1·q_2 + r_2)q_1 + r_1 = [(r_2·q_3 + \cancel{r_3})q_2 + r_2]q_1 + r_2·q_3 + \cancel{r_3} = r_2·(q_3q_2q_1 + q_1 + q_3)\]

<p>Thus, that \(a \vert r_2\) and also is evident that \(b \vert r_2\) so this number meets the first condition.</p>

<p><br /></p>

<p>Also, consider from above that every divisor of \(a\) and \(b\) is also divisor of the remainder:</p>

\[\forall d \in \mathbb{Z} : d | a \land d | b \implies d | (a \ \% \ b)\]

<p>So, as also happens that if we call \(r_1 = a \ \% \ b\):</p>

\[d | (a \ \% \ b)  \implies d | (b \ \% \ r_1)\]

<p>This means that the first remainder which also complies to be a divisor of a pair \((a,b) \in \mathbb{N}^2\) is in fact the greatest common divisor since every other divisor of this pair also divides it for being his reminder.</p>

<p>In formal terms, being \((a,b) \in \mathbb{N^*} \times \mathbb{N^*} : a \geq b\), we define the reminder sequence as:</p>

<p><br /></p>

\[(r_i)_{i\in \mathbb{N}} : \begin{cases}
   \  r_0 = a, \  r_1 = b \\
   \ \forall i \geq 1 \ \ \exists q_i \in \mathbb{N} : r_{i-1} = q_ir_i + r_{i+1} \ \land \ 0 \leq r_{i+1} &lt; r_i 
\end{cases}\]

<p><br /></p>

<p>Then, \(\exists! \  n \in \mathbb{N} : (r_n \neq 0 \ \land \ r_{n+1} = 0) \implies r_n =gcd(a,b)\)</p>

<p><br /></p>

<p>Then, if there are \((a,b) \in \mathbb{N^2} : a \geq b &gt; 0\), in order to get the \(gcd(a,b)\) we can make a computing agent to follow a finite sequence of instructions to return the \(gcd(a,b)\):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is an algorthim, we get two values <em>a</em> and <em>b</em> and calculate the reminder, if this is not zero, then calculate the reminder between the second operand of the module operation and the last calculated reminder.</p>

<p>We continue this way until the reminder is 0, this is would mean that, as we see in the demonstration above, the last calculated reminder (keeped in <em>a</em>) is \(gcd(a,b)\).</p>

<p><br /></p>

<h3 id="12-time-complexity">1.2. Time complexity.</h3>

<p>The example above shows in a clear way that the algorthims are structures, finite sequences of intructions, which pretends to automatize large repetitive tasks, in some way they are time-savers machines.</p>

<p>Here we introduced a very important parametter, the time that takes the algoritm to return an output from a given input. This is known as the <em>time complexity</em> problem.</p>

<p>Returning to the <em>gdc()</em> function showed above, given two integers, how many time it would require for the algorithm to return an output is related on how many times the while loop would iterate. In each iteration \(r_1 = a \ \% \ b\) gets computed and then shift the value \((a, b) → (b, r_1)\). So, when the sequence would end depends on how fast the \(b\) operand on \(a \ \% \ b\) operation would decrease.</p>

<p>Note that after two consecutive iterations, the \(b\) value will decrease at least \(a/2\), so after \(2k\) iterations: \(min \ value ≤ b / 2^k\), then the iterations would terminate when \(2^k &gt; b \iff k &gt; log₂(b)\), thus total iterations \(k\) is a function of the logaritm of the minum value of the \((a,b)\)  pair: \(k(a,b) = \mathcal{O}(log(min(a, b)))\).</p>

<p>This means that the number of iterations that will take the algorithm to finish depends of a logaritmic function of the minimum value of the pair which means that this iterations grow slowly as the size of the integer grows:</p>

<table>
  <thead>
    <tr>
      <th>Complexity</th>
      <th>Name</th>
      <th>Growth rate</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>O(1)</td>
      <td>Constant Time</td>
      <td>Instant</td>
    </tr>
    <tr>
      <td>O(log n)</td>
      <td>Logarithmic Time</td>
      <td>Very slow growth</td>
    </tr>
    <tr>
      <td>O(n)</td>
      <td>Linear Time</td>
      <td>Proportional</td>
    </tr>
    <tr>
      <td>O(n²)</td>
      <td>Quadratic/Polynomial Time</td>
      <td>Fast growth</td>
    </tr>
    <tr>
      <td>O(2ⁿ)</td>
      <td>Exponential</td>
      <td>Explodes</td>
    </tr>
  </tbody>
</table>

<p>An algorithm runs in <em>polynomial time</em> when its execution time can be bounded by some polynomial function of the input size.  We say an algorithm takes polynomial time if it runs in \(\mathcal{O}(n^c)\) time or faster, where \(n\) is the size of the input and \(c\) is a non-negative constant. We may refer to algorithms that run in polynomial time or faster as efficient algorithms because their running time doesn’t grow too quickly with the input size.</p>

<p><br /></p>

<h2 id="2-solving-problems-and-verifying-solutions">2. Solving problems and verifying solutions.</h2>

<h3 id="21-problems">2.1. Problems.</h3>

<p>Intimately attached to the idea of <strong>algorithms</strong> are the questions that algorithms are prepared to solve. We define the term <strong>problem</strong> as a specification of what we want to compute, this is; what to be solved by an algorthim implemented on a turing machine (we can think on this as a computin agent that can follow instruction and execute operations based on a language).</p>

<p>Formally, a problem is a relation that maps an input to a set of valid outputs, the algorithm is a set of instructions that a compute agent process to go from the input to an acceptable output.</p>

<p>There are many types of problems we can encounter:</p>

<ul>
  <li><em>Search Problems</em>: Where output is a concrete solution like "find all the posible divisors of 'n'*.</li>
  <li><em>Optimization Problems</em>: Output is the best possible solution "the shortest path between two nodes*.</li>
  <li><em>Decision Problems</em>: Where the output maps over a boolean value (YES/NO, TRUE/FALSE, 1/0), "Is number 'p' prime".</li>
</ul>

<p>For all about we care, we gonna focus on <em>decision problems</em>.</p>

<p><br /></p>

<h3 id="22-definitions-languages-decisions-problems-ndtms-and-time-in-tms">2.2. Definitions. Languages, Decisions Problems, N/DTMs and Time in TMs.</h3>

<h4 id="221-languages">2.2.1. Languages.</h4>

<p>Let's formalize the concept of a <em>decision problem</em>, we already said that a problem is a relation between inputs and outputs. Let's take some definitions:</p>

<ul>
  <li>
    <p>An <em>alphabet</em> is a finite nonempty set of simbols, usually refered as \(\Sigma\). For example, consider:</p>

\[\Sigma = \{0, 1\}\]
  </li>
  <li>
    <p>We also consider the set \(\Sigma^*\) of all posible strings of symbols of \(\Sigma\) (including the empty string \(\epsilon\)). This way, the set of all possible "binary numbers" would be:</p>

\[\Sigma^* = \{0,1\}^* = \{\epsilon,0,1,10,11,110,111,1110,1111,...\}\]

    <p>Considering \(x \in \Sigma^*\) we define as the <em>length</em> of \(x \text { as } \vert x \vert \in \mathbb{N}\); as the number of symbols \(\sigma \in \Sigma\) that constitutes that string.</p>
  </li>
  <li>
    <p>According to this definitions, we define as a <em>language</em>; \(L\) over the <em>alphabet</em> \(\Sigma\) to any subset of \(\Sigma^*\); \(L \subseteq \Sigma^*\).</p>
  </li>
</ul>

<p><br /></p>

<h4 id="222-decisions-problems-and-languages">2.2.2. Decisions Problems and Languages.</h4>

<p>A <em>decision problem</em> (as used in complexity) can be formalized as a Boolean-valued function on strings over a two valids outputs; NO or YES:</p>

\[\Pi : \Sigma^{*} \to \{0,1\}\]

<p>Associated with the previous decision problem is the subset of \(\Sigma^*\) (language) of those elements which maps through \(\Pi\) to a YES.</p>

\[L_{\Pi} = \{x \in \Sigma^* \ | \ \ \Pi(x)= 1\} \subseteq \Sigma^*\]

<p>Observe that this way, we have reduced the problem solution to language membership question.</p>

<p><br /></p>

<p>Also, observe that for any given language \(L \subseteq \Sigma\), we can define an associated decision problem \(\Pi\) as:</p>

\[\Pi_{L}(x)=
\begin{cases}
1 &amp; \text{if } x \in L\\
0 &amp; \text{if } x \notin L
\end{cases} \ : \ x \in \Sigma^*\]

<p>Being:</p>

\[L = \{ x \in \Sigma^* \ | \ \Pi_L(x) =1 \}\]

<p>This essentially means that any decision problem identifies it self with a language and we can talk indiscriminately about decision problems or languages. In this terms, solve a decision problem is equivalent to find a reliable decider of a certain language.</p>

<p><br /></p>

<h4 id="223-turing-machines">2.2.3. Turing Machines.</h4>

<p>A good way to think about a Turing Machine, \(TM\) is as a mathematical abstraction of an algorithm, a formal definition of a computable function.</p>

<p>A (single-tape) Turing Machine consists of:</p>

<ul>
  <li>
    <p>An <strong>infinite tape</strong> divided into cells (memory).</p>
  </li>
  <li>
    <p>A <strong>tape head</strong> that at any moment scans exactly one cell and operate (read, write or move) it.</p>
  </li>
  <li>
    <p>A <strong>finite control unit</strong> which contains internal information divided in a finite amount of pieces, called "states".</p>
  </li>
  <li>
    <p>A <strong>deterministic rule</strong> telling it what to do next based only on:</p>

    <ol>
      <li>
        <p>The current state.</p>
      </li>
      <li>
        <p>The symbol currently under the head.</p>
      </li>
    </ol>
  </li>
</ul>

<p>Computation is discrete: one transition per step.</p>

<p>The following diagram show a representation of what are we talking about:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

                             Finite Control Unit (states Q)
                          ┌──────────────────────────────────┐
                          │ current state: q                 │
                          │ deterministic rule:              │
                          │   δ(q, σ) = (q', b, R)           │
                          └─────────────┬────────────────────┘
                                        │ depends on (current state, symbol under "head")
                                        │ 
                                        ▼
    (Infinite Tape)     … | σ | a | σ | σ | b | σ | σ | a | σ | σ | b | c | c | a | …
                                        ▲
                                        │
                                  ┌─────┴───────────┐
                                  │  Tape Head      │
                                  │ scans 1 cell    │
                                  │ read / write    │
                                  │ move Left/Right │
                                  └─────────────────┘
</code></pre></div></div>

<p>We will come back to this diagram when the components gets explained and acquire full meaning.</p>

<p>For now, think of a Turing Machine as an abstract computing agent that manipulates symbols step by step on an unbounded tape.</p>

<p>Conceptually, it behaves as if it were executing an algorithm: at each step it consults a finite set of rules and updates its state and the tape accordingly, until a task is resolved. (Is worth to mention that the conception of the algorithm as if were an external-separate entity of the computational model is wrong and is only included for pedagogical purpouses, the algorithm is the TM it self, or said in other words, any algorithm is a concrete instance of a Turing Machine).</p>

<p><br /></p>

<p>A deterministic Turing Machine is a 7-tuple</p>

\[M = (Q, \Sigma, \Gamma, \delta, q_0, q_{\mathrm{acc}}, q_{\mathrm{rej}})\]

<p>Where:</p>

<ol>
  <li>
    <p>\(Q\) is a finite, nonempty <strong>set of states</strong>, including the <em>initial</em> state: \(q_0\).</p>

    <p>We will see later what a state is in depth; for now, we can say that a <em>state</em> is a finite piece of internal information that \(M\) uses to make decisions about the next move.</p>

    <p><br /></p>
  </li>
  <li>
    <p>\(\Sigma\) is the <strong>input alphabet</strong>.</p>
  </li>
  <li>
    <p>\(\Gamma\) is the <strong>tape alphabet</strong> which includes a special symbol, \(\square \in \Gamma\) which basically refers to an empty cell in the tape.</p>

\[\Sigma \subseteq \Gamma \ \ \land \ \ \square  \notin \Sigma\]

    <p>The reason why we distinguish between two alphabets is, besides the need of the <em>empty cell</em> conception \(\square\), because remember that \(M\) is the model of an algorithm, which receives an input and transforms it to an output, thus there can be symbols in the output which cannot be part of the input.</p>

    <p>Essentially, \(\Gamma\) is the set of all possible symbols which can be written on the tape, a subset of this one is \(\Sigma\), only the part of \(\Gamma\) that can be part of the input and not of the output.</p>

    <p><br /></p>
  </li>
  <li>
    <p>The <strong>transition function</strong>:</p>

\[\delta : \bigl(Q \setminus \{q_{\mathrm{acc}}, q_{\mathrm{rej}}\}\bigr)\times \Gamma \to Q \times \Gamma \times \{L,R\}\]

\[\delta(q_p,\gamma_q) =
  \ (q_m, \gamma_n, D)\]

    <p>Intuitively, the transition function specifies the next state transited from the current state, which symbol to overwrite the current symbol pointed by the head, and the next head movement (shift).</p>

    <p>Where:</p>

    <ul>
      <li>\(q_{\mathrm{acc}}\): Is the accepted state.</li>
      <li>\(q_{\mathrm{rej}}\): Is the rejected state.</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<p>Thus, lets develop the concepts above more precisely.</p>

<ol>
  <li>
    <p>The \(Q\) set or <em>set of states</em>, is also called; <em>Finite Control Unite</em>.</p>

    <p>When an algorithm transforms an input to an output it performs operations in one or more steps. A <em>state</em> is the abstraction of one of those steps for the Turing Machine in the sense that is used to decide what to do next when the head tape read the tape symbol.</p>

    <p>This abstraction consists in a parameter \(q \in Q\), which is known as a <em>Control Mode</em>, that, in combination with a tape symbol \(\gamma \in \Gamma\), gets associated by \(\delta\) function as a pair \((q, \gamma) \in Q \times \Gamma\)  to a 3-uple \(\delta(q,\gamma)\) which is another pair plus a movement (a shift \(L/R\)) to another cell in the tape. We will get into \(\delta\) soon, for now lets say that \(q\) is a fundamental parameter used to decide which step to take next in the computation chain.</p>

    <p>So, \(\delta(q,\gamma) = (q',\gamma',D)\) gets read as: for state \(q\) if \(\gamma\) is read, then writes \(\gamma'\) on the tape, moves the head one cell in direction \(D\) and enter state \(q'\).</p>

    <p>Note that \(q_{\mathrm{acc}}, q_{\mathrm{rej}}\) are both excluded from the domain of \(\delta\) meaning that those states have no transition, they are the end of the sequence in \(M\).</p>

    <p>In summary, as we said before, this are small pieces of information which \(M\) uses to makes decision about the next move along with other factors.</p>

    <p><br /></p>
  </li>
  <li>
    <p>Input alphabet \(\Sigma\), these are the symbols you allow in the input string, what \(M\) receives as input is a string from \(w \in \Sigma^*\).</p>
  </li>
  <li>
    <p>Tape alphabet \(\Gamma\), symbols that may appear on the tape during computation. It contains the input alphabet (because the input is written on the tape initially), but it can be larger because you may need work symbols / markers or the "blank" symbol, \(\square\).</p>
  </li>
  <li>
    <p>Transition function \(\delta\), this is the computational part of \(M\). For each pair \((q,a)\) of current state \(q\) and scanned symbol \(a\) there is at most one next action (and in the standard definition: exactly one, unless \(q\) is halting (\(q_{\mathrm{acc}}, q_{\mathrm{rej}}\)).</p>

    <p>A value:</p>

\[\delta(q,a) = (q', b, D)\]

    <p>means:</p>

    <ul>
      <li>
        <p>If you are in state \(q\) scanning symbol \(a\).</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DIAGRAM A — “Read” (the configuration that determines δ’s input)

                   Finite Control Unit (states Q)
                    ┌──────────────────────────────────┐
                    │ current state: q                 │
                    │ δ takes input from:              │
                    │   (q, a)                         │
                    └─────────────┬────────────────────┘
                                  │
                                  │  a = symbol currently under head
                                  ▼
  (Infinite Tape)     … | σ | σ | a | σ | σ | …
                                  ▲
                                  │
                             ┌────┴──────┐
                             │ Tape Head │
                             │ reads: a  │
                             └───────────┘
</code></pre></div>        </div>

        <p><br /></p>
      </li>
      <li>
        <p>Write symbol \(b\) in the current cell.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DIAGRAM B — “Apply δ” (computing the unique next action)

                   Finite Control Unit (states Q)
                    ┌──────────────────────────────────┐
                    │ current state: q                 │
                    │ scanned symbol: a                │
                    │                                  │
                    │ δ(q, a) = (q', b, D)             │
                    └─────────────┬────────────────────┘
                                  │
                                  │   next state + write symbol + move dir
                                  ▼
                               OUTPUTS

               next state: q'     write: b     move: D ∈ {L, R}



  DIAGRAM C — “Write” (overwrite the scanned cell with b)

                      Finite Control Unit (states Q)
                       ┌────────────────────────────────┐
                       │ δ(q, a) = (q', b, D)           │
                       │ action step: WRITE b           │
                       └─────────────┬──────────────────┘
                                     │
                                     ▼
    (Infinite Tape)      … | σ | σ | b | σ | σ | …
                                     ▲
                                     │
                                ┌────┴──────┐
                                │ Tape Head │
                                │ wrote: b  │
                                └───────────┘
</code></pre></div>        </div>

        <p><br /></p>
      </li>
      <li>
        <p>Move the head one step in direction \(D \in \{L,R\}\).</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DIAGRAM D — “Move Right” (D = R, head shifts one cell to the right)

                     Finite Control Unit (states Q)
                    ┌──────────────────────────────────┐
                    │ δ(q, a) = (q', b, R)             │
                    │ action step: MOVE RIGHT          │
                    └─────────────────┬────────────────┘
                                      │
                                      ▼
  (Infinite Tape)     … | σ | σ | b | σ | σ | …
                                  │   ▲
                                  │   │
                          (was here)  └── head after move


                     ┌────────────────────────────────┐
                     │ Tape Head now scans next cell  │
                     └────────────────────────────────┘
                                   
                                    




  DIAGRAM E — “Move Left” (D = L, head shifts one cell to the left)

                     Finite Control Unit (states Q)
                    ┌──────────────────────────────────┐
                    │ δ(q, a) = (q', b, L)             │
                    │ action step: MOVE LEFT           │
                    └──────────┬───────────────────────┘
                               │
                               ▼
   (Infinite Tape)     … | σ | σ | b | σ | σ | …
                               ▲   │
                               │   │
                   head after mov  └──── (was here)

                     ┌────────────────────────────────┐
                     │ Tape Head now scans prev cell  │
                     └────────────────────────────────┘
</code></pre></div>        </div>

        <p><br /></p>
      </li>
      <li>
        <p>Change state to \(q'\).</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Diagram F — “State Update” (complete the transition: new configuration)

                     Finite Control Unit (states Q)
                    ┌──────────────────────────────────┐
                    │ BEFORE: state = q                │
                    │ δ(q, a) = (q', b, D)             │
                    │ current state = q'               │
                    └─────────────┬────────────────────┘
                                  │
                                  │ configuration after one step:
                                  │ (new state, updated tape, moved head)
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<p>Before end, is worth to make the distinction between Non-Deterministic Turing Machines; \(NTM\), and Deterministic Turing Machines; \(DTM\).</p>

<p>The difference between those two is that in NTMs, \(\delta\) is a <em>relation</em>, which means that for each input, the output is a subset of the codomain with the posibility that is greater than one:</p>

\[x \in X, \ y = \delta(x) \subset Y: \ |\delta(x)| \leq |Y|\]

<p>where \(\vert \delta(x) \vert\) is \(\delta(x)\)'s cardinality (the number of elements of the set).</p>

<p>While in DTM, \(\delta\) is a <em>function</em> (a partial function to be accurate), which is a restricted subset of the relations. It means that for each input of the domain \(x \in X\), \(\delta\) maps at most (because it could be zero elements to map; partial) with one output</p>

\[y = \delta(x) \subset Y : |\delta(x) | \leq 1\]

<p><br /></p>

<p>To consolidate the concepts, lets take an exercise:</p>

<p><br /></p>

<h4 id="224-build-a-turing-machine-that-accepts-a-string-and-increments-the-number-of-as-within-the-string">2.2.4. Build a Turing machine that accepts a string and increments the number of a's within the string.</h4>

<p>We remember that a Turing Machine, \(M\), gets deined as a 7-upla: \(M = (Q, \Sigma, \Gamma, \delta, q_0, q_{acc}, q_{rej})\). This is the entities we have to define.</p>

<p>First, based on what we know about a Turing machine and how it works, let's think conceptually about how it will work \(M\).</p>

<ul>
  <li>
    <p>The machine starts in a state \(q_0\), in which the string is represented on the tape. The <em>tape head</em> is located above the first letter.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
                       Finite Control Unit (states Q)
                        ┌──────────────────────────────────┐
                        │ current state: q_0               │
                        │ action step: read first cell     │
                        └────────────┬─────────────────────┘
                                     │
                                     ▼
       (Infinite Tape)     … |  |  | h | o | l | a |  |  | …
</code></pre></div>    </div>

    <p><br /></p>
  </li>
  <li>
    <p>The mechanism consists of, whenever it encounters a non-empty symbol, writing the same letter that already exists on the tape in the box, moving to the right, and assigning the state \(q_0\).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                          Finite Control Unit (states Q)
                        ┌───────────────────────────────────┐
                        │ current state: q_0                │
                        │ READ: symbol, h (not blank)       │
                        │ action step:                      │
                        │   writes 'h', assigns q_0, move R │
                        └────────────┬──────────────────────┘
                                     │ R
                                     ▼ &gt; ▼ (next cell to read)
       (Infinite Tape)     … |  |  | h | o | l | a |  |  | …


                          Finite Control Unit (states Q)
                        ┌───────────────────────────────────┐
                        │ current state: q_0                │
                        │ READ: symbol, o (not blank)       │
                        │ action step:                      │
                        │   writes 'o', assigns q_0, move R │
                        └─────────────────┬─────────────────┘
                                          │ R
                                          ▼ &gt; ▼ (next cell to read)
       (Infinite Tape)     …  |  |  | h | o | l | a |  |  | …

       [...]
</code></pre></div>    </div>

    <p><br /></p>
  </li>
  <li>
    <p>When the <em>tape head</em> finds an empty cell, it writes an \(a\), changes the state to \(q_{acc}\) and moves to the right.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                          Finite Control Unit (states Q)
                        ┌────────────────────────────────────┐
                        │ current state: q_0                 │
                        │ READ: symbol, " " (blank)          │
                        │ action step:                       │
                        │  writes 'a', assigns q_acc, move R │
                        └────────────────┬───────────────────┘
                                         │
                                         ▼ &gt; ▼ (next cell to read)
       (Infinite Tape)    … | o | l | a |  |  |  |  |  |  …


                          Finite Control Unit (states Q)
                        ┌──────────────────────────────────────┐
                        │ current state: q_acc (HALT, SUCCESS) │
                        │ READ: symbol, " " (blank)            │
                        │ action step: -                       │
                        │   (q_acc, no action defined)         │
                        └────────────────────┬─────────────────┘
                                             │
                                             ▼
       (Infinite Tape)    … | o | l | a | a |  |  |  |  | …
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<p>Thus, according to our model, we define the following elements:</p>

<ul>
  <li>
\[Q = \{q_0, q_{\mathrm{acc}},q_{\mathrm{rej}}\}\]
  </li>
  <li>\(\Sigma = \{h,o,l,a\}\), \(\Sigma^*=\{\epsilon,h,hh,ho,hola,la,a,...\}\)</li>
  <li>
\[\Gamma = \{\square\} \bigcup \ \Sigma\]
  </li>
  <li>\(\delta : \bigl(Q \setminus \{q_{\mathrm{acc}}, q_{\mathrm{rej}}\}\bigr)\times \Gamma \to Q \times \Gamma \times \{L, R\}\) satisfying:</li>
</ul>

\[\delta(q,\sigma) = \begin{cases}
    \ (q, \sigma, R) \ \ \ \ \ \ \ \forall \sigma \in \Sigma\\
\ (q_{\mathrm{acc}}, a, R) \ \ \ \text{ if } \ \sigma = \square
\end{cases}\]

<p><br /></p>

<h4 id="225-time-in-turing-machines-configurations-and-computations">2.2.5. Time in Turing Machines. Configurations and Computations.</h4>

<p>For a \(M \in DTM\), we define as <em>time</em> as the number of discrete transition steps (a computation) that \(M\) performs before it halts. Relative to a problem, time-solving always refers to the number of steps that the \(M\) requires for solving the problem o, in other words, the maximum transition steps (worst-case number) that would take to solve the problem.</p>

<p>Let \(M\) be a DTM with \(\delta\) his transition function. Let's now fix a conventional input encoding:</p>

<ul>
  <li>Input \(x \in \Sigma^*\) is written on the tape (or input tape) initially.</li>
  <li>The head starts at the leftmost symbol of \(x\).</li>
  <li>The rest of the tape is blank.</li>
  <li>Computation proceeds by repeatedly applying \(\delta\), one application is equal to one transition step.</li>
</ul>

<p><br /></p>

<p>Then, we define as a configuration the 3-upla \(C = (q, t, i)\), where:</p>

<ul>
  <li>\(q \in Q\),</li>
  <li>\(i \in \mathbb{Z}\) refers to the head-tape position,</li>
  <li>
    <p>\(t: \mathbb{Z} \to \Gamma\), is the <em>tape-content</em> function. 
  Observe that, with this convention, \(t(i)\) is the tape-symbol of the cell being pointed by the head-tape of \(M\). We consider the set of all the tape-content function as \(T_M\).</p>

    <p>Note also that whenever a transition takes place in which the tape gets written, \(t\) function gets modified. For example let's say \(x = h\). Then by the convention it would be:</p>

\[t: \mathbb{Z} \to \Gamma\]

    <p>\(t(i) = \ \begin{cases}  \ \square \ \ \ \ \ \forall i \in \mathbb{Z} \setminus\{0\} \\ \ h \ \ \ \ \ \ \text{ if } \ i = 0 \end{cases}\)
  <br /></p>

    <p>Now, a transition step takes place and write \(a\), then \(t\) goes to \(t'\), where:</p>

\[t': \mathbb{Z} \to \Gamma\]

\[t'(i) = \ \begin{cases}  \ \square \ \ \ \ \ \ \ \ \ \forall i \in \mathbb{Z} \setminus\{0,1\} \\ \ t(i) \ \ \ \ \ \ \text{ if } \ i = 0 \\ \ a \ \ \ \ \ \ \ \ \ \  \text{ if } \ i = 1 \end{cases}\]

    <p>This <em>tape-content</em> function acts kind as a log of the symbols present in the tape in a static snapshot of \(M\) in a precise moment.</p>

    <p><br /></p>
  </li>
</ul>

<p>In this context, we read, \(C_i(x)\) as the \(i\)-th configuration of \(M\) processing \(x\), is an abstraction of a snapshot of the relevant features of \(M\) (this are the state, the tape and the head-tape). We also consider \(\Omega_x\) as the set of all the posible 3-uples \(C(x)\).</p>

<p><br /></p>

<p>Being \(C_i(x) = (q, t, n), \ C_j(x) = (q',t',m) \in \Omega_x\), then we define the following one-step transition relation; \(\vdash_{M} \ \subseteq \ \Omega_x \times \Omega_x\)  such as:</p>

\[C_i(x) \vdash_{M} C_j(x) \iff \delta(q,t(n)) = (q',t'(m-1), R) \ \vee \ \delta(q,t(n)) = (q',t'(m+1), L)\ : \ D \in \{L,R\}\]

<p><br /></p>

<p>This means basically that two configurations are sequental if they are immediate transitional steps through \(\delta\) in the processing of \(x\) input. If this condition is meet, then the effects of  \(\delta\) over the \(C_i\) configuration  must reachable by the \(C_j\) configuration in a concrete, well-defined terms.</p>

<p>Consider for example (lets obviate conveniently that in this particular case is \(n=0\) in order to ilustrate the relation showed above):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C_i = (q, t, n)

                            Finite Control Unit (states Q)
                          ┌───────────────────────────────────┐
                          │ current state: q                  │
                          │ READ: t(n) = h                    │
                          │ action step:                      │
                          │   writes 'j', assigns q', move R  │
                          └────────────┬──────────────────────┘
                                       │ 
                                       ▼ 
         (Infinite Tape)     … |  |  | h | o | l | a |  |  | …
                                      

C_j = (q',t', m)


                            Finite Control Unit (states Q)
                          ┌───────────────────────────────────┐
                          │ current state: q'                 │ 
                          │ READ: t'(m) = o                   │
                          │ action step:                      │
                          │   ...                             │
                          └────────────────┬──────────────────┘
                                           │ 
                                           ▼ 
         (Infinite Tape)     … |  |  | j | o | l | a |  |  | …

                                 t'(m - 1) = d(t(n)) = j
</code></pre></div></div>

<p>from a state \(q\) and a current tape symbol \(t(n)\), then \(M\) writes the symbol referenced by \(t'(m)\) and goes to \(q'\), then \(C_i(x)\) and \(C_j(x)\) are sequential.</p>

<p><br /></p>

<p>Having the following scheme, the computation of \(x\) by \(M\) is a finite sequence of configurations,</p>

\[C_{0}(x)\ \vdash_{M}\ C_{1}(x)\ \vdash_{M}\ \cdots\ \vdash_{M}\ C_{p}(x) \ \iff \ C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ : p \in \mathbb{N}\]

<p>where \(C_0(x)\) is the initial configuration, \(\vdash_{M}\) is the “one-step yields” relation, and \(C_t(x)\) is halting, this is usually expresed as \(C_t(x) = (q_{acc}/q_{rej},t,n): t \in T_M, n \in \mathbb{Z}\).</p>

<p>A little parenthesis, we usually refers that, for a given input \(x \in \Sigma^*\), we say that:</p>

\[M \text{ accepts } x \iff \exists ! p \in \mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{acc},t,n)\]

\[M \text{ rejects } x \  \iff  \exists ! p \in \mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{rej},t,n)\]

<p>This is, if exists a finite computation by \(M\) which ends either in \(q_{acc}\) or \(q_{rej}\) states. Note that for DTMs, necesarily \(p\) has to be unique, we will discuss this matter later, after a time definition.</p>

<p><br /></p>

<p>Then, we define two measures of time for DTMs, first, we introduce the time that \(M\) last to process a given input \(x \in X\):</p>

\[\mathrm{Time}_{M}(x)=\min\{\,p\in\mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q,t,n) : q \in \{q_{acc}, q_{rej}\}\}\]

<p>Essentially is the size (in transition steps) of the smallest computation path of \(x\) by \(M\).</p>

<p>Now we extend this concept to the worst-case scenario, consider for any input, \(x \in \Sigma^*\) of size \(n\), the largest time that \(M\) last to process it:</p>

\[t_{M}(n)=\max\{\,\mathrm{Time}_{M}(x) : |x|=n\}\]

<p>Observe that in this case, we are considering the worst-case scenario, the upperlimit of all the possible times. This last definition is what we call the time of \(M\) as an algorithm. So in summary, we are understanding the time that an algorthim last to solve a problem is the <em>number of steps</em> (abstracted those in the chain of configurations of a DTM) the first one needs to compute an input of a determinated size \(n\).</p>

<p><br /></p>

<p>Until here, we defined time for DTMs, we can extend this concept to NTMs.</p>

<p>As a brief reminder, DTM main's feature is that \(\delta\) is a partial function, so there is only one "transition" for a given status and symbol, this means that there is only one unique configuration that follows to a non-halting given one:</p>

\[M \in DTM \Rightarrow \forall C = (q,t,n) : q \in Q \setminus \{q_{\mathrm{acc}},q_{rej}\} \ \exists! \ D : C \vdash_{M}D\]

<p>since each \(D\) is unique, is easy to see that at the end this process lies in a unique computation (which besides is the only existent computation) for each input \(x\) by \(M\):</p>

\[M \in DTM \Rightarrow \forall x\, \forall p\, \forall C\, \forall D\ \bigl(C_{0}(x)\ \vdash_{M}^{\,p}\ C\ \wedge\ C_{0}(x)\ \vdash_{M}^{\,p}\ D\ \Rightarrow\ C=D\bigr)\]

<p>In contrast, in NTMs \(\delta\) is a relation, not a function, which means that can have one or more "one-step transition" configuration for a given configuration, this means that \(D\) is no longer unique:</p>

\[M \in NTM \Rightarrow \forall C = (q,t,n) : q \in Q \setminus \{q_{\mathrm{acc}},q_{rej}\} \ \exists D : C \vdash_{M} D\]

<p>Then, relative to NTMs, we no longer talk about "computation paths" (understand it as single-chains of configuration steps as we seen before) but about <em>branchs of chains of configurations</em>, making look the computation of a given input as a tree, instead of a single path:</p>

\[\begin{cases} C \vdash_{M} C_1 \begin{cases} C_1 \vdash_{M} C_{11} \ \ ...\\ C_1 \vdash_{M} C_{12} \ \ ...\\ ... \\ C_1 \vdash_{M} C_{13}\ \ ...\end{cases} \\ C \vdash_{M} C_2 \begin{cases} C_2 \vdash_{M} C_{21} \ \ ...\\ C_2 \vdash_{M} C_{22} \ \ ...\\ ... \\ C_2 \vdash_{M} C_{23} \ \ ...\end{cases} \\ ... \\ C \vdash_{M} C_m \begin{cases} C_m \vdash_{M} C_{m1}\ \ ... \\ C_m \vdash_{M} C_{m2} \ \ ...\\ ... \\ C_m \vdash_{M} C_{m3} \ \ ...\end{cases} \end{cases}\]

<p>In the nondeterministic case, the notation \(C_0 \vdash_{M}C_p\) is refering to the tree, not a branch in the tree. Also, in the present notes the \(C_0(x) \vdash^p_{M}C_p(x)\) notation can be read as; there exists a computation branch of length \(p\) from \(C_0\) to \(C_p\).</p>

<p><br /></p>

<p>Then we define for \(M \in NTM\):</p>

<ul>
  <li>
    <p>Acceptance (NTM); if there exists at least one halting-branch ending in \(q_{acc}\):</p>

\[M \text{ accepts } x \iff \exists  p \in \mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{acc},t,n)\]
  </li>
  <li>
    <p>Rejects (NTM); if all branches that halts end in \(q_{rej}\), or, equivallently, if no branch halts in \(q_{acc}\):</p>

\[M \text{ rejects } x \  \iff \ \nexists p \in \mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{acc},t,n)\]
  </li>
</ul>

<p><br /></p>

<p>Thus, for NTMs, the time is a bit more complex than for DTMs. Starting by the fact that we distinguish of two time conceptions:</p>

<ul>
  <li>
    <p>In one term, if \(x\) is accepted then it have sense to consider the <em>accepting time</em> as the number of transitional steps in the shortest accepting branch:</p>

\[\mathrm{AccTime}_{M}(x)=\min\{\,p\in\mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{acc},t,n)\}\]
  </li>
  <li>
    <p>But there is a more general and realistic concept of time for NTMs, universal over branches, which is considerate the number of steps of the largest branch (without consider if it halts or not):</p>

\[\mathrm{Time}_{M}(x)=\max\{\,p\in\mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\}\]

    <p>Equivalently, the depth of the computation tree, no upper bound case is considered (the time maybe \(\infty\)). This is the standard definition. Associate with it is the worst-case input-length definition:</p>

\[t_{M}(n)=\max\{\,\mathrm{Time}_{M}(x) : x\in\Sigma^{*},\ |x|=n\,\}\]
  </li>
</ul>

<p><br /></p>

<h4 id="226-time-of-a-language-solvable-problems">2.2.6. Time of a Language: Solvable problems.</h4>

<p>Now that we covered foundational material about Turing Machines, lets how this structure fits in our conception of the decision problems.</p>

<p>As a reminder, we was saying that a decision problem over an alphabet \(\Sigma\) can be understanded as Boolean function \(\Pi: \Sigma^* \to \Set{0,1}\) whose solution eventually lands over a language:</p>

\[L_{\Pi} = \Set{x|\Pi(x)=1} \subseteq \Sigma^*\]

<p>This way, solving \(\Pi\) becomes deciding the membership of \(L_\Pi\), which could be decided by a Turing Machine. That is the formal connection: a decision problem is (identified with) a language and a TM solves it by being a decider for that very language.</p>

<p>Lets be \(M \in TM\) over an alphabet \(\Sigma\), then we say that \(M\) decides \(L \subseteq \Sigma^*\) when:</p>

\[M \text{ accepts } x \iff x \in L \ \ \land \ \  M \text{ rejects } x  \iff x \notin L\]

<p>We say that \(\Pi\) is solvable or has a solution if \(\exists M \in DTM: M \text{ decides } L_\Pi\) (if exists a Turing Machine that decides his solution), we consider the set</p>

\[M_\Pi = \Set{ M | M \text{ decides } L_\Pi} \subseteq DTM\]

<p>With this terms, we can also give a more accurate conception about what \(\Pi(x) = 1\) means;</p>

\[\Pi(x) = 1 \iff \exists M \in M_\Pi : M_\Pi \text{ accepts } x\]

<p>This definition, despite being redundant since it doesnt include any new concept, is more human-friendly because we are just saying that for a decision problem, a given input is part of the solution whenever exists a mecanism (a turing machine mapping the solution of the problem) which accepts this input.</p>

\[L_{\Pi} = \{x \in \Sigma^* \   | \ \exists M \in M_\Pi : M_\Pi \text{ accepts } x\}\]

<p>Let's observe one thing. Despite we consider multiples turing machine that could solve a concrete problem \(\Pi\), \(L_\Pi\) do not depends on the turing machine selected as long as this turing machine is owned by \(M_\Pi\). Consider for example \(N,M \in M_\Pi\) and consider the language</p>

\[L_i = \{x \ | \ i \text{ accepts } x \} \subseteq \Sigma^*\]

<p>for \(i \in TM\).</p>

<p>Then it is:</p>

\[x \in L_N \iff N \text{ accepts } x \iff \Pi(x) = 1 \iff M \text { accepts } x \iff x \in L_M\]

<p>so</p>

\[\forall N,M \in M_\Pi \ \ \ L_N = L_M = L_\Pi\]

<p>This basically means that not matters what TM we consider, all maps \(L_\Pi\) equally since all refers to the \(\Pi\) criteria.</p>

<p>We end saying that we define the <em>resolution-time</em> of a decision problem \(\Pi\) over an alphabet \(\Sigma\) as</p>

\[T_{\Pi}(n)=\inf_{M\in\mathcal{M}_{\Pi}} t_{M}(n)\]

<p>Is worth to note that all the times definition we provided is not are not fixed values, they depends on the input size; \(\vert x \vert\). How the value of this time grows as the length of the input grows is a subject called <em>Time Complexity</em>, and it will be discussed in the next section.</p>

<p><br /></p>

<h4 id="227-time-complexity-big-o-efficient-algorithms">2.2.7. Time Complexity. Big-O. Efficient algorithms.</h4>

<p>Until here, we have a step-count model; \(\mathrm{Time}_{M}(x)\), and the induced worst-case length function time; \(t_M(n)\), and ultimately we defined the time associated with a decision problem as the fastest length function time of the set of the length function time from the turing machines that decides the language associated to that problem \(T_{\Pi}(n)\).</p>

<p>Now, we want to discuss about the <em>upper asymptotic</em> growth of those functions as \(n\to \infty\), which is also called the <em>time complexity</em> subject. We remember briefly that: an asymptote is a line or curve that a function's graph approaches infinitely closely but never touches or crosses as the graph heads toward infinity (or negative infinity).</p>

<p>Big-O notation is a mathematical notation that describes the approximate size of a function on a domain, specifically, Big-O describe an asymptotic upper bound behaviour which is perfect for the time complexity question.</p>

<p>Being \(f,g: \mathbb{N} \to \mathbb{R_+}\) then:</p>

\[f(n)\in \mathcal{O}(g(n))\ \Longleftrightarrow\ \exists c&gt;0,\ \exists n_{0}\in\mathbb{N},\ \forall n\ge n_{0}:\ f(n)\le c\,g(n)\]

<p>This is as far from some point \(n_0\) on the domain; \(f\) is bounded above by a constant multiple of \(g\), meaning that \(f\) grows no faster than \(g\) (up to constants). The \(f\)'s upper behavior is enveloped over the one of a model function \(g\).</p>

<p>Let's observe that this does not mean that \(f\) and \(g\) behaves the same (which would be reasonably to think since we are going to use this notation to refer time functions; "\(f\) is owned by a family of functions that behaves as \(g\)" is what would we be kind to imagine when describing a time function in relation to another). In fact, again, we are not defining the behaviour of \(f\), but his upper asymptotic behavior at some point in the domain which is being described through a model function \(g\) despite constant factors. Also note that no asymptotes are required, that's nomenclature, is just upper behaviour.</p>

<p>This is basically means that from certain point in the domain, \(f\) is as much as bigger as a multiple of \(g\).</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>Name (informal)</th>
      <th style="text-align: right">Typical bound (\(t(n)\in\mathcal O(\cdot)\))</th>
      <th>What it means (intuition)</th>
      <th>Canonical example(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Constant</td>
      <td style="text-align: right">\((1)\)</td>
      <td>Time does not scale with</td>
      <td>Array index access (RAM model), fixed-size checks</td>
    </tr>
    <tr>
      <td>Logarithmic</td>
      <td style="text-align: right">\(log \ n\)</td>
      <td>Each step shrinks problem size by a constant factor</td>
      <td>Binary search; balanced BST search</td>
    </tr>
    <tr>
      <td>Polylogarithmic</td>
      <td style="text-align: right">\((log \ n)^k\)</td>
      <td>Slightly more than logarithmic</td>
      <td>Some advanced data structure ops; certain graph queries</td>
    </tr>
    <tr>
      <td>Sublinear</td>
      <td style="text-align: right">\(n^\alpha \ : \  0&lt;\alpha&lt;1\)</td>
      <td>Reads/uses only a fraction of the input (often not possible if you must inspect all input)</td>
      <td>Property testing (probabilistic), sampling-based algorithms</td>
    </tr>
    <tr>
      <td>Linear</td>
      <td style="text-align: right">\(n\)</td>
      <td>Proportional to input length</td>
      <td>Single pass scan; counting; verification passes</td>
    </tr>
    <tr>
      <td>Linearithmic</td>
      <td style="text-align: right">\(n · log \ n\)</td>
      <td>“Divide-and-conquer + linear combine” pattern</td>
      <td>Merge sort, heap sort; many FFT-like routines</td>
    </tr>
    <tr>
      <td>Polynomial (general)</td>
      <td style="text-align: right">\(n^k : k\ge 1\)</td>
      <td>Considered “efficient/tractable” in complexity theory</td>
      <td>Many classic deterministic algorithms; defines (\mathbf P)</td>
    </tr>
    <tr>
      <td>Exponential</td>
      <td style="text-align: right">\(c^n : c&gt;1\)</td>
      <td>Branching search; scales very poorly</td>
      <td>Brute-force SAT assignment search; subset enumeration</td>
    </tr>
    <tr>
      <td>Factorial</td>
      <td style="text-align: right">\(n!\)</td>
      <td>Enumerating permutations</td>
      <td>Traveling Salesman brute force; permutation search</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>We say that an algorthim runs in a concrete time if its in the Big-\(\mathcal{O}\) family of the prototype function of that set (note also than tehre is an inclusion relation between those sets; \(\mathcal{O}(1) \subset \mathcal{O}(log \ n) \subset ... \subset \mathcal{O}(n^k)\)).</p>

<p>Cobham’s thesis asserts that a computational problem is feasibly/efficiently solvable iff it has an algorithm that runs in <em>polynomial time</em> in the length of the input, often refears as <em>tractable</em> problem. Thus, for all about we concern, we distinguish two types of algorithms; those which runs in polynomial time or less which solves "tractable" problems and those which runs in super-polynomial time.</p>

<p>Note that we refer to Cobham's assertmen as a thesis and not a theorem because it is not a theorem; it is a design choice that turned out to be unusually robust.</p>

<p><br /></p>

<h2 id="3-complexity-classes-p-np-and-pspace--pvsnp-problem">3. Complexity classes: P, NP and PSPACE.  PvsNP problem.</h2>

<p>A complexity class is a set of decision problems (languages) that are solvable within a specified resource budget, typically:</p>

<ul>
  <li>
    <p><em>time</em> (number of steps),</p>
  </li>
  <li>
    <p><em>space</em> (number of tape cells used),</p>
  </li>
</ul>

<p>measured as a function of the input length \(n = \vert x \vert\).</p>

<p><br /></p>

<p>Let's consider the following two sets. For a function \(T:\mathbb{N} \to \mathbb{N}\):</p>

\[DTIME(T(n)) = \{L \subseteq \Sigma^* \ | \ \exists M \in DTM: \big( M \ decides \ L \land \ t_M(n) \in \mathcal{O}(T(n))\big) \}\]

\[NTIME(T(n)) = \{L \subseteq \Sigma^* \ | \ \exists M \in NTM: \big( M \ decides \ L \land \ t_M(n) \in \mathcal{O}(T(n))\big) \}\]

<p>This are basically the class of those languages for which exists respectively a deterministic and no-deterministc Turing machine which decides it in \(T(n)\) time.</p>

<p>Then, we define:</p>

<ul>
  <li>
    <p>\(\mathbf{P}=\displaystyle\bigcup_{k\ge 1}\mathrm{DTIME}(n^{k})\). The class of the languages that can be deterministically decided in polynomial time. This is, that exists a DTM that can decide, for a given input \(x\), if it is \(x \in L\) or \(x \notin L\).</p>
  </li>
  <li>
    <p>\(\mathbf{NP}=\displaystyle\bigcup_{k\ge 1}\mathrm{NTIME}(n^{k})\); Which are the class of the languages for which exists a non-deterministic turing machine that decides it in polynomial time.</p>
  </li>
</ul>

<p>Note that, in this context, if we apply the identification of decisions problems with languages, we are just talking about those problems for which exists, respectively, deterministic and not-deterministic time-efficient solutions. Note that \(P \subseteq NP\).</p>

<p><br /></p>

<h3 id="31-certificateverifier-characterization-of-np-verification">3.1 Certificate/verifier characterization of NP. Verification.</h3>

<h4 id="311-deterministic-conception-of-np">3.1.1 Deterministic conception of NP.</h4>

<p>At this point, “efficient” is being used relative to the underlying machine model: in \(P\) the efficiency bound is measured along the unique deterministic computation, whereas in \(NP\) it is measured along computation branches of a nondeterministic machine.</p>

<p>The relation between these two notions of efficiency is not immediate, because nondeterminism is a theoretical construct rather than a direct physical assumption about how computation is executed. This motivates the distinguition about the abstract models (DTM/NTM) from implementable computation and explain how this leads to a deterministic conception of NP languages as the class of those languages for which exists polynomial-time "verification".</p>

<p>Let's remember acceptance in NTMs. Being \(M \in NTM\), then \(M\) accepts \(x_0 \in \Sigma^*\) is exists at least one branch in the computation halting in \(q_{acc}\):</p>

\[M \text{ accepts } x_0 \iff \exists  p \in \mathbb{N} : C_{0}(x_0)\ \vdash_{M}^{\,p}\ C_{p}(x_0)\ \land \ C_{p}(x_0) = (q_{acc},t,n)\]

<p>Consider as \(c_0: C_{0}(x_0)\ \vdash_{M}\ C_{1}(x_0) \vdash_{M} ... \vdash_{M} C_p(x_0)\) to this single configuration chain. And if we consider \(t_M(n) \in \mathcal{O}(n^k) : k \geq 1\), then we can consider the existence of:</p>

\[V_{x_0} \in DTM :C_{0}(x_0)\ \vdash_{V_{x_0}}^{\,p}\ C_{p}(x_0)\ \land \forall i &lt;p \ \big(C_{i}(x_0)\ \vdash_{V_{x_0}}^\ C_{i+1}(x_0) = C_{i}(x_0)\ \vdash_{M}^\ C_{i+1}(x_0) \in c_0\big)\]

<p>This means basically a deterministic algorthim computing \(x_0\) through the computation accepting-branch of the non-deterministic turing machine.</p>

<p>Let's observe that from the definition of \(V_{x_0}\), the following statements are immediately follow:</p>

<ul>
  <li>
    <p>Let's consider \(w_0\) a codification of the following statement:</p>

\[C_{0}(x_0)\ \vdash_{V_{x_0}}^{\,p}\ C_{p}(x_0)\ \land \forall i &lt;p \ \big(C_{i}(x_0)\ \vdash_{V_{x_0}}^\ C_{i+1}(x_0) = C_{i}(x_0)\ \vdash_{M}^\ C_{i+1}(x_0)\big)\]

    <p>such as \(V_{x_0}(x_0,w_0) = 1 \iff C_{p}(x_0) = (q_{acc},t,n)\), then</p>

\[M \text{ accepts } x_0 \iff \exists w_0:V_{x_0}(x_0,w_0)=1\]

    <p>And it also have an immediate corolary; if \(M\) is a decider of \(L \subseteq \Sigma^*\), then:</p>

\[x_0 \in L \iff \exists w: V_{x_0}(x_0,w_0)=1\]
  </li>
  <li>
    <p>For \(V\) as is described before is: \(\ Time_V(x_0) \in \mathcal{O}(n^k) : k \geq 1\)</p>

    <p>From the definition is known that: \(\mathrm{Time}_{V_{x_0}}(x_0) = AccTime_M(x_0) \leq t_M(n) \in \mathcal{O}(n^k) \ \Rightarrow \ \mathrm{Time}_{V}(x_0) \in \mathcal{O}(n^k)\), so \(V_{x_0}\) computes \(x_0\) in polynomial time.</p>

    <p><br /></p>
  </li>
</ul>

<p>We refer to \(w_0\) as the witness and \(V_{x_0}\) as the <em>verifier</em> of the pair \((x_0,w_0)\).</p>

<p>We can think of \(w_0\) as a piece of encoded information about how a deterministic turing machine (\(V_{x_0}\)) have to compute the specific \(x_0 \in \Sigma^*\) input to obtain a halt-accepted configuration \(C_p\) equivalent to the one reached by \(M \in NTM\).</p>

<p><br /></p>

<h4 id="312-formalizing-the-witness-encoding">3.1.2. Formalizing the witness encoding.</h4>

<p>Let's now formaly nail the formulation of \(w_0\).</p>

<p>We can reformulate what we understand as an accepting branch for \(x_0\) like a finite sequence of configurations:</p>

\[c_0 = (C_0,C_1,...,C_p): C_0 = C_0(x_0)  \ \land \ C_p = (q_{acc},t,n) \ \land \ C_i \vdash_{M} C_{i+1} \ \ \forall i &lt; p\]

<p>Then, from this point, we can define a <em>witness</em> as an encoding of this accepting branch in a string of symbols of the input alphabet of \(M\), \(w_0 = enc(c_0) \in \Sigma^*\). Let's observe that as a string of symbols, this witness is only encoding a path in the computation tree of \(M\), a sequence of nondeterministc choices.</p>

<p>Since we are considering \(M\) as a decider NTM, then  infinit branchs are out of scope and we can consider for any given computation, the set of the succesors from a departing configuration:</p>

\[Succ(C) = \{D : C \vdash_{M} D\} : |Succ(C)| \leq b \in \mathbb{N}\]

<p>observe we can fix this set to consider the deterministic ordering of successors for each C:</p>

\[Succ(C) = (D_{C,1},D_{C,2},...,D_{C,m_C}):1\leq m_C \leq b\]

<p><br /></p>

<p>Now, given a branch, like \(c_0 = (C_0,...,C_p)\), define its choice sequence as the set: \(choice(c_0) = (a_0,...,a_{p-1})\) where each \(a_i \in {0,...,b}\) is an index such \(C_{i+1} = D_{C_i,a_i}\), an identifier for any deterministical succesor in the branch.</p>

<p>So essentially, we are providing a deterministic methodology for mapping the branch \(c_0\), as in \(Succ(D_c)\) choose \(a_1\) which leads to \(D_{C,1} = C_1\). Now for \(Succ(D_{C_1})\) choose \(a_2\) which will lead to \(D_{C,2} = C_2\) and so on. Now, lets find a way to encode this information in the witness \(w\).</p>

<p><br /></p>

<p>Considering the alphabet \(\{0,1\}\), we define \(w_0 \in \{0,1\}^*\). Since \(a_i\) as described before, are just natural numbers, we can encode them in binary an concibe:</p>

\[w_0 := \mathrm{enc}(\pi) = \mathrm{bin}_{m}(a_{0})\,\mathrm{bin}_{m}(a_{1})\cdots \mathrm{bin}_{m}(a_{p-1}) \in \{0,1\}^{mp},\]

<p>This way, without entering in details, \(w\) is a string of \(m=log_2b\) length blocks of bits encoding \(a_i\) numbers. Thus, a deterministic TM could be craft to do:</p>

<ul>
  <li>Start at \(C_0(x)\).</li>
  <li>At step \(i\), read the \(i\)-th block \(bin_m(a_i)\) from \(w_0\). If \(a_i &gt; m_{C_i}\) rject, otherwise, \(C_{i+1} := D_{C_i,a_i}\)</li>
  <li>Continue up to most \(T(\vert x \vert)\) steps and accept iff an accepting configuration is reached.</li>
</ul>

<p>So we have demonstrated that \(w\) is a piece of encoding information polynomially bounded in \(\vert x \vert\).</p>

<p><br /></p>

<h4 id="313-generalizating-v-as-a-verifier-of-l">3.1.3. Generalizating V as a verifier of L.</h4>

<p>At this point, we have a strong conception for \(w_0\), but we only concibed \(V_{x_0}\)  and \(w_0\) as a mecanism specific for a given input, \(x_0\). Let's now formalize this idea for a language \(L\).</p>

<p>Since \(w_0\) departs from an accepting branch \(c_0\) in the computation tree of \(x_0 \in \Sigma^*\) by \(M\) and \(V_{x_0}\) is a deterministic mecanism that computes \(x_0\) using \(c_0\) follwing \(w_0\), we can now consider a generic case of \(V_{x_0}\) for a language \(L \subseteq \Sigma^*\).</p>

<p>Considering a \(L\subseteq \Sigma^*\) and \(M \in NTM: M \ decides \ L\). Then we can consider \(x \in L\) and \(c\) the accepting-halting branch of the computation \(C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\).</p>

<p>Then we define \(V \in DTM\) in a manner that garantee a finite computation of \(x\) following the non-deterministical choices of \(C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\) to ultimately reaching the same accepted-halt configuration \(C_p\).</p>

<p>Formaly \(V\), as defined above, satisfies:</p>

\[\forall x \in L \ \exists p \in \mathbb{N} : \Big(C_{0}(x)\ \vdash_{V}^{\,p}\ C_{p}(x)\ \land \forall i &lt;p \ \big(C_{i}(x)\ \vdash_{V_{x_0}}^\ C_{i+1}(x) = C_{i}(x)\ \vdash_{M}^\ C_{i+1}(x) \in c\big)\Big)\]

<p>In this terms, encoding \(c\) in \(w\) as seen before, we also define:</p>

\[V(x,w) = 1 \iff C_p = (q_{acc},t,n)\]

<p>and reformulate the caracterization of \(V\) as:</p>

\[\forall x \in L \  \exists w : |w| \in \mathcal{O}(|x|^k) \ \land \ V(x,w) = 1\]

<p>The \(\vert w \vert \in \mathcal{O}(\vert x \vert^k)\) condition refers that the encoding uses an reasonable amount of space resources.</p>

<p>And ultimately we can say that \(V\) is a verifier of \(L\):</p>

\[\forall x\in \Sigma^* \ \big( x\in L \iff \exists w : |w| \in \mathcal{O}(|x|^k) \ \land \ V(x,w) = 1 \big)\]

<p>Observe that also is:</p>

\[x \notin L \ \iff \ \forall w\ \bigl(|w|\le p(|x|)\ \Rightarrow\ V(x,w)=0\bigr)\]

<p>Is worth to note that \(t_M(n) \in \mathcal{O}(f(n)) \Rightarrow t_V(n) \in \mathcal{O}(f(n))\) since we are refering to computations build from non-deterministic choices.</p>

<p>Informaly, we can say that a <em>verifier</em> is kind of a <em>decider</em> with some aid.</p>

<p><br /></p>

<h4 id="314-caracterization-of-np-np-deterministic-approach">3.1.4. Caracterization of NP. NP deterministic approach.</h4>

<p>Reaching this point, having understanded that, for a non-deterministic machine, we always can think about a deterministic machine that can compute a set of nondeterministical choices reaching the same accepting-halted configuration for a given input having the aid of encoding information. We can now present a deterministic conception of \(NP\) as the class of the languages that can be verified in polynomial time, which is in fact.</p>

<p><br /></p>

<p>First of all, we've already seen that for a language \(L \subseteq \Sigma^*\) and \(M \in NTM\) exists \(V \in DTM\) that acts as a verifier for \(L\) running in the same time that \(M\) if \(t_M(n) \in \mathcal{O}(n^k)\), so fixing \(t_M(n) \in \mathcal{O}(n^k)\) we can say that any \(L \in NP\) has a verifier running in polynomial time.</p>

<p><br /></p>

<p>Also, considering \(L\) a language that has a verifier \(V\) running in polynomial time, then, we can consider a \(M \in NTM\) running also in polynomial time that has one branch that reproduce the deterministic path of \(V\) for any \(x \in L\). Then \(M\) becomes a decider of \(L\) and \(L \in NP\).</p>

<p><br /></p>

<p>This two approachs, despite they lacks of formalization and are poorly accurate, are enough to see that is not dificult too imagine the existing equivalence between those two classes once the idea of the verifier and the witness are formally understanded. Then, \(NP\) can be considered as the class of those languages for which exists a verifier which runs in polynomial time.</p>

<p>Thus, essentially we have:</p>

<ul>
  <li>
    <p>\(\mathbf{P}=\displaystyle\bigcup_{k\ge 1}\mathrm{DTIME}(n^{k})\). The class of the languages that can be deterministically decided in polynomial time. This is, that exists a DTM that can decide, for a given input \(x\), if it is \(x \in L\) or \(x \notin L\).</p>
  </li>
  <li>
    <p>\(\mathbf{NP}= \{ \ L \ \vert \  \forall x \ \big( x\in L \iff \exists w : \vert w \vert \in \mathcal{O}(\vert x \vert^k) \ \land \ V(x,w) = 1 \big)\}\); Which are the class of the languages that can be verified in polynomial time.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="32-p-class-efficiently-solvable-problems-witness">3.2. P class: Efficiently solvable problems. Witness.</h3>

<p>Let's review some examples for \(P\) class:</p>

<ul>
  <li>
    <p><strong>Sorting a list</strong>: we can efficiently sort a list in \(\mathcal{O}(n·log(n))\) with <em>mergesort</em>, check that \(log(n) &lt; n\) for any base bigger than 1, so \(n·log(n) &lt;n^2\) and this it is indeed a polynomial-time algorithm. Also and we can efficiently verify that a list is sorted in \(\mathcal{O}(n)\).</p>
  </li>
  <li>
    <p><strong>Returning the index of a number in a list, if it occurs in the list</strong>: Taking a given list, we can sort it in a \(\mathcal{O}(n)\) time while check if a given number of the list is in a position is inmediate \(\mathcal{O}(1)\).</p>
  </li>
  <li>
    <p><strong>Determining if two nodes in a graph are connected</strong>: We can efficiently determine if two nodes in a graph are connected by using breadth-first search; start at a node, then visit all of its neighbors except nodes we’ve already visited, then search the neighbors of the neighbors, and so forth.  Discovering the path between nodes using breadth-first search will take \(\mathcal(O)(n + e)\) time, where  is the number of nodes in the graph and  is the number of edges. We can verify the proposed path is valid in \(\mathcal(O)(n)\) time simply by following the proposed path to see if the two points really are connected by that path.</p>
  </li>
</ul>

<p>In all the examples above, both computing and verifying the solution can be done in polynomial time</p>

<p><br /></p>

<p><strong>Witness example</strong></p>

<p>When we discussed \(NP\) class we define what a <em>witness</em> was, a piece of encoded information that helps a verifier (deterministic turing machine) to perform a verification about some given input for a decision problem. We rememeber that this means; if the verifier accepts the pair, then the input is part of the solution of the problem, if not, is not conclusive, it may be problem of the verifier.</p>

<p>Expanding this concept, at a high-level, in computer science we can think on a <strong>witness</strong> as a proof of you solve an instance of the problem, that a particular input is a YES-instance.</p>

<p>A witness can be a direct solution to the problem. For the examples above, that can be solved deterministically, these are things we could use as a witness:</p>

<ul>
  <li>The sorted list</li>
  <li>The index where a number appears in the list</li>
  <li>The path between two nodes in a graph</li>
</ul>

<p>But in most cases a witness does not necessarily have to be a direct solution to a problem, or, in other words, the solution to the original problem. This is essentially true when a deterministic approach is not efficient at a first glance. This is when the idea of the verifier as separate entity and the witness gains more weight. Then, the verifier can be thinked as a deterministic algorithm that decides an alternative representation of the same problem.</p>

<p><br /></p>

<p>For example, consider the following question: "Given a number \(n\), is \(n\) composite?". The direct solution would be: find two integers \(a,b&gt;1\) such that \(n=ab\). If we have for example the number \(341\) the direct solution would be: \(341 = 11·31\), so its composite.</p>

<p>But we can provide a different proof avoiding the factorization.</p>

<p>We know that if a number cannot be decomposite in factors different from one and him self, then is <em>prime</em>, so demonstrate that a number is prime is the boolean-opposite to demonstrate that is composite.</p>

<p>For this matters, we can use the <em>Miller–Rabin primality test</em>, which says that:</p>

<p>For a given odd integer \(n &gt; 2\), let’s write \(n − 1\) as \(2^sd\) where \(s\) is a positive integer and 
\(d\) is an odd positive integer. Let’s consider an integer \(a\), which is coprime to \(n\). Then, \(n\) is said to be a <em>strong probable prime</em> to base \(a\) if one of these congruence relations holds:</p>

<ul>
  <li>
\[a^d \equiv 1 \pmod n\]
  </li>
  <li>
\[\exists r \in \mathbb{Z}: 0 \leq r &lt; s \land a^{2^rd} \equiv -1 \pmod n\]
  </li>
</ul>

<p>We were saying that \(p=341\), then \(a=2\) (obviously a coprime), so \(p−1=340 = 2^{2}·85\), then:</p>

\[a^d \equiv 1 \pmod n \iff 2^{85} \ mod \ 341 = 32\]

<p>So this fails the first test, the second test requires the retest with \(r\) between 0 and 1, we already now that (for \(r = 0\)) \(32 \neq -1\), so for \(r=1\):</p>

\[2^{2·85} \ mod \ 341 = 2^{170} \ mod \ 341 = 1 \neq -1\]

<p>This means that, for base \(2\), our integer do not satisfies any of the condition to be likely a prime, which means that definitively is not a prime.</p>

<p>Then, in therms of computation, the integer \(a=2\) applied to the theorem above is our <em>witness</em> to the decision problem we propose at the init: \(341\) is prime?. The primality test could be thinked as the verifier \(V\), and being \(V(2,341) = 1\) (since it fails both test so is not primal, otherwise it would be strongly probable a primal, but not definitive a primal) is equivalent to solve the question about if it is composite which was our original decision problem.</p>

<p><br /></p>

<h3 id="33-problems-in-pspace-not-all-problems-have-solutions-that-can-be-efficiently-verified">3.3. Problems in PSPACE: Not all problems have solutions that can be efficiently verified.</h3>

<p>We talked about two class which have conditions that consider the time in which a problem can be either verified or solved by a deterministic model. In this case, PSPACE consider the space inversion amount, the only requirement relative to time is that eventually finish.</p>

<p><br /></p>

<h4 id="331-space-bounded-turing-machines">3.3.1. Space-bounded Turing Machines.</h4>

<p>Being \(M \in DTM\) with \(\Gamma\) being the tape alphabet, we recover that a configuration \(C = (q,t,n): q \in Q, t:\mathbb{Z} \to \Gamma, n \in \mathbb{Z}\).</p>

<p>Then, consider the halting computation \(C_0(x) \vdash_M C_1(x) \vdash_M ... \vdash_M C_p(x)\), then we would write \(C_i(x) = (q_i,t_i,n_i)\). We define</p>

\[Space_M(x):= |\{\ n_i \ | \ 0 \leq i \leq p\ \}|\]

<p>If \(n\) reflects in \(C = (q,t,n)\) in which cell of the tape is the head tape on that current snapshot, then, we are just considering the number of all different cell tapes the head visit on the computation of a given input.</p>

<p>Then, for a function \(s:\mathbb{N} \to \mathbb{N}\):</p>

\[DSPACE(s(n)) = \{ L \subseteq \Sigma^* \ | \ \exists \ M \in DTM \ deciding \ L: space_M(x) \in s(|x|)\}\]

<p>this is, the set of those lanmguages for which exists a DTM that have a usespace function upper bounded by \(s(\vert x \vert)\).</p>

<p>We define \(PSPACE\) as set of those DSPACES for polynomial use-space function:</p>

\[PSPACE = \displaystyle\bigcup_{k \in \mathbb{N}} DSPACE(n^k)\]

<p>This are all of those problems that can be decide with a reasonable amount of space.</p>

<p>The relation withother class discussed before is:</p>

\[P\subseteq NP\subseteq PSPACE\]

<p><br /></p>

<h4 id="332-space-problems-example">3.3.2. Space-problems example.</h4>

<p>This class of problems has been researched extensively, yet no efficient algorithm to solve them has been discovered. Many researchers believe no efficient algorithm to solve these problems exists at all. If an efficient solution to these problems could be discovered, it would also be possible to reuse the algorithm to break all modern encryption and fundamentally alter computing as we know it.</p>

<p>Despite significant incentives for finding efficient solutions to these problems, evidence suggests such solutions likely do not exist. These problems are so challenging that you cannot provide easily verifiable proof (witness) even if you solve them correctly.</p>

<p>Let see some examples:</p>

<ul>
  <li>
    <p><em>Given an started chess-state, find the optimal chess move</em>. If we ask a computer about the optimal next move for a given position, the computer give a straight answer based on a calculation of all the future game-state from the given position. There is no efficient way to check the best move, and as you optimize the calculation about the move more resource you need to invest.</p>
  </li>
  <li>
    <p><em>Determining if regexes (regular expressions) are equivalent</em>. Checking if two arbitrary regexes are equivalent takes exponential time to compute. Even if a powerful computer told you they match the same strings, there is no short proof (witness) the computer can give you to show the answers are correct. Similar to the chess example, you’d have to search a very large space of strings to check if the regexes are equivalent, and that will take exponential time.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="34-np-problems-that-can-be-quickly-verified-but-not-quickly-computed">3.4. NP. Problems that can be quickly verified but not quickly computed.</h3>

<p>If we can quickly verify the solution to a problem, then the problem is in NP. However, finding the solution might require exponential resources.</p>

<p>As we say before: any problem whose proposed solution (witness) can be quickly verified as correct is an NP problem. If the problem also has an algorithm for finding the solution in polynomial time, then it is a P problem. All P problems are NP problems, but it is extremely unlikely that all NP problems are also P problems.</p>

<p>Let's check some examples:</p>

<ul>
  <li>
    <p><em>Sudoku</em>: Given a Sudoku puzzle solution, we can quickly verify the solution is correct simply by looping over the columns and rows. The witness can be verified in polynomial time. However, computing the solution requires significantly more resources — there are an exponential number of combinations to search. Note that as the sudoku grows, the time needed to check the solution grows exponentially.</p>
  </li>
  <li>
    <p><em>Three-coloring a map</em>: Any 2D map of territories can be “colored” with just four colors (see the four color theorem). That is, we can assign a unique color (one of four colors) to each territory such that no neighboring territories share the same color. The three-coloring problem asks whether a map can be colored using just three colors instead of four. Discovering a three-coloring (if it exists) is a computationally intensive search problem. However, verifying a proposed 3-coloring is easy: loop through each of the regions and check that no neighboring regions have the same color of the territory currently being checked.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="35-explanation-of-pvsnp">3.5. Explanation of PvsNP.</h3>

<p>Now that we have a solid understanding about, what P, NP are. Lets face some core question about complexity theory.</p>

<ul>
  <li>
    <p>First, we did see that \(P\) is the class of problems for which exists a deterministical solution running in polynomial time (efficient time),</p>
  </li>
  <li>
    <p>Then, we see that \(NP\) is the class of those languages that admit a non-deterministical but never the less time-efficient solution and also we see that a deterministical perspective of NP problems is needed. That was the characterization of NP as the class of those languages that admit a verification in polynomial time.</p>
  </li>
</ul>

<p>Now, a convenient question is put on the table. Do thouse quick verificable problems admit a efficient solution also? Or said in other words, is NP part of P?</p>

\[P \supseteq NP\]

<p>Remember that above we said that \(P \subseteq PN\), both statements together are equal to propose the equivalence between those two setsL</p>

\[P \subseteq NP \land P \supseteq NP \iff P = NP\]

<p>This is, <em>any problem that can be efficiently verified can also be efficienctly decided</em>?</p>

<p>\(P = NP\) is a powerful statement, it would mean that whenever we can find an efficient verifier for a YES-instance input of a decision problem, we can be sure that there exists also an efficient solution that decides the problem.</p>

<p><br /></p>

<p>As a summary, we dedicated a part of the course to understand PvNP subject (among with turing machine, efficient time-solving problems, etc) because ZK cares about the verifying aspect of the computation, this means, to the subject of develop a witness that efficiently proof a YES-instance of a problem.</p>]]></content><author><name>German Sanmi</name></author><category term="Maths" /><category term="mathematics" /><category term="theory" /><summary type="html"><![CDATA[0. Index. Introduction: Algorithms and Time Complexity. 1.1. Algorithms. 1.2. Time complexity. Solving problems and verifying solutions. 2.1. Problems. 2.2. Definitions. Languages, Decisions Problems, N/DTMs and Time in TMs. 2.2.1. Languages. 2.2.2. Decisions Problems and Languages. 2.2.3. Turing Machines. 2.2.4. Build a Turing machine that accepts a string and increments the number of a's within the string. 2.2.5. Time in Turing Machines. Configurations and Computations. 2.2.6. Time of a Language: Solvable problems. 2.2.7. Time Complexity. Big-O. Efficient algorithms. Complexity classes: P, NP and PSPACE. PvsNP problem. 3.1 Certificate/verifier characterization of NP. Verification. 3.1.1 Deterministic conception of NP. 3.1.2. Formalizing the witness encoding. 3.1.3. Generalizating V as a verifier of L. 3.1.4. Caracterization of NP. NP deterministic approach. 3.2. P class: Efficiently solvable problems. Witness. 3.3. Problems in PSPACE: Not all problems have solutions that can be efficiently verified. 3.3.1. Space-bounded Turing Machines. 3.3.2. Space-problems example. 3.4. NP. Problems that can be quickly verified but not quickly computed. 3.5. Explanation of PvsNP. 1. Introduction: Algorithms and Time Complexity. 1.1. Algorithms. An algorithm is a finite sequence of well-defined instructions that transforms an input into an output and satisfyies the following three properties: Definiteness: Each step has exactly one interpretation. Finiteness: Must terminate after a finite number of steps, not loop infinitely. Effectiveness: Steps are basic enough to be carried out by a computing agent. The following is an example of an algorithm: Greater Common Divisor By definition, the greater common divisor of two natural numbers a and b (notated as \(gcd(a,b)\)), is the greater natural that divides those two numbers, this is: \[g = gcd(a,b) \iff g \in \mathbb{N^*} \ : \begin{cases} \ g | a \land g | b \\ \ \nexists \ d \in \mathbb{N^*} : d | a , d | b \land d &gt; g \end{cases}\] Note that this is an straight definition but universal and unambiguos declaration would also be: \[g = gcd(a,b)\ \Longleftrightarrow\ g \in \mathbb{N}^{*}:\ (g \mid a \wedge g \mid b)\ \wedge\ \forall d \in \mathbb{N}^{*}\big((d \mid a \wedge d \mid b)\Rightarrow d \leq g\big)\] (We are just saying that for any other integer, being a common divisor of \(a\) and \(b\) implies be smaller or equal than \(g\)) Let's consider \(a,b \in \mathbb{N^*}\) (we can safely assume that is \(a&gt;b\), otherwise \(gcd(a,b) = gcd(a,a) = a\)). Then: \[\exists (q_1,r_1) \in \mathbb{N^2}: a = bq_1 + r_1 \ \land \ b&gt;r_1 \geq 0\] For this same reason, it's also true that: \[\exists (q_2,r_2) \in \mathbb{N}^2 : b = r_1q_2 + r_2 \ \land \ b &gt; r_1 &gt; r_2 &gt;=0\] Aware that this process is finite, the sequence \(b, r_1, r_2\), and so on are strictly positive and decremental, this means that \(\exists \ n : r_n = 0\). Since this is just an approach, we don't gonna demonstrate the generic case, although is also easy to extrapolate from a concrete case. Let's suppose that \(r_3 = 0\), thus we would have: \[a = b·q_1 + r_1 = (r_1·q_2 + r_2)q_1 + r_1 = [(r_2·q_3 + \cancel{r_3})q_2 + r_2]q_1 + r_2·q_3 + \cancel{r_3} = r_2·(q_3q_2q_1 + q_1 + q_3)\] Thus, that \(a \vert r_2\) and also is evident that \(b \vert r_2\) so this number meets the first condition. Also, consider from above that every divisor of \(a\) and \(b\) is also divisor of the remainder: \[\forall d \in \mathbb{Z} : d | a \land d | b \implies d | (a \ \% \ b)\] So, as also happens that if we call \(r_1 = a \ \% \ b\): \[d | (a \ \% \ b) \implies d | (b \ \% \ r_1)\] This means that the first remainder which also complies to be a divisor of a pair \((a,b) \in \mathbb{N}^2\) is in fact the greatest common divisor since every other divisor of this pair also divides it for being his reminder. In formal terms, being \((a,b) \in \mathbb{N^*} \times \mathbb{N^*} : a \geq b\), we define the reminder sequence as: \[(r_i)_{i\in \mathbb{N}} : \begin{cases} \ r_0 = a, \ r_1 = b \\ \ \forall i \geq 1 \ \ \exists q_i \in \mathbb{N} : r_{i-1} = q_ir_i + r_{i+1} \ \land \ 0 \leq r_{i+1} &lt; r_i \end{cases}\] Then, \(\exists! \ n \in \mathbb{N} : (r_n \neq 0 \ \land \ r_{n+1} = 0) \implies r_n =gcd(a,b)\) Then, if there are \((a,b) \in \mathbb{N^2} : a \geq b &gt; 0\), in order to get the \(gcd(a,b)\) we can make a computing agent to follow a finite sequence of instructions to return the \(gcd(a,b)\): int gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; } This is an algorthim, we get two values a and b and calculate the reminder, if this is not zero, then calculate the reminder between the second operand of the module operation and the last calculated reminder. We continue this way until the reminder is 0, this is would mean that, as we see in the demonstration above, the last calculated reminder (keeped in a) is \(gcd(a,b)\). 1.2. Time complexity. The example above shows in a clear way that the algorthims are structures, finite sequences of intructions, which pretends to automatize large repetitive tasks, in some way they are time-savers machines. Here we introduced a very important parametter, the time that takes the algoritm to return an output from a given input. This is known as the time complexity problem. Returning to the gdc() function showed above, given two integers, how many time it would require for the algorithm to return an output is related on how many times the while loop would iterate. In each iteration \(r_1 = a \ \% \ b\) gets computed and then shift the value \((a, b) → (b, r_1)\). So, when the sequence would end depends on how fast the \(b\) operand on \(a \ \% \ b\) operation would decrease. Note that after two consecutive iterations, the \(b\) value will decrease at least \(a/2\), so after \(2k\) iterations: \(min \ value ≤ b / 2^k\), then the iterations would terminate when \(2^k &gt; b \iff k &gt; log₂(b)\), thus total iterations \(k\) is a function of the logaritm of the minum value of the \((a,b)\) pair: \(k(a,b) = \mathcal{O}(log(min(a, b)))\). This means that the number of iterations that will take the algorithm to finish depends of a logaritmic function of the minimum value of the pair which means that this iterations grow slowly as the size of the integer grows: Complexity Name Growth rate O(1) Constant Time Instant O(log n) Logarithmic Time Very slow growth O(n) Linear Time Proportional O(n²) Quadratic/Polynomial Time Fast growth O(2ⁿ) Exponential Explodes An algorithm runs in polynomial time when its execution time can be bounded by some polynomial function of the input size. We say an algorithm takes polynomial time if it runs in \(\mathcal{O}(n^c)\) time or faster, where \(n\) is the size of the input and \(c\) is a non-negative constant. We may refer to algorithms that run in polynomial time or faster as efficient algorithms because their running time doesn’t grow too quickly with the input size. 2. Solving problems and verifying solutions. 2.1. Problems. Intimately attached to the idea of algorithms are the questions that algorithms are prepared to solve. We define the term problem as a specification of what we want to compute, this is; what to be solved by an algorthim implemented on a turing machine (we can think on this as a computin agent that can follow instruction and execute operations based on a language). Formally, a problem is a relation that maps an input to a set of valid outputs, the algorithm is a set of instructions that a compute agent process to go from the input to an acceptable output. There are many types of problems we can encounter: Search Problems: Where output is a concrete solution like "find all the posible divisors of 'n'*. Optimization Problems: Output is the best possible solution "the shortest path between two nodes*. Decision Problems: Where the output maps over a boolean value (YES/NO, TRUE/FALSE, 1/0), "Is number 'p' prime". For all about we care, we gonna focus on decision problems. 2.2. Definitions. Languages, Decisions Problems, N/DTMs and Time in TMs. 2.2.1. Languages. Let's formalize the concept of a decision problem, we already said that a problem is a relation between inputs and outputs. Let's take some definitions: An alphabet is a finite nonempty set of simbols, usually refered as \(\Sigma\). For example, consider: \[\Sigma = \{0, 1\}\] We also consider the set \(\Sigma^*\) of all posible strings of symbols of \(\Sigma\) (including the empty string \(\epsilon\)). This way, the set of all possible "binary numbers" would be: \[\Sigma^* = \{0,1\}^* = \{\epsilon,0,1,10,11,110,111,1110,1111,...\}\] Considering \(x \in \Sigma^*\) we define as the length of \(x \text { as } \vert x \vert \in \mathbb{N}\); as the number of symbols \(\sigma \in \Sigma\) that constitutes that string. According to this definitions, we define as a language; \(L\) over the alphabet \(\Sigma\) to any subset of \(\Sigma^*\); \(L \subseteq \Sigma^*\). 2.2.2. Decisions Problems and Languages. A decision problem (as used in complexity) can be formalized as a Boolean-valued function on strings over a two valids outputs; NO or YES: \[\Pi : \Sigma^{*} \to \{0,1\}\] Associated with the previous decision problem is the subset of \(\Sigma^*\) (language) of those elements which maps through \(\Pi\) to a YES. \[L_{\Pi} = \{x \in \Sigma^* \ | \ \ \Pi(x)= 1\} \subseteq \Sigma^*\] Observe that this way, we have reduced the problem solution to language membership question. Also, observe that for any given language \(L \subseteq \Sigma\), we can define an associated decision problem \(\Pi\) as: \[\Pi_{L}(x)= \begin{cases} 1 &amp; \text{if } x \in L\\ 0 &amp; \text{if } x \notin L \end{cases} \ : \ x \in \Sigma^*\] Being: \[L = \{ x \in \Sigma^* \ | \ \Pi_L(x) =1 \}\] This essentially means that any decision problem identifies it self with a language and we can talk indiscriminately about decision problems or languages. In this terms, solve a decision problem is equivalent to find a reliable decider of a certain language. 2.2.3. Turing Machines. A good way to think about a Turing Machine, \(TM\) is as a mathematical abstraction of an algorithm, a formal definition of a computable function. A (single-tape) Turing Machine consists of: An infinite tape divided into cells (memory). A tape head that at any moment scans exactly one cell and operate (read, write or move) it. A finite control unit which contains internal information divided in a finite amount of pieces, called "states". A deterministic rule telling it what to do next based only on: The current state. The symbol currently under the head. Computation is discrete: one transition per step. The following diagram show a representation of what are we talking about: Finite Control Unit (states Q) ┌──────────────────────────────────┐ │ current state: q │ │ deterministic rule: │ │ δ(q, σ) = (q', b, R) │ └─────────────┬────────────────────┘ │ depends on (current state, symbol under "head") │ ▼ (Infinite Tape) … | σ | a | σ | σ | b | σ | σ | a | σ | σ | b | c | c | a | … ▲ │ ┌─────┴───────────┐ │ Tape Head │ │ scans 1 cell │ │ read / write │ │ move Left/Right │ └─────────────────┘ We will come back to this diagram when the components gets explained and acquire full meaning. For now, think of a Turing Machine as an abstract computing agent that manipulates symbols step by step on an unbounded tape. Conceptually, it behaves as if it were executing an algorithm: at each step it consults a finite set of rules and updates its state and the tape accordingly, until a task is resolved. (Is worth to mention that the conception of the algorithm as if were an external-separate entity of the computational model is wrong and is only included for pedagogical purpouses, the algorithm is the TM it self, or said in other words, any algorithm is a concrete instance of a Turing Machine). A deterministic Turing Machine is a 7-tuple \[M = (Q, \Sigma, \Gamma, \delta, q_0, q_{\mathrm{acc}}, q_{\mathrm{rej}})\] Where: \(Q\) is a finite, nonempty set of states, including the initial state: \(q_0\). We will see later what a state is in depth; for now, we can say that a state is a finite piece of internal information that \(M\) uses to make decisions about the next move. \(\Sigma\) is the input alphabet. \(\Gamma\) is the tape alphabet which includes a special symbol, \(\square \in \Gamma\) which basically refers to an empty cell in the tape. \[\Sigma \subseteq \Gamma \ \ \land \ \ \square \notin \Sigma\] The reason why we distinguish between two alphabets is, besides the need of the empty cell conception \(\square\), because remember that \(M\) is the model of an algorithm, which receives an input and transforms it to an output, thus there can be symbols in the output which cannot be part of the input. Essentially, \(\Gamma\) is the set of all possible symbols which can be written on the tape, a subset of this one is \(\Sigma\), only the part of \(\Gamma\) that can be part of the input and not of the output. The transition function: \[\delta : \bigl(Q \setminus \{q_{\mathrm{acc}}, q_{\mathrm{rej}}\}\bigr)\times \Gamma \to Q \times \Gamma \times \{L,R\}\] \[\delta(q_p,\gamma_q) = \ (q_m, \gamma_n, D)\] Intuitively, the transition function specifies the next state transited from the current state, which symbol to overwrite the current symbol pointed by the head, and the next head movement (shift). Where: \(q_{\mathrm{acc}}\): Is the accepted state. \(q_{\mathrm{rej}}\): Is the rejected state. Thus, lets develop the concepts above more precisely. The \(Q\) set or set of states, is also called; Finite Control Unite. When an algorithm transforms an input to an output it performs operations in one or more steps. A state is the abstraction of one of those steps for the Turing Machine in the sense that is used to decide what to do next when the head tape read the tape symbol. This abstraction consists in a parameter \(q \in Q\), which is known as a Control Mode, that, in combination with a tape symbol \(\gamma \in \Gamma\), gets associated by \(\delta\) function as a pair \((q, \gamma) \in Q \times \Gamma\) to a 3-uple \(\delta(q,\gamma)\) which is another pair plus a movement (a shift \(L/R\)) to another cell in the tape. We will get into \(\delta\) soon, for now lets say that \(q\) is a fundamental parameter used to decide which step to take next in the computation chain. So, \(\delta(q,\gamma) = (q',\gamma',D)\) gets read as: for state \(q\) if \(\gamma\) is read, then writes \(\gamma'\) on the tape, moves the head one cell in direction \(D\) and enter state \(q'\). Note that \(q_{\mathrm{acc}}, q_{\mathrm{rej}}\) are both excluded from the domain of \(\delta\) meaning that those states have no transition, they are the end of the sequence in \(M\). In summary, as we said before, this are small pieces of information which \(M\) uses to makes decision about the next move along with other factors. Input alphabet \(\Sigma\), these are the symbols you allow in the input string, what \(M\) receives as input is a string from \(w \in \Sigma^*\). Tape alphabet \(\Gamma\), symbols that may appear on the tape during computation. It contains the input alphabet (because the input is written on the tape initially), but it can be larger because you may need work symbols / markers or the "blank" symbol, \(\square\). Transition function \(\delta\), this is the computational part of \(M\). For each pair \((q,a)\) of current state \(q\) and scanned symbol \(a\) there is at most one next action (and in the standard definition: exactly one, unless \(q\) is halting (\(q_{\mathrm{acc}}, q_{\mathrm{rej}}\)). A value: \[\delta(q,a) = (q', b, D)\] means: If you are in state \(q\) scanning symbol \(a\). DIAGRAM A — “Read” (the configuration that determines δ’s input) Finite Control Unit (states Q) ┌──────────────────────────────────┐ │ current state: q │ │ δ takes input from: │ │ (q, a) │ └─────────────┬────────────────────┘ │ │ a = symbol currently under head ▼ (Infinite Tape) … | σ | σ | a | σ | σ | … ▲ │ ┌────┴──────┐ │ Tape Head │ │ reads: a │ └───────────┘ Write symbol \(b\) in the current cell. DIAGRAM B — “Apply δ” (computing the unique next action) Finite Control Unit (states Q) ┌──────────────────────────────────┐ │ current state: q │ │ scanned symbol: a │ │ │ │ δ(q, a) = (q', b, D) │ └─────────────┬────────────────────┘ │ │ next state + write symbol + move dir ▼ OUTPUTS next state: q' write: b move: D ∈ {L, R} DIAGRAM C — “Write” (overwrite the scanned cell with b) Finite Control Unit (states Q) ┌────────────────────────────────┐ │ δ(q, a) = (q', b, D) │ │ action step: WRITE b │ └─────────────┬──────────────────┘ │ ▼ (Infinite Tape) … | σ | σ | b | σ | σ | … ▲ │ ┌────┴──────┐ │ Tape Head │ │ wrote: b │ └───────────┘ Move the head one step in direction \(D \in \{L,R\}\). DIAGRAM D — “Move Right” (D = R, head shifts one cell to the right) Finite Control Unit (states Q) ┌──────────────────────────────────┐ │ δ(q, a) = (q', b, R) │ │ action step: MOVE RIGHT │ └─────────────────┬────────────────┘ │ ▼ (Infinite Tape) … | σ | σ | b | σ | σ | … │ ▲ │ │ (was here) └── head after move ┌────────────────────────────────┐ │ Tape Head now scans next cell │ └────────────────────────────────┘ DIAGRAM E — “Move Left” (D = L, head shifts one cell to the left) Finite Control Unit (states Q) ┌──────────────────────────────────┐ │ δ(q, a) = (q', b, L) │ │ action step: MOVE LEFT │ └──────────┬───────────────────────┘ │ ▼ (Infinite Tape) … | σ | σ | b | σ | σ | … ▲ │ │ │ head after mov └──── (was here) ┌────────────────────────────────┐ │ Tape Head now scans prev cell │ └────────────────────────────────┘ Change state to \(q'\). Diagram F — “State Update” (complete the transition: new configuration) Finite Control Unit (states Q) ┌──────────────────────────────────┐ │ BEFORE: state = q │ │ δ(q, a) = (q', b, D) │ │ current state = q' │ └─────────────┬────────────────────┘ │ │ configuration after one step: │ (new state, updated tape, moved head) Before end, is worth to make the distinction between Non-Deterministic Turing Machines; \(NTM\), and Deterministic Turing Machines; \(DTM\). The difference between those two is that in NTMs, \(\delta\) is a relation, which means that for each input, the output is a subset of the codomain with the posibility that is greater than one: \[x \in X, \ y = \delta(x) \subset Y: \ |\delta(x)| \leq |Y|\] where \(\vert \delta(x) \vert\) is \(\delta(x)\)'s cardinality (the number of elements of the set). While in DTM, \(\delta\) is a function (a partial function to be accurate), which is a restricted subset of the relations. It means that for each input of the domain \(x \in X\), \(\delta\) maps at most (because it could be zero elements to map; partial) with one output \[y = \delta(x) \subset Y : |\delta(x) | \leq 1\] To consolidate the concepts, lets take an exercise: 2.2.4. Build a Turing machine that accepts a string and increments the number of a's within the string. We remember that a Turing Machine, \(M\), gets deined as a 7-upla: \(M = (Q, \Sigma, \Gamma, \delta, q_0, q_{acc}, q_{rej})\). This is the entities we have to define. First, based on what we know about a Turing machine and how it works, let's think conceptually about how it will work \(M\). The machine starts in a state \(q_0\), in which the string is represented on the tape. The tape head is located above the first letter. Finite Control Unit (states Q) ┌──────────────────────────────────┐ │ current state: q_0 │ │ action step: read first cell │ └────────────┬─────────────────────┘ │ ▼ (Infinite Tape) … | | | h | o | l | a | | | … The mechanism consists of, whenever it encounters a non-empty symbol, writing the same letter that already exists on the tape in the box, moving to the right, and assigning the state \(q_0\). Finite Control Unit (states Q) ┌───────────────────────────────────┐ │ current state: q_0 │ │ READ: symbol, h (not blank) │ │ action step: │ │ writes 'h', assigns q_0, move R │ └────────────┬──────────────────────┘ │ R ▼ &gt; ▼ (next cell to read) (Infinite Tape) … | | | h | o | l | a | | | … Finite Control Unit (states Q) ┌───────────────────────────────────┐ │ current state: q_0 │ │ READ: symbol, o (not blank) │ │ action step: │ │ writes 'o', assigns q_0, move R │ └─────────────────┬─────────────────┘ │ R ▼ &gt; ▼ (next cell to read) (Infinite Tape) … | | | h | o | l | a | | | … [...] When the tape head finds an empty cell, it writes an \(a\), changes the state to \(q_{acc}\) and moves to the right. Finite Control Unit (states Q) ┌────────────────────────────────────┐ │ current state: q_0 │ │ READ: symbol, " " (blank) │ │ action step: │ │ writes 'a', assigns q_acc, move R │ └────────────────┬───────────────────┘ │ ▼ &gt; ▼ (next cell to read) (Infinite Tape) … | o | l | a | | | | | | … Finite Control Unit (states Q) ┌──────────────────────────────────────┐ │ current state: q_acc (HALT, SUCCESS) │ │ READ: symbol, " " (blank) │ │ action step: - │ │ (q_acc, no action defined) │ └────────────────────┬─────────────────┘ │ ▼ (Infinite Tape) … | o | l | a | a | | | | | … Thus, according to our model, we define the following elements: \[Q = \{q_0, q_{\mathrm{acc}},q_{\mathrm{rej}}\}\] \(\Sigma = \{h,o,l,a\}\), \(\Sigma^*=\{\epsilon,h,hh,ho,hola,la,a,...\}\) \[\Gamma = \{\square\} \bigcup \ \Sigma\] \(\delta : \bigl(Q \setminus \{q_{\mathrm{acc}}, q_{\mathrm{rej}}\}\bigr)\times \Gamma \to Q \times \Gamma \times \{L, R\}\) satisfying: \[\delta(q,\sigma) = \begin{cases} \ (q, \sigma, R) \ \ \ \ \ \ \ \forall \sigma \in \Sigma\\ \ (q_{\mathrm{acc}}, a, R) \ \ \ \text{ if } \ \sigma = \square \end{cases}\] 2.2.5. Time in Turing Machines. Configurations and Computations. For a \(M \in DTM\), we define as time as the number of discrete transition steps (a computation) that \(M\) performs before it halts. Relative to a problem, time-solving always refers to the number of steps that the \(M\) requires for solving the problem o, in other words, the maximum transition steps (worst-case number) that would take to solve the problem. Let \(M\) be a DTM with \(\delta\) his transition function. Let's now fix a conventional input encoding: Input \(x \in \Sigma^*\) is written on the tape (or input tape) initially. The head starts at the leftmost symbol of \(x\). The rest of the tape is blank. Computation proceeds by repeatedly applying \(\delta\), one application is equal to one transition step. Then, we define as a configuration the 3-upla \(C = (q, t, i)\), where: \(q \in Q\), \(i \in \mathbb{Z}\) refers to the head-tape position, \(t: \mathbb{Z} \to \Gamma\), is the tape-content function. Observe that, with this convention, \(t(i)\) is the tape-symbol of the cell being pointed by the head-tape of \(M\). We consider the set of all the tape-content function as \(T_M\). Note also that whenever a transition takes place in which the tape gets written, \(t\) function gets modified. For example let's say \(x = h\). Then by the convention it would be: \[t: \mathbb{Z} \to \Gamma\] \(t(i) = \ \begin{cases} \ \square \ \ \ \ \ \forall i \in \mathbb{Z} \setminus\{0\} \\ \ h \ \ \ \ \ \ \text{ if } \ i = 0 \end{cases}\) Now, a transition step takes place and write \(a\), then \(t\) goes to \(t'\), where: \[t': \mathbb{Z} \to \Gamma\] \[t'(i) = \ \begin{cases} \ \square \ \ \ \ \ \ \ \ \ \forall i \in \mathbb{Z} \setminus\{0,1\} \\ \ t(i) \ \ \ \ \ \ \text{ if } \ i = 0 \\ \ a \ \ \ \ \ \ \ \ \ \ \text{ if } \ i = 1 \end{cases}\] This tape-content function acts kind as a log of the symbols present in the tape in a static snapshot of \(M\) in a precise moment. In this context, we read, \(C_i(x)\) as the \(i\)-th configuration of \(M\) processing \(x\), is an abstraction of a snapshot of the relevant features of \(M\) (this are the state, the tape and the head-tape). We also consider \(\Omega_x\) as the set of all the posible 3-uples \(C(x)\). Being \(C_i(x) = (q, t, n), \ C_j(x) = (q',t',m) \in \Omega_x\), then we define the following one-step transition relation; \(\vdash_{M} \ \subseteq \ \Omega_x \times \Omega_x\) such as: \[C_i(x) \vdash_{M} C_j(x) \iff \delta(q,t(n)) = (q',t'(m-1), R) \ \vee \ \delta(q,t(n)) = (q',t'(m+1), L)\ : \ D \in \{L,R\}\] This means basically that two configurations are sequental if they are immediate transitional steps through \(\delta\) in the processing of \(x\) input. If this condition is meet, then the effects of \(\delta\) over the \(C_i\) configuration must reachable by the \(C_j\) configuration in a concrete, well-defined terms. Consider for example (lets obviate conveniently that in this particular case is \(n=0\) in order to ilustrate the relation showed above): C_i = (q, t, n) Finite Control Unit (states Q) ┌───────────────────────────────────┐ │ current state: q │ │ READ: t(n) = h │ │ action step: │ │ writes 'j', assigns q', move R │ └────────────┬──────────────────────┘ │ ▼ (Infinite Tape) … | | | h | o | l | a | | | … C_j = (q',t', m) Finite Control Unit (states Q) ┌───────────────────────────────────┐ │ current state: q' │ │ READ: t'(m) = o │ │ action step: │ │ ... │ └────────────────┬──────────────────┘ │ ▼ (Infinite Tape) … | | | j | o | l | a | | | … t'(m - 1) = d(t(n)) = j from a state \(q\) and a current tape symbol \(t(n)\), then \(M\) writes the symbol referenced by \(t'(m)\) and goes to \(q'\), then \(C_i(x)\) and \(C_j(x)\) are sequential. Having the following scheme, the computation of \(x\) by \(M\) is a finite sequence of configurations, \[C_{0}(x)\ \vdash_{M}\ C_{1}(x)\ \vdash_{M}\ \cdots\ \vdash_{M}\ C_{p}(x) \ \iff \ C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ : p \in \mathbb{N}\] where \(C_0(x)\) is the initial configuration, \(\vdash_{M}\) is the “one-step yields” relation, and \(C_t(x)\) is halting, this is usually expresed as \(C_t(x) = (q_{acc}/q_{rej},t,n): t \in T_M, n \in \mathbb{Z}\). A little parenthesis, we usually refers that, for a given input \(x \in \Sigma^*\), we say that: \[M \text{ accepts } x \iff \exists ! p \in \mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{acc},t,n)\] \[M \text{ rejects } x \ \iff \exists ! p \in \mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{rej},t,n)\] This is, if exists a finite computation by \(M\) which ends either in \(q_{acc}\) or \(q_{rej}\) states. Note that for DTMs, necesarily \(p\) has to be unique, we will discuss this matter later, after a time definition. Then, we define two measures of time for DTMs, first, we introduce the time that \(M\) last to process a given input \(x \in X\): \[\mathrm{Time}_{M}(x)=\min\{\,p\in\mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q,t,n) : q \in \{q_{acc}, q_{rej}\}\}\] Essentially is the size (in transition steps) of the smallest computation path of \(x\) by \(M\). Now we extend this concept to the worst-case scenario, consider for any input, \(x \in \Sigma^*\) of size \(n\), the largest time that \(M\) last to process it: \[t_{M}(n)=\max\{\,\mathrm{Time}_{M}(x) : |x|=n\}\] Observe that in this case, we are considering the worst-case scenario, the upperlimit of all the possible times. This last definition is what we call the time of \(M\) as an algorithm. So in summary, we are understanding the time that an algorthim last to solve a problem is the number of steps (abstracted those in the chain of configurations of a DTM) the first one needs to compute an input of a determinated size \(n\). Until here, we defined time for DTMs, we can extend this concept to NTMs. As a brief reminder, DTM main's feature is that \(\delta\) is a partial function, so there is only one "transition" for a given status and symbol, this means that there is only one unique configuration that follows to a non-halting given one: \[M \in DTM \Rightarrow \forall C = (q,t,n) : q \in Q \setminus \{q_{\mathrm{acc}},q_{rej}\} \ \exists! \ D : C \vdash_{M}D\] since each \(D\) is unique, is easy to see that at the end this process lies in a unique computation (which besides is the only existent computation) for each input \(x\) by \(M\): \[M \in DTM \Rightarrow \forall x\, \forall p\, \forall C\, \forall D\ \bigl(C_{0}(x)\ \vdash_{M}^{\,p}\ C\ \wedge\ C_{0}(x)\ \vdash_{M}^{\,p}\ D\ \Rightarrow\ C=D\bigr)\] In contrast, in NTMs \(\delta\) is a relation, not a function, which means that can have one or more "one-step transition" configuration for a given configuration, this means that \(D\) is no longer unique: \[M \in NTM \Rightarrow \forall C = (q,t,n) : q \in Q \setminus \{q_{\mathrm{acc}},q_{rej}\} \ \exists D : C \vdash_{M} D\] Then, relative to NTMs, we no longer talk about "computation paths" (understand it as single-chains of configuration steps as we seen before) but about branchs of chains of configurations, making look the computation of a given input as a tree, instead of a single path: \[\begin{cases} C \vdash_{M} C_1 \begin{cases} C_1 \vdash_{M} C_{11} \ \ ...\\ C_1 \vdash_{M} C_{12} \ \ ...\\ ... \\ C_1 \vdash_{M} C_{13}\ \ ...\end{cases} \\ C \vdash_{M} C_2 \begin{cases} C_2 \vdash_{M} C_{21} \ \ ...\\ C_2 \vdash_{M} C_{22} \ \ ...\\ ... \\ C_2 \vdash_{M} C_{23} \ \ ...\end{cases} \\ ... \\ C \vdash_{M} C_m \begin{cases} C_m \vdash_{M} C_{m1}\ \ ... \\ C_m \vdash_{M} C_{m2} \ \ ...\\ ... \\ C_m \vdash_{M} C_{m3} \ \ ...\end{cases} \end{cases}\] In the nondeterministic case, the notation \(C_0 \vdash_{M}C_p\) is refering to the tree, not a branch in the tree. Also, in the present notes the \(C_0(x) \vdash^p_{M}C_p(x)\) notation can be read as; there exists a computation branch of length \(p\) from \(C_0\) to \(C_p\). Then we define for \(M \in NTM\): Acceptance (NTM); if there exists at least one halting-branch ending in \(q_{acc}\): \[M \text{ accepts } x \iff \exists p \in \mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{acc},t,n)\] Rejects (NTM); if all branches that halts end in \(q_{rej}\), or, equivallently, if no branch halts in \(q_{acc}\): \[M \text{ rejects } x \ \iff \ \nexists p \in \mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{acc},t,n)\] Thus, for NTMs, the time is a bit more complex than for DTMs. Starting by the fact that we distinguish of two time conceptions: In one term, if \(x\) is accepted then it have sense to consider the accepting time as the number of transitional steps in the shortest accepting branch: \[\mathrm{AccTime}_{M}(x)=\min\{\,p\in\mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\ \land \ C_{p}(x) = (q_{acc},t,n)\}\] But there is a more general and realistic concept of time for NTMs, universal over branches, which is considerate the number of steps of the largest branch (without consider if it halts or not): \[\mathrm{Time}_{M}(x)=\max\{\,p\in\mathbb{N} : C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\}\] Equivalently, the depth of the computation tree, no upper bound case is considered (the time maybe \(\infty\)). This is the standard definition. Associate with it is the worst-case input-length definition: \[t_{M}(n)=\max\{\,\mathrm{Time}_{M}(x) : x\in\Sigma^{*},\ |x|=n\,\}\] 2.2.6. Time of a Language: Solvable problems. Now that we covered foundational material about Turing Machines, lets how this structure fits in our conception of the decision problems. As a reminder, we was saying that a decision problem over an alphabet \(\Sigma\) can be understanded as Boolean function \(\Pi: \Sigma^* \to \Set{0,1}\) whose solution eventually lands over a language: \[L_{\Pi} = \Set{x|\Pi(x)=1} \subseteq \Sigma^*\] This way, solving \(\Pi\) becomes deciding the membership of \(L_\Pi\), which could be decided by a Turing Machine. That is the formal connection: a decision problem is (identified with) a language and a TM solves it by being a decider for that very language. Lets be \(M \in TM\) over an alphabet \(\Sigma\), then we say that \(M\) decides \(L \subseteq \Sigma^*\) when: \[M \text{ accepts } x \iff x \in L \ \ \land \ \ M \text{ rejects } x \iff x \notin L\] We say that \(\Pi\) is solvable or has a solution if \(\exists M \in DTM: M \text{ decides } L_\Pi\) (if exists a Turing Machine that decides his solution), we consider the set \[M_\Pi = \Set{ M | M \text{ decides } L_\Pi} \subseteq DTM\] With this terms, we can also give a more accurate conception about what \(\Pi(x) = 1\) means; \[\Pi(x) = 1 \iff \exists M \in M_\Pi : M_\Pi \text{ accepts } x\] This definition, despite being redundant since it doesnt include any new concept, is more human-friendly because we are just saying that for a decision problem, a given input is part of the solution whenever exists a mecanism (a turing machine mapping the solution of the problem) which accepts this input. \[L_{\Pi} = \{x \in \Sigma^* \ | \ \exists M \in M_\Pi : M_\Pi \text{ accepts } x\}\] Let's observe one thing. Despite we consider multiples turing machine that could solve a concrete problem \(\Pi\), \(L_\Pi\) do not depends on the turing machine selected as long as this turing machine is owned by \(M_\Pi\). Consider for example \(N,M \in M_\Pi\) and consider the language \[L_i = \{x \ | \ i \text{ accepts } x \} \subseteq \Sigma^*\] for \(i \in TM\). Then it is: \[x \in L_N \iff N \text{ accepts } x \iff \Pi(x) = 1 \iff M \text { accepts } x \iff x \in L_M\] so \[\forall N,M \in M_\Pi \ \ \ L_N = L_M = L_\Pi\] This basically means that not matters what TM we consider, all maps \(L_\Pi\) equally since all refers to the \(\Pi\) criteria. We end saying that we define the resolution-time of a decision problem \(\Pi\) over an alphabet \(\Sigma\) as \[T_{\Pi}(n)=\inf_{M\in\mathcal{M}_{\Pi}} t_{M}(n)\] Is worth to note that all the times definition we provided is not are not fixed values, they depends on the input size; \(\vert x \vert\). How the value of this time grows as the length of the input grows is a subject called Time Complexity, and it will be discussed in the next section. 2.2.7. Time Complexity. Big-O. Efficient algorithms. Until here, we have a step-count model; \(\mathrm{Time}_{M}(x)\), and the induced worst-case length function time; \(t_M(n)\), and ultimately we defined the time associated with a decision problem as the fastest length function time of the set of the length function time from the turing machines that decides the language associated to that problem \(T_{\Pi}(n)\). Now, we want to discuss about the upper asymptotic growth of those functions as \(n\to \infty\), which is also called the time complexity subject. We remember briefly that: an asymptote is a line or curve that a function's graph approaches infinitely closely but never touches or crosses as the graph heads toward infinity (or negative infinity). Big-O notation is a mathematical notation that describes the approximate size of a function on a domain, specifically, Big-O describe an asymptotic upper bound behaviour which is perfect for the time complexity question. Being \(f,g: \mathbb{N} \to \mathbb{R_+}\) then: \[f(n)\in \mathcal{O}(g(n))\ \Longleftrightarrow\ \exists c&gt;0,\ \exists n_{0}\in\mathbb{N},\ \forall n\ge n_{0}:\ f(n)\le c\,g(n)\] This is as far from some point \(n_0\) on the domain; \(f\) is bounded above by a constant multiple of \(g\), meaning that \(f\) grows no faster than \(g\) (up to constants). The \(f\)'s upper behavior is enveloped over the one of a model function \(g\). Let's observe that this does not mean that \(f\) and \(g\) behaves the same (which would be reasonably to think since we are going to use this notation to refer time functions; "\(f\) is owned by a family of functions that behaves as \(g\)" is what would we be kind to imagine when describing a time function in relation to another). In fact, again, we are not defining the behaviour of \(f\), but his upper asymptotic behavior at some point in the domain which is being described through a model function \(g\) despite constant factors. Also note that no asymptotes are required, that's nomenclature, is just upper behaviour. This is basically means that from certain point in the domain, \(f\) is as much as bigger as a multiple of \(g\). Name (informal) Typical bound (\(t(n)\in\mathcal O(\cdot)\)) What it means (intuition) Canonical example(s) Constant \((1)\) Time does not scale with Array index access (RAM model), fixed-size checks Logarithmic \(log \ n\) Each step shrinks problem size by a constant factor Binary search; balanced BST search Polylogarithmic \((log \ n)^k\) Slightly more than logarithmic Some advanced data structure ops; certain graph queries Sublinear \(n^\alpha \ : \ 0&lt;\alpha&lt;1\) Reads/uses only a fraction of the input (often not possible if you must inspect all input) Property testing (probabilistic), sampling-based algorithms Linear \(n\) Proportional to input length Single pass scan; counting; verification passes Linearithmic \(n · log \ n\) “Divide-and-conquer + linear combine” pattern Merge sort, heap sort; many FFT-like routines Polynomial (general) \(n^k : k\ge 1\) Considered “efficient/tractable” in complexity theory Many classic deterministic algorithms; defines (\mathbf P) Exponential \(c^n : c&gt;1\) Branching search; scales very poorly Brute-force SAT assignment search; subset enumeration Factorial \(n!\) Enumerating permutations Traveling Salesman brute force; permutation search We say that an algorthim runs in a concrete time if its in the Big-\(\mathcal{O}\) family of the prototype function of that set (note also than tehre is an inclusion relation between those sets; \(\mathcal{O}(1) \subset \mathcal{O}(log \ n) \subset ... \subset \mathcal{O}(n^k)\)). Cobham’s thesis asserts that a computational problem is feasibly/efficiently solvable iff it has an algorithm that runs in polynomial time in the length of the input, often refears as tractable problem. Thus, for all about we concern, we distinguish two types of algorithms; those which runs in polynomial time or less which solves "tractable" problems and those which runs in super-polynomial time. Note that we refer to Cobham's assertmen as a thesis and not a theorem because it is not a theorem; it is a design choice that turned out to be unusually robust. 3. Complexity classes: P, NP and PSPACE. PvsNP problem. A complexity class is a set of decision problems (languages) that are solvable within a specified resource budget, typically: time (number of steps), space (number of tape cells used), measured as a function of the input length \(n = \vert x \vert\). Let's consider the following two sets. For a function \(T:\mathbb{N} \to \mathbb{N}\): \[DTIME(T(n)) = \{L \subseteq \Sigma^* \ | \ \exists M \in DTM: \big( M \ decides \ L \land \ t_M(n) \in \mathcal{O}(T(n))\big) \}\] \[NTIME(T(n)) = \{L \subseteq \Sigma^* \ | \ \exists M \in NTM: \big( M \ decides \ L \land \ t_M(n) \in \mathcal{O}(T(n))\big) \}\] This are basically the class of those languages for which exists respectively a deterministic and no-deterministc Turing machine which decides it in \(T(n)\) time. Then, we define: \(\mathbf{P}=\displaystyle\bigcup_{k\ge 1}\mathrm{DTIME}(n^{k})\). The class of the languages that can be deterministically decided in polynomial time. This is, that exists a DTM that can decide, for a given input \(x\), if it is \(x \in L\) or \(x \notin L\). \(\mathbf{NP}=\displaystyle\bigcup_{k\ge 1}\mathrm{NTIME}(n^{k})\); Which are the class of the languages for which exists a non-deterministic turing machine that decides it in polynomial time. Note that, in this context, if we apply the identification of decisions problems with languages, we are just talking about those problems for which exists, respectively, deterministic and not-deterministic time-efficient solutions. Note that \(P \subseteq NP\). 3.1 Certificate/verifier characterization of NP. Verification. 3.1.1 Deterministic conception of NP. At this point, “efficient” is being used relative to the underlying machine model: in \(P\) the efficiency bound is measured along the unique deterministic computation, whereas in \(NP\) it is measured along computation branches of a nondeterministic machine. The relation between these two notions of efficiency is not immediate, because nondeterminism is a theoretical construct rather than a direct physical assumption about how computation is executed. This motivates the distinguition about the abstract models (DTM/NTM) from implementable computation and explain how this leads to a deterministic conception of NP languages as the class of those languages for which exists polynomial-time "verification". Let's remember acceptance in NTMs. Being \(M \in NTM\), then \(M\) accepts \(x_0 \in \Sigma^*\) is exists at least one branch in the computation halting in \(q_{acc}\): \[M \text{ accepts } x_0 \iff \exists p \in \mathbb{N} : C_{0}(x_0)\ \vdash_{M}^{\,p}\ C_{p}(x_0)\ \land \ C_{p}(x_0) = (q_{acc},t,n)\] Consider as \(c_0: C_{0}(x_0)\ \vdash_{M}\ C_{1}(x_0) \vdash_{M} ... \vdash_{M} C_p(x_0)\) to this single configuration chain. And if we consider \(t_M(n) \in \mathcal{O}(n^k) : k \geq 1\), then we can consider the existence of: \[V_{x_0} \in DTM :C_{0}(x_0)\ \vdash_{V_{x_0}}^{\,p}\ C_{p}(x_0)\ \land \forall i &lt;p \ \big(C_{i}(x_0)\ \vdash_{V_{x_0}}^\ C_{i+1}(x_0) = C_{i}(x_0)\ \vdash_{M}^\ C_{i+1}(x_0) \in c_0\big)\] This means basically a deterministic algorthim computing \(x_0\) through the computation accepting-branch of the non-deterministic turing machine. Let's observe that from the definition of \(V_{x_0}\), the following statements are immediately follow: Let's consider \(w_0\) a codification of the following statement: \[C_{0}(x_0)\ \vdash_{V_{x_0}}^{\,p}\ C_{p}(x_0)\ \land \forall i &lt;p \ \big(C_{i}(x_0)\ \vdash_{V_{x_0}}^\ C_{i+1}(x_0) = C_{i}(x_0)\ \vdash_{M}^\ C_{i+1}(x_0)\big)\] such as \(V_{x_0}(x_0,w_0) = 1 \iff C_{p}(x_0) = (q_{acc},t,n)\), then \[M \text{ accepts } x_0 \iff \exists w_0:V_{x_0}(x_0,w_0)=1\] And it also have an immediate corolary; if \(M\) is a decider of \(L \subseteq \Sigma^*\), then: \[x_0 \in L \iff \exists w: V_{x_0}(x_0,w_0)=1\] For \(V\) as is described before is: \(\ Time_V(x_0) \in \mathcal{O}(n^k) : k \geq 1\) From the definition is known that: \(\mathrm{Time}_{V_{x_0}}(x_0) = AccTime_M(x_0) \leq t_M(n) \in \mathcal{O}(n^k) \ \Rightarrow \ \mathrm{Time}_{V}(x_0) \in \mathcal{O}(n^k)\), so \(V_{x_0}\) computes \(x_0\) in polynomial time. We refer to \(w_0\) as the witness and \(V_{x_0}\) as the verifier of the pair \((x_0,w_0)\). We can think of \(w_0\) as a piece of encoded information about how a deterministic turing machine (\(V_{x_0}\)) have to compute the specific \(x_0 \in \Sigma^*\) input to obtain a halt-accepted configuration \(C_p\) equivalent to the one reached by \(M \in NTM\). 3.1.2. Formalizing the witness encoding. Let's now formaly nail the formulation of \(w_0\). We can reformulate what we understand as an accepting branch for \(x_0\) like a finite sequence of configurations: \[c_0 = (C_0,C_1,...,C_p): C_0 = C_0(x_0) \ \land \ C_p = (q_{acc},t,n) \ \land \ C_i \vdash_{M} C_{i+1} \ \ \forall i &lt; p\] Then, from this point, we can define a witness as an encoding of this accepting branch in a string of symbols of the input alphabet of \(M\), \(w_0 = enc(c_0) \in \Sigma^*\). Let's observe that as a string of symbols, this witness is only encoding a path in the computation tree of \(M\), a sequence of nondeterministc choices. Since we are considering \(M\) as a decider NTM, then infinit branchs are out of scope and we can consider for any given computation, the set of the succesors from a departing configuration: \[Succ(C) = \{D : C \vdash_{M} D\} : |Succ(C)| \leq b \in \mathbb{N}\] observe we can fix this set to consider the deterministic ordering of successors for each C: \[Succ(C) = (D_{C,1},D_{C,2},...,D_{C,m_C}):1\leq m_C \leq b\] Now, given a branch, like \(c_0 = (C_0,...,C_p)\), define its choice sequence as the set: \(choice(c_0) = (a_0,...,a_{p-1})\) where each \(a_i \in {0,...,b}\) is an index such \(C_{i+1} = D_{C_i,a_i}\), an identifier for any deterministical succesor in the branch. So essentially, we are providing a deterministic methodology for mapping the branch \(c_0\), as in \(Succ(D_c)\) choose \(a_1\) which leads to \(D_{C,1} = C_1\). Now for \(Succ(D_{C_1})\) choose \(a_2\) which will lead to \(D_{C,2} = C_2\) and so on. Now, lets find a way to encode this information in the witness \(w\). Considering the alphabet \(\{0,1\}\), we define \(w_0 \in \{0,1\}^*\). Since \(a_i\) as described before, are just natural numbers, we can encode them in binary an concibe: \[w_0 := \mathrm{enc}(\pi) = \mathrm{bin}_{m}(a_{0})\,\mathrm{bin}_{m}(a_{1})\cdots \mathrm{bin}_{m}(a_{p-1}) \in \{0,1\}^{mp},\] This way, without entering in details, \(w\) is a string of \(m=log_2b\) length blocks of bits encoding \(a_i\) numbers. Thus, a deterministic TM could be craft to do: Start at \(C_0(x)\). At step \(i\), read the \(i\)-th block \(bin_m(a_i)\) from \(w_0\). If \(a_i &gt; m_{C_i}\) rject, otherwise, \(C_{i+1} := D_{C_i,a_i}\) Continue up to most \(T(\vert x \vert)\) steps and accept iff an accepting configuration is reached. So we have demonstrated that \(w\) is a piece of encoding information polynomially bounded in \(\vert x \vert\). 3.1.3. Generalizating V as a verifier of L. At this point, we have a strong conception for \(w_0\), but we only concibed \(V_{x_0}\) and \(w_0\) as a mecanism specific for a given input, \(x_0\). Let's now formalize this idea for a language \(L\). Since \(w_0\) departs from an accepting branch \(c_0\) in the computation tree of \(x_0 \in \Sigma^*\) by \(M\) and \(V_{x_0}\) is a deterministic mecanism that computes \(x_0\) using \(c_0\) follwing \(w_0\), we can now consider a generic case of \(V_{x_0}\) for a language \(L \subseteq \Sigma^*\). Considering a \(L\subseteq \Sigma^*\) and \(M \in NTM: M \ decides \ L\). Then we can consider \(x \in L\) and \(c\) the accepting-halting branch of the computation \(C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\). Then we define \(V \in DTM\) in a manner that garantee a finite computation of \(x\) following the non-deterministical choices of \(C_{0}(x)\ \vdash_{M}^{\,p}\ C_{p}(x)\) to ultimately reaching the same accepted-halt configuration \(C_p\). Formaly \(V\), as defined above, satisfies: \[\forall x \in L \ \exists p \in \mathbb{N} : \Big(C_{0}(x)\ \vdash_{V}^{\,p}\ C_{p}(x)\ \land \forall i &lt;p \ \big(C_{i}(x)\ \vdash_{V_{x_0}}^\ C_{i+1}(x) = C_{i}(x)\ \vdash_{M}^\ C_{i+1}(x) \in c\big)\Big)\] In this terms, encoding \(c\) in \(w\) as seen before, we also define: \[V(x,w) = 1 \iff C_p = (q_{acc},t,n)\] and reformulate the caracterization of \(V\) as: \[\forall x \in L \ \exists w : |w| \in \mathcal{O}(|x|^k) \ \land \ V(x,w) = 1\] The \(\vert w \vert \in \mathcal{O}(\vert x \vert^k)\) condition refers that the encoding uses an reasonable amount of space resources. And ultimately we can say that \(V\) is a verifier of \(L\): \[\forall x\in \Sigma^* \ \big( x\in L \iff \exists w : |w| \in \mathcal{O}(|x|^k) \ \land \ V(x,w) = 1 \big)\] Observe that also is: \[x \notin L \ \iff \ \forall w\ \bigl(|w|\le p(|x|)\ \Rightarrow\ V(x,w)=0\bigr)\] Is worth to note that \(t_M(n) \in \mathcal{O}(f(n)) \Rightarrow t_V(n) \in \mathcal{O}(f(n))\) since we are refering to computations build from non-deterministic choices. Informaly, we can say that a verifier is kind of a decider with some aid. 3.1.4. Caracterization of NP. NP deterministic approach. Reaching this point, having understanded that, for a non-deterministic machine, we always can think about a deterministic machine that can compute a set of nondeterministical choices reaching the same accepting-halted configuration for a given input having the aid of encoding information. We can now present a deterministic conception of \(NP\) as the class of the languages that can be verified in polynomial time, which is in fact. First of all, we've already seen that for a language \(L \subseteq \Sigma^*\) and \(M \in NTM\) exists \(V \in DTM\) that acts as a verifier for \(L\) running in the same time that \(M\) if \(t_M(n) \in \mathcal{O}(n^k)\), so fixing \(t_M(n) \in \mathcal{O}(n^k)\) we can say that any \(L \in NP\) has a verifier running in polynomial time. Also, considering \(L\) a language that has a verifier \(V\) running in polynomial time, then, we can consider a \(M \in NTM\) running also in polynomial time that has one branch that reproduce the deterministic path of \(V\) for any \(x \in L\). Then \(M\) becomes a decider of \(L\) and \(L \in NP\). This two approachs, despite they lacks of formalization and are poorly accurate, are enough to see that is not dificult too imagine the existing equivalence between those two classes once the idea of the verifier and the witness are formally understanded. Then, \(NP\) can be considered as the class of those languages for which exists a verifier which runs in polynomial time. Thus, essentially we have: \(\mathbf{P}=\displaystyle\bigcup_{k\ge 1}\mathrm{DTIME}(n^{k})\). The class of the languages that can be deterministically decided in polynomial time. This is, that exists a DTM that can decide, for a given input \(x\), if it is \(x \in L\) or \(x \notin L\). \(\mathbf{NP}= \{ \ L \ \vert \ \forall x \ \big( x\in L \iff \exists w : \vert w \vert \in \mathcal{O}(\vert x \vert^k) \ \land \ V(x,w) = 1 \big)\}\); Which are the class of the languages that can be verified in polynomial time. 3.2. P class: Efficiently solvable problems. Witness. Let's review some examples for \(P\) class: Sorting a list: we can efficiently sort a list in \(\mathcal{O}(n·log(n))\) with mergesort, check that \(log(n) &lt; n\) for any base bigger than 1, so \(n·log(n) &lt;n^2\) and this it is indeed a polynomial-time algorithm. Also and we can efficiently verify that a list is sorted in \(\mathcal{O}(n)\). Returning the index of a number in a list, if it occurs in the list: Taking a given list, we can sort it in a \(\mathcal{O}(n)\) time while check if a given number of the list is in a position is inmediate \(\mathcal{O}(1)\). Determining if two nodes in a graph are connected: We can efficiently determine if two nodes in a graph are connected by using breadth-first search; start at a node, then visit all of its neighbors except nodes we’ve already visited, then search the neighbors of the neighbors, and so forth. Discovering the path between nodes using breadth-first search will take \(\mathcal(O)(n + e)\) time, where is the number of nodes in the graph and is the number of edges. We can verify the proposed path is valid in \(\mathcal(O)(n)\) time simply by following the proposed path to see if the two points really are connected by that path. In all the examples above, both computing and verifying the solution can be done in polynomial time Witness example When we discussed \(NP\) class we define what a witness was, a piece of encoded information that helps a verifier (deterministic turing machine) to perform a verification about some given input for a decision problem. We rememeber that this means; if the verifier accepts the pair, then the input is part of the solution of the problem, if not, is not conclusive, it may be problem of the verifier. Expanding this concept, at a high-level, in computer science we can think on a witness as a proof of you solve an instance of the problem, that a particular input is a YES-instance. A witness can be a direct solution to the problem. For the examples above, that can be solved deterministically, these are things we could use as a witness: The sorted list The index where a number appears in the list The path between two nodes in a graph But in most cases a witness does not necessarily have to be a direct solution to a problem, or, in other words, the solution to the original problem. This is essentially true when a deterministic approach is not efficient at a first glance. This is when the idea of the verifier as separate entity and the witness gains more weight. Then, the verifier can be thinked as a deterministic algorithm that decides an alternative representation of the same problem. For example, consider the following question: "Given a number \(n\), is \(n\) composite?". The direct solution would be: find two integers \(a,b&gt;1\) such that \(n=ab\). If we have for example the number \(341\) the direct solution would be: \(341 = 11·31\), so its composite. But we can provide a different proof avoiding the factorization. We know that if a number cannot be decomposite in factors different from one and him self, then is prime, so demonstrate that a number is prime is the boolean-opposite to demonstrate that is composite. For this matters, we can use the Miller–Rabin primality test, which says that: For a given odd integer \(n &gt; 2\), let’s write \(n − 1\) as \(2^sd\) where \(s\) is a positive integer and \(d\) is an odd positive integer. Let’s consider an integer \(a\), which is coprime to \(n\). Then, \(n\) is said to be a strong probable prime to base \(a\) if one of these congruence relations holds: \[a^d \equiv 1 \pmod n\] \[\exists r \in \mathbb{Z}: 0 \leq r &lt; s \land a^{2^rd} \equiv -1 \pmod n\] We were saying that \(p=341\), then \(a=2\) (obviously a coprime), so \(p−1=340 = 2^{2}·85\), then: \[a^d \equiv 1 \pmod n \iff 2^{85} \ mod \ 341 = 32\] So this fails the first test, the second test requires the retest with \(r\) between 0 and 1, we already now that (for \(r = 0\)) \(32 \neq -1\), so for \(r=1\): \[2^{2·85} \ mod \ 341 = 2^{170} \ mod \ 341 = 1 \neq -1\] This means that, for base \(2\), our integer do not satisfies any of the condition to be likely a prime, which means that definitively is not a prime. Then, in therms of computation, the integer \(a=2\) applied to the theorem above is our witness to the decision problem we propose at the init: \(341\) is prime?. The primality test could be thinked as the verifier \(V\), and being \(V(2,341) = 1\) (since it fails both test so is not primal, otherwise it would be strongly probable a primal, but not definitive a primal) is equivalent to solve the question about if it is composite which was our original decision problem. 3.3. Problems in PSPACE: Not all problems have solutions that can be efficiently verified. We talked about two class which have conditions that consider the time in which a problem can be either verified or solved by a deterministic model. In this case, PSPACE consider the space inversion amount, the only requirement relative to time is that eventually finish. 3.3.1. Space-bounded Turing Machines. Being \(M \in DTM\) with \(\Gamma\) being the tape alphabet, we recover that a configuration \(C = (q,t,n): q \in Q, t:\mathbb{Z} \to \Gamma, n \in \mathbb{Z}\). Then, consider the halting computation \(C_0(x) \vdash_M C_1(x) \vdash_M ... \vdash_M C_p(x)\), then we would write \(C_i(x) = (q_i,t_i,n_i)\). We define \[Space_M(x):= |\{\ n_i \ | \ 0 \leq i \leq p\ \}|\] If \(n\) reflects in \(C = (q,t,n)\) in which cell of the tape is the head tape on that current snapshot, then, we are just considering the number of all different cell tapes the head visit on the computation of a given input. Then, for a function \(s:\mathbb{N} \to \mathbb{N}\): \[DSPACE(s(n)) = \{ L \subseteq \Sigma^* \ | \ \exists \ M \in DTM \ deciding \ L: space_M(x) \in s(|x|)\}\] this is, the set of those lanmguages for which exists a DTM that have a usespace function upper bounded by \(s(\vert x \vert)\). We define \(PSPACE\) as set of those DSPACES for polynomial use-space function: \[PSPACE = \displaystyle\bigcup_{k \in \mathbb{N}} DSPACE(n^k)\] This are all of those problems that can be decide with a reasonable amount of space. The relation withother class discussed before is: \[P\subseteq NP\subseteq PSPACE\] 3.3.2. Space-problems example. This class of problems has been researched extensively, yet no efficient algorithm to solve them has been discovered. Many researchers believe no efficient algorithm to solve these problems exists at all. If an efficient solution to these problems could be discovered, it would also be possible to reuse the algorithm to break all modern encryption and fundamentally alter computing as we know it. Despite significant incentives for finding efficient solutions to these problems, evidence suggests such solutions likely do not exist. These problems are so challenging that you cannot provide easily verifiable proof (witness) even if you solve them correctly. Let see some examples: Given an started chess-state, find the optimal chess move. If we ask a computer about the optimal next move for a given position, the computer give a straight answer based on a calculation of all the future game-state from the given position. There is no efficient way to check the best move, and as you optimize the calculation about the move more resource you need to invest. Determining if regexes (regular expressions) are equivalent. Checking if two arbitrary regexes are equivalent takes exponential time to compute. Even if a powerful computer told you they match the same strings, there is no short proof (witness) the computer can give you to show the answers are correct. Similar to the chess example, you’d have to search a very large space of strings to check if the regexes are equivalent, and that will take exponential time. 3.4. NP. Problems that can be quickly verified but not quickly computed. If we can quickly verify the solution to a problem, then the problem is in NP. However, finding the solution might require exponential resources. As we say before: any problem whose proposed solution (witness) can be quickly verified as correct is an NP problem. If the problem also has an algorithm for finding the solution in polynomial time, then it is a P problem. All P problems are NP problems, but it is extremely unlikely that all NP problems are also P problems. Let's check some examples: Sudoku: Given a Sudoku puzzle solution, we can quickly verify the solution is correct simply by looping over the columns and rows. The witness can be verified in polynomial time. However, computing the solution requires significantly more resources — there are an exponential number of combinations to search. Note that as the sudoku grows, the time needed to check the solution grows exponentially. Three-coloring a map: Any 2D map of territories can be “colored” with just four colors (see the four color theorem). That is, we can assign a unique color (one of four colors) to each territory such that no neighboring territories share the same color. The three-coloring problem asks whether a map can be colored using just three colors instead of four. Discovering a three-coloring (if it exists) is a computationally intensive search problem. However, verifying a proposed 3-coloring is easy: loop through each of the regions and check that no neighboring regions have the same color of the territory currently being checked. 3.5. Explanation of PvsNP. Now that we have a solid understanding about, what P, NP are. Lets face some core question about complexity theory. First, we did see that \(P\) is the class of problems for which exists a deterministical solution running in polynomial time (efficient time), Then, we see that \(NP\) is the class of those languages that admit a non-deterministical but never the less time-efficient solution and also we see that a deterministical perspective of NP problems is needed. That was the characterization of NP as the class of those languages that admit a verification in polynomial time. Now, a convenient question is put on the table. Do thouse quick verificable problems admit a efficient solution also? Or said in other words, is NP part of P? \[P \supseteq NP\] Remember that above we said that \(P \subseteq PN\), both statements together are equal to propose the equivalence between those two setsL \[P \subseteq NP \land P \supseteq NP \iff P = NP\] This is, any problem that can be efficiently verified can also be efficienctly decided? \(P = NP\) is a powerful statement, it would mean that whenever we can find an efficient verifier for a YES-instance input of a decision problem, we can be sure that there exists also an efficient solution that decides the problem. As a summary, we dedicated a part of the course to understand PvNP subject (among with turing machine, efficient time-solving problems, etc) because ZK cares about the verifying aspect of the computation, this means, to the subject of develop a witness that efficiently proof a YES-instance of a problem.]]></summary></entry><entry><title type="html">Boolean Formulas.</title><link href="http://localhost:4000/posts/2026/01/11/Boolean_Formulas/" rel="alternate" type="text/html" title="Boolean Formulas." /><published>2026-01-11T10:00:00+01:00</published><updated>2026-01-11T10:00:00+01:00</updated><id>http://localhost:4000/posts/2026/01/11/Boolean_Formulas</id><content type="html" xml:base="http://localhost:4000/posts/2026/01/11/Boolean_Formulas/"><![CDATA[<h2 id="0-index">0. Index.</h2>

<ol>
  <li>
    <p>Expressing problems and solutions as Boolean formulas.</p>
  </li>
  <li>
    <p>Boolean Logic.</p>
  </li>
</ol>

<ul>
  <li>
    <p>2.1. Introduction.</p>
  </li>
  <li>
    <p>2.2. Boolean Formulas. Propositional variables and connectives.</p>
  </li>
  <li>
    <p>2.3. Boolean formulas and Valuations.</p>
  </li>
</ul>

<ol>
  <li>SAT is NP-complete: Cook–Levin Theorem.</li>
</ol>

<ul>
  <li>
    <p>3.1. SAT – Boolean Satisfiability Problem.</p>
  </li>
  <li>
    <p>3.2. NP-completeness. Reductions.</p>
  </li>
  <li>
    <p>3.3. SAT is NP-complete.</p>
  </li>
</ul>

<ol>
  <li>Examples.</li>
</ol>

<ul>
  <li>
    <p>4.1. Checking if a list is sorted using a boolean formula.</p>
  </li>
  <li>
    <p>4.2. Map-coloring problem: Graph theory.</p>

    <ul>
      <li>
        <p>4.2.1. Introduction to Graph Theory.</p>

        <ul>
          <li>
            <p>4.2.1.1. Graphs and Subgraphs. Vertices and Edges. Neighborhood.</p>
          </li>
          <li>
            <p>4.2.1.2. Graph coloring.</p>
          </li>
          <li>
            <p>4.2.1.3. Plannar graphs. Drawings and faces. Euler’s formula.</p>
          </li>
          <li>
            <p>4.2.1.4. Dual graphs.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>4.2.2. Formuling the problems. Three-coloring problem.</p>

        <ul>
          <li>
            <p>4.2.2.1. Describing the problem.</p>
          </li>
          <li>
            <p>4.2.2.2. Graph Encoding.</p>

            <ul>
              <li>
                <p>4.2.2.2.1. Matrix reduction.</p>
              </li>
              <li>
                <p>4.2.2.2.2. Matrix Encoding.</p>
              </li>
            </ul>
          </li>
          <li>
            <p>4.2.2.3. Verifying L.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<ol>
  <li>Conclusion.</li>
</ol>

<p><br /></p>

<h1 id="1-expressing-problems-and-solutions-as-boolean-formulas">1. Expressing problems and solutions as Boolean formulas.</h1>

<p>What ties P and NP problems together is that both can be quickly verified. We remember that a verifier is a deterministic turing machine that operates an input and a witness and accepts a YES-instance of a given problem and rejects the NO-instances, on the other hand, we considered the witness of a YES-instance as a proof or certificate of the existance of that same instance.</p>

<p>In order to model a problem statement we make uses of formal languages, specifically, of boolean formulas. It is true that: <strong>Verifying a solution to a problem in NP or P can be accomplished by verifying a solution to a boolean formula that models the problem.</strong></p>

<p><br /></p>

<h1 id="2-boolean-logic">2. Boolean Logic.</h1>

<h2 id="21-introduction">2.1. Introduction.</h2>

<p>The term <em>boolean-logic</em> refers to a formal framework for reasoning about propositions. It mainly consist of a formal language; an alphabet of symbols from which concatenations of symbols or simply <em>strings</em> are formed. This symbols can be either:</p>

<ul>
  <li>
    <p><em>Proposition</em> is a statement with a unique, unambiguous truth value (either true or false).</p>
  </li>
  <li>
    <p><em>Connectives</em>, symbols with a precise significancy that are use to relate primitive propositions to build more complex ones.</p>
  </li>
</ul>

<p>Boolean logic formalizes reasoning with truth values. Its primitive objects are propositions (statements), and connectives that build new propositions from old or atomics ones.</p>

<p><br /></p>

<h2 id="22-boolean-formulas-propositional-variables-and-conectives">2.2. Boolean Formulas. Propositional variables and conectives.</h2>

<p><strong>Boolean Formulas</strong></p>

<p>As we say before, boolean-logic formalizes reasoning with truth values by relating propositions with connectives. In order to study those relations arises the <em>boolean formulas</em>, which abstract the logic relations between propositions using <em>propositional variables</em>.</p>

<p><br /></p>

<p><strong>Propositional variables and Logical Connectives</strong></p>

<p>A propositional variable is mathematical object that stands for a proposition. Is not a preposition itself, it becames a preposition under a valuation, which maps the preposition variable to a truth value. It the most basic syntactic units, consider the following set; $ Var = {p_0,p_1,p_2,…} $, any $ p \in Var $ is a propositional variable.</p>

<p>As a intuitional approach, a propositional variable stands for an unspecified statement, with lack of specific content, which eventually can by valuable as true or false becoming straight to a proposition: $ v: Var \rarr {0,1}$. Variables are syntactic placeholders; truth arises only after a valuation is chosen.</p>

<p><br /></p>

<p>On the other hand, the logical conectives are the symbols used to relate propositions or propositional variables resulting in other proposition (complex proposition). They are the grammar of propositional logic, this are also called as <em>logical operators</em>.</p>

<p>For the following, consider $p, q \in Var$.</p>

<ul>
  <li>
    <p><strong>NOT</strong>, This is an unary operator which assigns the opposite truth value of the original proposition:</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: right">$p$</th>
          <th style="text-align: right">$\lnot p$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
        </tr>
      </tbody>
    </table>

    <p><br /></p>
  </li>
  <li>
    <p><strong>AND</strong>, This is a binary operator which returns true iff both propositions are true:</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: right">$p$</th>
          <th style="text-align: right">$q$</th>
          <th style="text-align: right">$p \land q$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
        </tr>
      </tbody>
    </table>

    <p><br /></p>
  </li>
  <li>
    <p><strong>OR</strong>, This is a binary operator (inclusive disjunction) which returns true iff at least one proposition is true:</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: right">$p$</th>
          <th style="text-align: right">$q$</th>
          <th style="text-align: right">$p \lor q$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
        </tr>
      </tbody>
    </table>

    <p><br /></p>
  </li>
  <li>
    <p><strong>XOR</strong>, This is a binary operator (exclusive disjunction) which returns true iff exactly one proposition is true:</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: right">$p$</th>
          <th style="text-align: right">$q$</th>
          <th style="text-align: right">$p \oplus q$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
        </tr>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
        </tr>
      </tbody>
    </table>

    <p><br /></p>
  </li>
  <li>
    <p><strong>IMPLICATION</strong>, This is a binary operator which returns false only when $p$ is true and $q$ is false:</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: right">$p$</th>
          <th style="text-align: right">$q$</th>
          <th style="text-align: right">$p \to q$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
        </tr>
      </tbody>
    </table>

    <p>Equivalent identity:</p>
    <ul>
      <li>$p \to q \equiv \lnot p \lor q$</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p><strong>BICONDITIONAL (IFF)</strong>, This is a binary operator which returns true iff both propositions have the same truth value:</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: right">$p$</th>
          <th style="text-align: right">$q$</th>
          <th style="text-align: right">$p \leftrightarrow q$</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">1</td>
        </tr>
        <tr>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
          <td style="text-align: right">0</td>
        </tr>
        <tr>
          <td style="text-align: right">0</td>
          <td style="text-align: right">0</td>
          <td style="text-align: right">1</td>
        </tr>
      </tbody>
    </table>

    <p>Equivalent identity:</p>

    <ul>
      <li>$p \leftrightarrow q \equiv (p \to q) \land (q \to p)$</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>The following relations between conectives are true:</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Symbol</th>
      <th>Read as</th>
      <th>Semantics (under valuation v)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Negation</td>
      <td>$\lnot p$</td>
      <td>not $p$</td>
      <td>$(\lnot p)_v = \neg  (p)_v$</td>
    </tr>
    <tr>
      <td>Conjunction</td>
      <td>$p \land q$</td>
      <td>$p$ and $q$</td>
      <td>$(p \land q)_v = (p)_v \wedge (q)_v$</td>
    </tr>
    <tr>
      <td>Disjunction (inclusive)</td>
      <td>$p \lor q$</td>
      <td>$p$ or $q$</td>
      <td>$(p \lor q)_v = (p)_v \vee (q)_v$</td>
    </tr>
    <tr>
      <td>Implication</td>
      <td>$p \to q$</td>
      <td>if $p$ then $q$</td>
      <td>$(p \to q)_v = \neg (p)_v \vee\ (q)_v$</td>
    </tr>
    <tr>
      <td>Biconditional</td>
      <td>$p \leftrightarrow q$</td>
      <td>$p$ iff $q$</td>
      <td>$(p \leftrightarrow q)_v = (p \to q)_v\wedge(q \to p )_v$</td>
    </tr>
    <tr>
      <td>Exclusive OR</td>
      <td>$p \oplus q$</td>
      <td>either $p$ or $q$, not both</td>
      <td>$(p \oplus q)_v = (p \lor q)_v \wedge \neg(p \land q)_v$</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>Note that, from the formulas above, we can safely assume that <strong>every complex formula can be put in terms of Negation, Conjuntion and Disjunction connectives ($\neg, \wedge, \vee$)</strong>. To demonstrate the equivalences of those expressions all we need is to compare the truth tables of each formula to validate it.</p>

<p>This way, a boolean formula is a well-formed syntactic object, semantically empty. Meaning that it does not have a truth value by itself until a valuation is performed.</p>

<brz>

The valuation (or interpretation) is the process in which every propostional variable involved with a boolean formula adquires a truth value. It is defined as an application. Being $X = \Set{x_1,...,x_n}\subset Var$, then a interpretation of that set is an application as: 

$$ a: X  \to \Set{0,1}$$

Often, since the propositional variables can be ordered, we can define $a$ as a string of the $\Set{0,1}$ alphabet satisfying $\vert a\vert  = \vert X\vert $. Then when we fix a valuation that maps each propositional variable to under a truth value, the formula evaluates to a unique truth value as well.

<br />

Thus; the boolean formulas are sintactically well formed strings involving prepositional variables and conectives which are suitable for be valuable or interpreted. They serve to plasm the relation about elements or statements represented in the propositional variables.

<br />

## 2.3. Boolean formulas and Valuations.

Now, consider an example of arbitrary formula. $x_i \in Var: i = 1,2,3,4$, then $out$ is a boolean formula such as:

$$ out = (x_1 \vee \neg x_2 \vee \neg x_3)\ \wedge\ (\neg x_2 \vee x_3 \vee x_4)\ \wedge\ (x_1 \vee x_3 \vee \neg x_4)\ \wedge\ (\neg x_2 \vee \neg x_3 \vee \neg x_4)  $$

Then, the question is, can we find values for $x_i: i = 1,2,3,4$ such makes $out$ true? This can be reformuled as, exists at least one *valuation* $a : \{x_1,x_2,x_3,x_4\} \rarr \{0,1\}$ which makes $out_{a} = 1$?

Lets consider, $a_0 = 1010$, which means $ a_0(x_1) = 1, \ a_0(x_2) = 0, \ a_0(x_3) = 1, \ a_0(x_4) = 0 $, then:

$$ (out)_{a_0} = (1 \vee \neg 0 \vee \neg 1)\ \wedge\ (\neg 0 \vee 1 \vee 0)\ \wedge\ (1 \vee 1 \vee \neg 0)\ \wedge\ (\neg 0 \vee \neg 1 \vee \neg 0) = \\ = 1\ \wedge\ 1\ \wedge\ 1\ \wedge\ 1 = 1 $$

Observe that, for we can consider the following problem $\Pi$. Being $\Sigma = \Set{Var} \bigcup \Set{\vee, \land, \neg }$: 

$$\Pi: \Sigma^* \to \Set{0,1}$$
$$\Pi (B) = 1 \iff \exists a : (B)_a = 1$$

In this context, $a_0=1010$ is a witness for $B = out$. Considering a $V \in DTM$ that accepts a boolean formula $B$ of $m$ connectives and a evalution $a$. $V$ operates connectives simplifying expressions and obtaining the truth value, then we call $V$ our verifier and it would be $V(out,a_0) = 1$.

Observe, that if it is $\Beta$ a boolean formula that has $m$ conectives, then $V(\Beta,a)$ operates simplfying one connective per step so it needs $m$ steps before give the truth value of $(B)_a$, thus is $t_V(n) \in \mathcal{O{(n^1)}}$ and runs in polynomial time, so; $\Pi \in NP$.

<br />

# 3. SAT is NP-complete: Cook-Levin Theorem.

The reason why we introduce before the boolean formulas and demonstrate that the language of all the satisfiiable boolean formulas is an $NP$ language is because we are about to introduce a very important statement: **all problems in $P$ and $NP$ can be verified by transforming them into boolean formulas and showing a solution to the formula.**

<br />

## 3.1. SAT - Boolean Satisfiability Problem.

$SAT$, also known as the Boolean satisfiability problem, asks whether there exists an interpretation that satisfies a given Boolean formula. What we provide above is a concrete case of a more extended language.

Given an alphabet $\Sigma$ with all you need to create a boolean formula and consider as $\text{Form} \subset \Sigma^*$ all those strings which, as boolean formulas, are considered well-formed (in the behalf of simplity we will act as we all know what "well-formed" means so we don't have to provide a formal description about what $\text{Form}$ is). 

Then, we can define $SAT$ language as:

$$SAT := \Set{B | \exists a : (B)_a = 1} \subset \text{Form}$$

<br />

## 3.2. NP-completness. Reductions.

**Reduction. Karp reduction.**

Conceptually, a *reduction* is a way to translate one problem $A$ into another problem $B$ such that solving $B$ (on the translated input) automatically solves $A$. It gets formalized as a a function that preserves membership between reductable languages.

- First, we consider the **Many-one reduction (mapping reduction)**. Being $A,B \subseteq \Sigma^*$, then we say that $A \text{ is many-one reductible to } B$:

    $$A \leq_m B \iff \exists f : \Sigma^* \to \Sigma^* : \forall x \in A \iff f(x) \in B$$

- Then, we define the karp reduction as a polynomial-time many-one reduction. This is, if a exists a total function computable by a turing machine running in polynomial time.

    $$A \leq_p B \iff \exists f : \Sigma^* \to \Sigma^* : \Big(  x \in A \leftrightarrow  f(x) \in B \ \land \ \exists M \in TM : \big( \ t_M \in \mathcal{O}(n^k) \land M(x)=f(x) \ \ \forall x \in A\big)\Big)$$

    Note that the term $M(x)$ is non-standard but is a license to refer to the computation of $x$ by $M$.

<br />

**NP-completness**

$NP-complete$ problems are the hardest of the problems to which solutions can be verified quickly. 

A problem $L$ is $NP-complete$ when satisfies:

- $L \in NP$
- $L$ is $NP-hard$, this means; every other problem in $NP$ can be reduced to it in polynomial time:

    $$ \forall H \in NP \ \ H \leq_p L$$

So NP-hard problems are “hard enough” (in complexity terms) to subsume the whole class NP via polynomial-time reductions.

<br />

## 3.3. SAT is NP-complete.

Suppose you have two binary numbers $P,Q$ and you want to know if $P&gt;Q$. This can be formuled in terms of decision problem

Until this point, we have now enough tools to understand what the statment "$SAT$ is $NP-complete$" means:

It means that any other problem in NP can be reduced in terms of SAT, or said in other terms, any instance of an $NP$ problem can be translate as an instance of $SAT$, this way; verifying an input of a NP decision problem is equivalent to verify the satisfiability of one concrete boolean formula.

Let's see a bunch of examples:

<br />

# 4. Examples.
 
## 4.1. Checking if a list is sorted using a boolean formula.

Consider $p,q \in \Set{0,1} \wedge 1 &gt; 0$ it is:

$$p &gt; q \iff p \ \land \neg q$$
$$p=q \iff (p \land q) \vee \neg (p \vee q)$$

Essentially meaning that $p &gt; q$ only if is $p$ is true and $q$ false. We can quicly check this result by comparing the true table:

| $p$ | $q$ | $p &gt; q$ | $p \land \neg q$ | $p = q$ | $(p \land q) \vee \neg (p \vee q)$ |
|:---:|:---:|:-----:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 | 0 | 0 |
| 1 | 1 | 0 | 0 | 1 | 1 |

<br />

If we consider $A \in \Set{0,1}^*$ then is: $A := a_1...a_n : a_i \in \Set{0,1} \forall i \leq n \in \mathbb{N}$ (although we are not force to it, we always consider finites strings in this case).

Now, being $P,Q \in \Set{0,1}^*$ interpreted both as a representation in base 2 of a numeric value (a binary number, can safely assume that $\vert P\vert  = \vert Q\vert  = n$, if not, we add zeros to the shortest string until the equiality is meeted) then it is 

$$P &gt; Q \iff \exists i \leq n:p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i$$

Let's demonstrate the statement above.

1. First, in order to see it clearly, lets understand that a decimal representation from $A$ can be obtained as:

    $$A_{10} = a_0·2^{n-1} ... + a_n·2^{n-n} = \sum_{t = 1}^n a_t·2^{n-t}$$


    In order to demonstrate the statement above, first demonstrate that:

    $$a_i · 2^{n-i} &gt; \sum_{t = i+1}^n a_t·2^{n-t} \ \ \forall i \leq n : a_i \neq 0$$

    Observe that since is $a_j \in \Set{0,1} \ \forall j &gt; i$, we can reduce the demonstration applying two index changes and summatories properties to a geometric sum: 

    $$2^{n-i} &gt; \sum_{t = i+1}^n 2^{n-t} \ \underbrace{\iff}_{h = n-i} \  2^h &gt; \sum_{t=i+1}^{h+i}2^{h+i-t} \underbrace{\iff}_{k=0} 2^h &gt; \sum_{k=0}^{h+i - (i+1)}2^{h+i-(k+i+1) } \iff 2^h &gt; \sum_{k=0}^{h-1} 2^{h-1 - k} = \sum_{k=0}^{h-1} 2^{k}$$

    which is a well known result:

    $$S=\sum_{t=0}^{h-1}2^{t},\qquad 2S=\sum_{t=1}^{h}2^{t},\qquad 2S-S=2^{h}-1\ \Rightarrow\ S=2^{h}-1$$

    <br />

2. Reverse Implication: $\exists i \leq n:p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i \implies P &gt; Q$

    <br />

    Let's take $P_{10}$ and $Q_{10}$:

    $$P_{10} - Q_{10} = \sum_{t = 1}^n p_t·2^{n-t} - \sum_{t = 1}^n q_t·2^{n-t} =$$
    $$= \sum_{t = 1}^i p_t·2^{n-t} - \sum_{t = 1}^i q_t·2^{n-t} + \sum_{t = i+1}^n p_t·2^{n-t} - \sum_{t = i+1}^n q_t·2^{n-t} $$

    <br />
    
    Since $p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i$, the above is:

    $$P_{10} - Q_{10} = p_i · 2^{n-i} + \sum_{t = i+1}^n p_t·2^{n-t} - \sum_{t = i+1}^n q_t·2^{n-t}$$

    And, since $p_i,q_i \in \Set{0,1}$, due to **(1)** is:

    $$p_i · 2^{n-i} - \sum_{t = i+1}^n q_t·2^{n-t} &gt; 0 \ \Rightarrow \ P_{10} - Q_{10} &gt; 0$$

    <br />

3. Direct Implication: $ P &gt; Q \implies \exists i \leq n:p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i$, observe that:

    $$ P &gt; Q \iff P_{10} &gt; Q_{10} \iff \sum_{t = 1}^n p_t·2^{n-t} &gt; \sum_{t = 1}^n q_t·2^{n-t}$$

    Then, let's assume that the implicated statement is not true and see that it triggers a contradiction:
    
    $$\neg(\exists i \leq n:p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i) \iff  \neg (p_i &gt; q_i) \ \ \forall i \leq n \ \vee \ \exists j &lt; i : \neg(p_j = q_j)$$

    Let's observe that:

    - $\neg(p_i &gt; q_i) \iff (q_i &gt; p_i) \vee (p_i = q_i)$
    
    $$(q &gt; p) \vee (p = q) \iff (q \land \neg p) \vee (p \land q) \vee \neg (p \vee q) \equiv q \land \cancel{(\neg p \vee p)}_\top \vee (\neg p \land \neg q) \equiv$$
    
    $$\equiv (q \vee \neg p) \land \cancel{(q \vee \neg q)}_{\top} \equiv \neg(p \land \neg q) \iff \neg(p &gt; q)$$

    - $\neg(p_j = q_j) \iff (p_i &gt; q_i) \vee (q_i &gt; p_i):$

        $$\neg(p= q) \iff \neg[(p \land q) \vee \neg (p \vee q)] \equiv \neg(p \land q) \land (p \vee q) \equiv (\neg p \vee \neg q) \land (p \vee q) \equiv$$
        $$\equiv [(\neg p \vee \neg q) \land p] \vee [(\neg p \vee \neg q) \land q] \equiv [\cancel{(\neg p \land p)}_\bot \vee (\neg q \land p)] \vee [(\neg p \land q) \vee \cancel{(\neg q \land q)}_\bot] \equiv$$
        $$\equiv (p \land \neg q) \vee (q \land \neg p) \iff (p &gt; q) \vee (q &gt; p)$$


    Thus, we have two ways to negate the premise:

    <br />

    - First, we have the trivial cases:

        $$\forall i \leq n : \begin{cases} \ q_i &gt; p_i \\ \ p_i,q_i \in \Set{0,1} \end{cases} \implies p_i = 0 \land q_i =1 \ \  \forall i\leq n \implies Q_{10} &gt; P_{10}$$

        $$\forall i \leq n : p_i = q_i \iff Q_{10} = P_{10}$$

        <br />

    -  Then, we consider the second version:

        $$\exists i : p_i &gt; q_i \ \land \ \exists j&lt;i : p_j \neq q_j \Rightarrow \begin{cases} p_j &gt; q_j \\ q_j &gt; p_j \end{cases}$$

        If $p_j &gt; q_j$ then we make i = j and reevaluate, then, we can safely assume that is $q_j &gt; p_j \ \land \ \neg \exists m &lt; j : p_m &gt; q_m $. Thus:

        $$Q_{10} - P_{10} = \sum_{t = 1}^j q_t·2^{n-t} - \sum_{t = 1}^j p_t·2^{n-t} + \sum_{t = j+1}^n q_t·2^{n-t} - \sum_{t = j+1}^n p_t·2^{n-t} = $$

        $$ \sum_{t = j+1}^n q_t·2^{n-t} + q_j·2^{n-j} - \sum_{t = j+1}^n p_t·2^{n-t} - \cancel{p_j·2^{n-j}}_0 + \sum_{t = 1}^{j-1} q_t·2^{n-t} - \sum_{t = 1}^{j-1} p_t·2^{n-t} &gt; 0 $$

        Let's observe that there are two differences but both of them are greater than $0$, the first one starting from the left is due to the result we demonstrate above along with the fact that $p_i,q_i \in \Set{0,1} \forall i \leq n$, the second one is due to the premise: $\neg \exists m &lt; j : p_m &gt; q_m $

        <br />

This essentially justifies the existence of an algorithm that for $P,Q \in \Set{0,1}^*$ goes checking $p_i, q_i : i \leq n \in \mathbb{N}$ and accepts the input considering that for the first $i: p_i &gt; q_i \Rightarrow P &gt; Q$, if this condition is not meet, the algorithm rejects and is $\neg (P &gt; Q)$.

```

P1 = 1001 
            =&gt; ACCEPTS =&gt; p_4 &gt; q_4 =&gt; P &gt; Q
Q1 = 1000 



P2 = 1001
            =&gt; REJECTS =&gt; P = Q
Q2 = 1001

```

Let's observe that the solution to this problem (the procedure of the algorithm) can model as a bolean formula:

$$p_1 &gt; q_1 \vee (p_1 = q_1 \land p_2 &gt; q_2) \vee (p_1 = q_1 \land p_2 = q_2 \land p_3 &gt; q_3) ...$$

Which is similar to: 

$$\bigvee_{i=1}^{|P|} \Big[\bigwedge_{j=1}^{i -1} [p_j = q_j] \land (p_i &gt; q_i)\Big] \iff \bigvee_{i=1}^{|P|} \Big[\bigwedge_{j=1}^{i -1} \big[(p_j \land q_j) \vee \neg(p_j \vee q_j)\big] \land \big(p_i \land \neg q_i\big)\Big]$$

<br />

Lets observe that in the case $i=1$ results in an "empty conjunction" and an "empty disjunction", which by convention is:  

$$ \bigwedge_{j=1}^{1-1} p_j = q_j  \iff \bigwedge_{j=1}^{0} (p_j \land q_j) \vee \neg(p_j \vee q_j) \iff \top \vee \neg \bot \equiv \top$$

<br />

Now, let's consider $\Pi_Q : Q \in \Set{0.1}^*$ the decision problemd defined as: $L_{\Pi_Q} := \Set{P \vert  P &gt;Q}$.

Then the boolean formula we just crafted above models the problem in the sense that, for any $x \in \Set{0,1}^*$:

$$x \in L \iff (B_x)_x = \Bigg( \bigvee_{i=1}^{|x|} \Big[\bigwedge_{j=1}^{i -1} [x_j = q_j] \land (x_i &gt; q_i)\Big] \Bigg)_x= \top$$

Thus we define:

$$f: \Set{0,1}^* \to \Sigma^*_{SAT}$$
$$ f(x) := B_x $$

This function satisfies the requisites of the karp reduction

- $f$ is polynomically computable since we can define $V \in DTM$ that computes $(B)_x$ in polynomial time as we see above.
- $f$ preserves ownership between $L$ and $SAT$, $x \in L \iff f(x) = B_x \in SAT$.


So is $L_{\Pi_Q} \leq_p SAT$. 

Observe that in this case, despite we showed that we can verify a solution to a problem verifying a solution to a trivial formula, there is no witness. This is because this is a P problem, and in this specific case $V$ that computes $(B)_x$ is also de decider of $L$ so no aid is needed. This does not mean that there are $P$ in problems that admits verificators that needs witness as well.

<br />

## 4.2. Map-coloring problem: Graph theory.

There is a problem knew as the *map-coloring problem*, which ask about for how many colors do you need (in the sense of minimum required) to color a map. The canonical result is the *Four Color Theorem*, which states that any planar map can be colored with at most four colors so that adjacent regions differ. The Four Color Theorem has 3-color variant, known as the 3-colorability problem which asks what maps admits being colored with no more than 3 colors.

All this problematic is presented and understanded in the terminology of *Graph Theory*; which is the discipline of mathematics which occupies about the study of discrete relation's structures and his properties.

<br />

### 4.2.1. Introduction to Graph Theory.

#### 4.2.1.1. Graphs and Subgraphs. Vertices and Edges. Neighborhood.

We call as a **graph** to the pair $G := (V,E)$ where:

- $V$ is a finite non-empty set whose elements are called *vertices*.
- $E \subseteq \binom{V}{2}$ and his elements are called *edges*.

<br />

As a brief apex, it is:

$$ \binom{V}{2} := \Set{\Set{u,v} \subseteq V : u \neq v} $$

Where $\Set{u,v}$ is a not-ordered set (in contrast with $(u,v)$).

Then, we have the following definitions:

- If $\Set{u,v} \in E$, then $u,v \in V$ are say to be **adjacents**. 
- For $v \in V$, $N(v) := \Set{u \vert  \Set{u,v} \in E} \subseteq V$ is the **neighborhood of $v$**, and $\vert N(v)\vert $ is called his **degree**.

In general, is not safe to assume that $\vert N(v)\vert  \geq 1 \ \forall v \in V$.  We call $Iso(G) := \Set{v \in V : \vert N(v)\vert  = 0}$ and the following relation can be verified:

$$V = \bigcup_{v \in V} N(v) \cup Iso(G)$$

<br />

For a graph $G := (V,E)$:

- A **subgraph** of $G$ is any set:

    $$H := (V_H, E_H) : V_H \subseteq V \land E_H \subseteq E \ \cap \ \binom{V_H}{2}$$

- An **induced subgraph** on $W \subseteq V$:

    $$G[W] := (W, E \cap \binom{W}{2})$$

- A **walk** is a finite sequence of adjacent vertices:

    $$v_0...,v_t:\Set{v_{i-1},v_i} \in E \ \ \forall i \leq t \in \mathbb{N}$$
- A **path** is a walk with all the vertices distinct:

    $$v_0...,v_t:\Set{v_{i-1},v_i} \in E \land v_i \neq v_j \ \ \forall i,j \in \mathbb{N}$$

- A **cycle** is a walk $v_0,...,v_{t-1},v_0$ where $v_0,...,v_{t-1}$ is a path.

- A **complete** graph $G$ is a graph where every pair of vertices are connected by an edge:

    $$G := (V,E) : E = \binom{V}{2}$$

    Observe that this means that $\vert N(v)\vert  = \vert V\vert  - 1$.


<br />

Going back to isolated vertices, we say that 

$$G \text{ is connected } \iff \forall u,v \in V \ \exists \text{ a path}: u,w_1...,w_{t-1},v  $$

<br />

#### 4.2.1.2. Graph coloring.

Being, $G := (V,E)$, then a $k\text{-coloring}$ of $G$ is an application:

$$c : V \to \Set{1,...,k} : \forall \Set{u,v} \in E \ \ c(u)  \neq c(v)$$

For $G$, we define his **chromatic number** as the minimum number for which exists a coloration:

$$\chi(G) := min\Set{k | \exists c : V \to \Set{1,...,k} \text{ is a } k\text{-coloring}}$$

Observe that this means that the Four Colour theorem exposes $\chi(G) \leq 4 \ \ \forall G$ and the 3-coloring problem ask whether, $\chi(G) \leq 3$.

<br />

Let's observe that:

1. For a complete graph $K_n$ (where $\vert V_K\vert  = n$), is: $\chi(K_n) = n$.

    - First, let's see that $c : V_K \to \Set{1,...,n}$ is *injective* ($\vert V_K\vert  = \vert \Set{1,...,n}\vert $) and it verifies:

        $$\forall u,v \in V_K : u \neq v \implies c(u) \neq c(v)$$

        Also, since $K_n$ is a complete graph, $\forall u,v \in V_K : u \neq v \iff \Set{u,v} \in E_K$, thus:

        $$\forall \Set{u,v} \in E_K \ \  c(u) \neq c(v)$$

        And $c$ is a coloration.

        <br />

    - Let's see now that $\neg (\exists i &lt; n : c : V_K \to \Set{1,...,i} \text{ is a coloration})$.

        Simply, considering $c : V_K \to \Set{1,...,i}$ with $ i &lt; n$, then $c$ is *no injective* and it verifies the *pigeonhole principle*:

        $$\exists u,v \in V_K : u \neq v \land c(u) = c(v)$$

        Again, for $\forall u,v \in K_n \ \ u \neq v \iff \Set{u,v} \in E_K$ and thus:

        $$\exists \Set{u,v} \in E_K : c(u) = c(v)$$

        And $c$ is no coloration.

        <br />

2. For a cycle $C_n$, $\chi(C_n) = 2$ if $n$ is even and $\chi(C_n) = 3$ if $n$ is odd.

    First, let's define what a cycle graph is: 
    
    $$C_n := (V_C, E_C) : \begin{cases} V_C = \Set{v_0,...,v_{n-1}} \\ E_C = \Set{\Set{v_{i-1},v_i} : i \in \Set{1,...,n-1}} \cup \Set{\Set{v_{n-1},v_0}} \end{cases}$$

    Let's observe that, as defined, the sequence: $v_0,...,v_{n-1}$ is a path, thus $v_0,...,v_{n-1},v_0$ is a cycle.

    - Now, consider the case $\exists m : n = 2m$, then, we define:

        $$c : V_C \to \Set{1,2} : c(v_i) = \begin{cases}  1 \ \text{ if } i  \text{ is even}\\ 2 \ \text{ if } i  \text{ is odd} \end{cases}$$

        It is clear that even and odd numbers alternates each in a consecutive numeric sequence. So:

        $$c(v_{i-1}) \neq c(v_i) \ \ \forall v_{i-1},v_i \in v_0,...,v_{n-1} \implies c(v_{i-1}) \neq c(v_i) \ \ \forall \Set{v_{i-1},v_i} \in E_C $$

        For the same reason, if $n$ is even, then $n-1$ is odd and $c(v_{n-1}) \neq c(v_0)$, thus, in conclusion:

        $$c(u) \neq c(v)  \ \ \forall \Set{u,v} \in E_C$$

        And $c$ is a $2-coloring$ of $C_n$. Obviously since $E_C \neq \varnothing$ it can't be $\chi(C_n) = 1$.

        <br />

    - If $n = 2m + 1$ and we suppose the existence of a $2-coloring$, $c$ over $C_n$, then: 

        $$c(u) \neq c(v) \ \ \forall \Set{u,v} \in E_C \implies c(v_{i-1}) \neq c(v_i) \ \ \forall \Set{v_{i-1},v_i} \in E_C \iff$$
        $$ \iff c(v_{i-1}) \neq c(v_i) \ \ \forall v_{i-1},v_i \in v_0,...,v_{n-1}$$

        Or, in other words, any consecutive vertex in the path $v_0,...,v_{n-1}$ has different image under $c$. 
        
        Thus, is easy to see that:
        
        - Since in a $2-coloring$ there are only two possible images values 
        
        - And $n-1$ is even (because $n$ is odd), 
        
        Then $v_0$ and $v_{n-1}$ share the same image under $c$ and it is:
        
        $$c(v_{n-1}) = c(v_0) \land \Set{v_{n-1},v_0} \in E_C$$
        
        Triggering a contradiction with the $2-coloring$ requirement.

        Getting the example of $c$ provided above, is easy to see that:

        $$c : V_c \to \Set{1,2,3} : c(v_i) = \begin{cases}  1 \ \text{ if } i  \text{ is even } \land i \neq n -1\\ 2 \ \text{ if } i  \text{ is odd} \\  3 \end{cases}$$

        Is a $3-coloring$ of $C_n$.

        <br />

3. **Bipartite Graphs**.

    A bipartite graph is a graph $G_B$ satisfying:

    $$G_B := (V_B,E_B): \begin{cases}V_B := A \sqcup B \ \ (V = A\cup B \land A \cap B = \varnothing) \\ E_B \subset \binom{V_B}{2} : a \in A \land b \in B \ \ \forall \Set{a,b} \in E_B \end{cases}$$

    Then, consider 
    
    $$c : V_B \to \Set{1,2} : c(v) =\begin{cases}  1 \ \ \text{ if } v \in A\\ 2 \ \ \text{ if } v \in B \end{cases}$$

    Then:

    $$\forall \Set{u,v} \in E_B \ \  \begin{cases} u \in A  \Rightarrow c(u) = 1 \\ v \in B \Rightarrow c(v) = 2 \end{cases} \implies c(u) \neq c(v)$$

    And $c$ is a $2-coloring$ of $G_B$. Of course, $E_B \neq \varnothing \implies \chi(G_B) \neq 1$.

    <br />

4. **2-colorability theorem**.

    The 2-colorability caracterization stands for, being $G := (V,E)$ a graph, then:

    $$\chi(G)=2 \iff G \text{ is bipartite } \iff \neg \exists\,\text{cycle } C \subseteq G : |C|\ \text{ is odd} $$

    Observe that we already demonstrate that:

    - $G \text{ is bipartite } \implies \chi(G)=2$
    - $\chi(G)=2 \implies \neg \exists\,\text{cycle } C \subseteq G : \vert C\vert \ \text{ is odd}$ (since all odd cycle has a 3 as a chromatic number).
    - $\chi(G)=2 \implies G \text{ is bipartite }$

       Observe that

        $$\chi(G)=2 \implies \exists c :V \to \Set{1,2} : c(u) \neq c(v) \ \ \forall \set{u,v} \in E$$

        We define: 

        $$\begin{cases}A := \Set{u \in V | c(u) = 1} \\ B:= \Set{u \in V | c(u) = 2}\end{cases}$$

        In this context, since $c$ is an application we have:

        - $v \in V \Rightarrow c(v) = 1 \vee c(v) =2 \Leftrightarrow v \in A \vee v \in B \Rightarrow V = A \cup B$

        - $A \cap B = \varnothing$

        - $\forall \Set{u,v} \in E \implies c(u) \neq c(v) \implies  (u \in A \land v \in B) \vee (v \in A \land u \in B)$

        <br />

        Thus, $G$ verifies:
        $$\begin{cases}V := A \sqcup B \ \ (V = A\cup B \land A \cap B = \varnothing) \\ E \subset \binom{V}{2} : a \in A \land b \in B \ \ \forall \Set{a,b} \in E \end{cases}$$

    Now, only last to demonstrate that:

    - $\neg \exists\,\text{cycle } C \subseteq G : \vert C\vert \ \text{ is odd} \implies G$ is bipartite. 

        The premise can be negated in two ways:

        - First, $\neg \exists C \subseteq G : C \text{ is a cycle}$, then consider a vertex we call $r$ and: $A = \Set{u \vert  dist(r,u) \text{ is even}}$ and $B = \Set{u \vert  dist(r,u) \text{ is odd}}$. Then is pretty obvius that $A \cup B$ and we impose that $A \cap B = \varnothing$, let's observe that this impossition requires no odd cycles.

            Being $C \subseteq G : C \text{ is odd}$, then, $C:=v_0,...,v_{n-1},v_0$ where $v_0,...,v_{n-1}$ is a path and $\Set{v_{n-1},v_0} \in E$. Lets say $r : dist(r,v_0) \land r \notin C$. Then, since $C$ is a cycle there are two paths to measure the distance between $r$ and $v_{n-1}$:

            $$dist(r,v_{n-1}) = dist(r,v_0) + dist(v_0,v_{n-1})$$

            Since $\Set{v_{n-1},v_0} \in E \Rightarrow dist(v_0,v_{n-1}) = 1 \Rightarrow dist(r,v_{n-1}) = 2 \text{ (even)}$, but also, since $C$ is odd, $n-1$ is even (meaning that $dist(v_0,v_{n-1})$ is even and $1 + dist(v_0,v_{n-1}) = dist(r,v_{n-1})$ is odd). So in summary: $A \cap B \neq \varnothing$

           <br />

#### 4.2.1.3. Plannar graphs. Drawings and faces. Euler's formula.

A *planar graph* is a graph that admits a graphical representation on a plane such its edges do not cross each other. For example, Complete graph $K_3$ do admit a representation in which the edges not cross, but $K_5$ do not.

Let be $G:=(V,E)$ a finite simple graph, then an embedding of $G$ into $\mathbb{R}^2$ is a function $\phi: G \to \mathbb{R}^2$ that:

- $\forall u,v \in V \ \ \left(\phi(u), \phi(v) \in \mathbb{R}^2 \land u \neq v \implies \phi(u) \neq \phi(v) \right)$

- $\forall e, f \in E \ \ \left( \phi(e) = \gamma_{e_1e_2}, \phi(f) = \gamma_{f_1f_2}  \in \mathbb{R}^2 : e \neq f \implies \phi(e) \cap \phi(f) \subseteq \Set{\phi(e_1),\phi(e_2),\phi(f_1),\phi(f_2)} \right)$


Where $\gamma_{uv}$ is a simple arc (non-self-intersecting, continuous curve) from $\phi(u)$ to $\phi(v)$. $\phi$ maps the edges of $G$ ensuring that two different arcs only share endpoints as much.

Then, $G$ is said to be planar if admits a embedding $\phi$ in $\mathbb{R}^2$ as above.

<br />

Associated to a drawing of a planar graph are the so called *faces*, grouped in the set $F$; which are enclosed regions of the plane $\mathbb{R}^2$ by the planar drawing of the graph (here is included the unbound outer face extranl to the graph). The Euler's formula specifies that, for a complete planar graph $G:= (V,E)$, being $F$ the set of the faces of the drawing graph, then:

$$|V| - |E| + |F| = 2$$

<br />

#### 4.2.1.4. Dual graphs.

Given a connected planar graph $G$, then, the *dual graph* is what you get when you turn faces into vertices in a planar embedding of $G$. 

The drawing (planar embedding) cuts the plane into regions (faces), one unbounded “outside” face plus the bounded ones, then the dual $G^*$ is built by:

- Putting one vertex inside each face of $G$.
- For each $e \in E$ there exists one $e^* \in E^*$ crossing once $e$, connecting two faces.

Formally;

Being $G$ a connected planar graph and $\phi$ his drawing in $\mathbb{R}^2$. Then, we define the dual graph $G^*:= (V^*,E^*)$:

$$\begin{align}V^* &amp;:= F = \Set{f : f \text{ is a face of }(G,\phi)} \\ E^* &amp;:= \Set{\Set{f_1,f_2} | \exists e \in E \text{ between } f_1 \text{ and } f_2 } \subseteq \binom{V^*}{2}\end{align}$$

Is important to understand that *Dual depends on the embedding*: Two different planar drawings of the same abstract planar graph can produce non-isomorphic duals. The dual is canonical only after you fix the embedding.

In this context, a map coloring is equal to color a dual graph. A map representation is in fact a dual graph.

<br />

### 4.2.2. Formuling the problems. Three-coloring problem.

#### 4.2.2.1. Describing the problem.

With the notion we have gathered, then, the Four Color Theorem (the “all maps” statement), states that, for every planar graph $G$, the chromatic number is as much 4 $\chi(G) \leq 4$. It only required four colour to color every planar map.

How ever, for example $\chi(K_4)=4$, so three colors is not always sufficent. And we can formulate the problem as the language:

$$L := \Set{G | \chi(G)\leq 3}$$

How ever, in this terms, $G$ still a graph and not a string codificaction of a graph and it isn't a computable decision problem.

<br />

#### 4.2.2.2. Graph Encoding.

**Matrix reduction**

Given a finite simple undirected graph $G :=(V,E) : \vert V\vert  = d \in \mathbb{N}$, then consider the following elements:

- Being $[d] := \Set{1,...,d} \subset \mathbb{N}$ the function $T$ such: 

    $$T: V \to [d] : \Big(u \neq v \Rightarrow T(u) \neq T(v) \Big)\ \ \ \forall v,u \in V$$

    Meaning that any vertex is mapped to a distinct natural number between $1$ and $\vert V\vert $. Observe that $T$ is bijective (our imposed condition makes it injective and since both domain and codomain have the same cardinal; from the injectivity we obtain the surjectivity and thus the bijectivity) and we can consider its inverse $T^{-1}$.

    <br />

- The function $T'$ such:

    $$\begin{align}T'&amp;: \binom{T(V)}{2} \to \Set{0,1} \\ T'(\Set{n,m}) &amp;= \begin{cases} \ 1 \ \ \ \Set{T^{-1}(n),T^{-1}(m)} \in E \\ \ 0 \ \ \ \Set{T^{-1}(n),T^{-1}(m)} \notin E\end{cases}\end{align}$$

    We define $T'(E):=\Set{\Set{n,m} \vert  T'(\Set{n,m}) = 1 } \subseteq \binom{T(V)}{2}$

    <br />

- The matrix:

    $$M_{d} := (a_{ij})_{i,j \in T(V)} : a_{ij} = \begin{cases}  \ 1 \ \ \ \Set{i,j} \in T'(E) \\ \ 0 \ \ \ \Set{i,j} \notin T'(E)\end{cases}$$
    
    This is called the *edge matrix*, and it stores the edges of $G$ in form of entries up to one. Since this is a simmetric matrix, we end defining his upper part to evade redundances:

    $$M^+_{d} := (a^+_{ij})_{i,j \in T(V)} : a_{ij}^+ = \begin{cases} \ \ a_{ij} \ \ \ i &lt; j \\ \ \ 0  \ \ \ \ \ \ i \geq j\end{cases}$$

In this context, we can reduce $G$ to $M^+_{d}$ in the sense that $M^+_d$ has all the necesary information to craft an equivalent graph $G_T$ of $G$:

$$M^+_d \to G_T \ := ([d], E_T) :E_T = \Set{\Set{i,j}:a^+_{ij} = 1 \land i &lt; j}$$

<br />

**Matrix Encoding**

Let be $M_n := (a_{ij})_{i,j \in [n]}$, then, we can reorganize the $a_{ij}$ elements by following rows: 

$$\langle M_n \rangle : = (a_{11}...,a_{1n},a_{21},...,a_{nn}) = (\alpha_s)_{s \in [n^2]} : a_{ij} = \alpha_{n·(i-1) + j}$$

Let's see how to reconstruct $M_n$ from the sequence $(\alpha_s)_{s \in [n^2]}$. 

Let's think that in $M_n$, each row is a group of $n$ elements and each colum is a number between $1$ and $n$, thus the euclidian division fits well giving us as a final result:




$$(\alpha_s)_{s \in [n^2]} \to (a_{ij})_{i,j \in [n]}: \begin{cases} i =\left\lfloor \frac{s-1}{n}\right\rfloor +1 \\ j = ((s-1) \text{mod } n) +1 \end{cases}$$

Observe that each row of $M_n$ is a set of $n$ elements, thus is in our interest to decompose any index $\alpha_m$ in terms of $n$ through the Euclid Division theorem.

Being 

$$\alpha_m \in (\alpha_s)_{s \in [n^2]} \implies \exists p,q \in \mathbb{N} : m = np + q \land 0 \leq q &lt; n$$

Observe that this expression is telling us two things:

1. $p$ tell us how many times is $m$ contained in $n$. This is related with how many rows $\alpha_m$ is down as $a_{ij}$ on $M_n$.
2. $q$ how much is left over to $m$ to be a $n$-multiple. This is related with how many columns has left to the left $\alpha_m$ as $a_{ij}$ on $M_n$.

Both of them are related to the position of $\alpha_m$ as $a_{ij} \in M_n$ but not in a straight way. 

Specifically, this equation has two problems:

- First, $q$ adjusts just fine to the colum place $j$ in the sense that correctly defines the position $p·n \leq m \leq (p + 1)·n$ but $q$ do not exists in an interval compatible with $j$, since $q \in [0,n-1] \cap \mathbb{N}$ and $j \in [n]$. 

    Thus, we have to find a similar expression of the euclid division between $m$ and $n$ that fits $q$ in the correct set of values:

    $$m = np + q : 0 \leq q &lt; n \iff m-1 = np+ (q-1) : 0 \leq q-1 &lt; n \implies q\in [n]$$

    This expresion correctly defines $q$ in a compatible way with $j$. Clearing $q$ we obtain: 
    
    $$j = q = ((m-1)\text{mod } n) +1$$

    <br />

- Now, we have a similar problem with the rows. As we said above, the expression tells us the number of times that $n$ fits on $m$. Traduced to $M_n$ if $p=0 \implies i=1, p = 1 \implies i = 2$, and so on. 

    Thus, $i = p + 1$, again clearing we have:

    $$i = p + 1 = \left\lfloor \frac{m-1}{n}\right\rfloor +1$$

    Where $\left\lfloor \frac{a}{b}\right\rfloor$, denotes the entire divison of $a$ between $b$.

    Note that, to obtain $i$ we did not cleared from $m = p·n + q$ but from $m-1 = p·n + (q-1)$, since the last accurately identifies $j \leftrightarrow q$, in the first expression this do not happen and thus there are unaccuracies from some edgy cases like for example $m$ being multiple of $n$.


<br />

#### 4.2.2.3. Forming the problem.

**Conceptual definition**

Given a $G:=(V,E)$ and a function $c:V \to \Set{1,2,3}$, then if:

$$\forall \Set{u,v} \in E, \ c(u) \neq c(v) \iff c \text{ is a coloration on G} \implies \chi(G) \leq 3$$

This essentially means that, conceptually, we can ensure that $\chi(G) \leq 3$ if the function $c$ defined as above is indeed a coloration by checking that there are no neighbours vertex with the same color. 

<br />

**Formalizing the language**

Given the alphabet $\Sigma = \Set{0,1}$, then we just see above that any graph $G:=(V,E):\vert V \vert = n$ can be reduced to a square matrix $M^+_n$ and then to a string of $(\alpha_s)_{s\in[n^2]}  \in \Sigma^*$. 

Now, lets define:

$$c_T: [n] \to \Set{\alpha, \beta, \gamma} : c_T(i) = \begin{cases}\alpha \ \ \ \ c(u) = 1 \\ \beta \ \ \ \ c(u) = 2  \\ \gamma \ \ \ \ c(u) = 3  \end{cases} \ \  \land \ \ u = T^{-1}(i) $$

Observe that as defined; $c$ is a coloration on $G:=(V,E)$ iff $c_T$ is a coloration of $G_T:=([d],E_T)$, since:

$$c(u) \neq c(v) \ \ \forall \Set{u,v} \in E \iff c_T(i) \neq c_T(j) \ \ \forall \Set{i,j} \in E_T$$


Thus, applying $c_T$ to the sucession $(\alpha_s)_{s\in[n^2]}$ and $i,j$ translation. The language to decide is:

$$L = \Set{(\alpha_s)_{s\in[n^2]} | \exists c_T : [n] \to \Set{\alpha, \beta, \gamma}: c_T\left(\left\lfloor \frac{s-1}{n}\right\rfloor +1\right) \neq c_T\left(((s-1) \text{mod } n) +1\right) \ \ \forall s : \alpha_s=1}$$

<br />

#### 4.2.2.4. Verifying L.

In this terms, we can think in a verifier that admits a sucesion and a function as described above $V((\alpha_s)_{s\in[n^2]} ,c_T)$ and goes iterating over each term of the sequence $\alpha_s$ performing:

0. $\begin{cases} s \leq n(n-1) \to (1) \land \alpha_s (q_1) \\ s&gt; n(n-1) \to \text{ACCEPT STATE}\end{cases}$

1. $\begin{cases} \alpha_s = 1 \to (2) \land \alpha_s \\ \alpha_s = 0 \to (0) \land \alpha_{s+1}\end{cases}$

2. $\begin{cases} c_T\left(\left\lfloor \frac{s-1}{n}\right\rfloor +1\right) = c_T\left(((s-1)\mod n) +1\right) \to \text{ REJECT STATE } \\ c_T\left(\left\lfloor \frac{s-1}{n}\right\rfloor +1\right) \neq c_T\left(((s-1)\mod n) +1\right) \to (0) \land \alpha_{s+1}\end{cases}$

Let's observe that calling each step $p^s_i,q^s_i$ for the term $s$ of the sequence from $i=0,1,2$, a non-rejected path for the term $\alpha_s \in (\alpha_s)_{s\in[n^2]}$ by $V$ can be described as:

$$q^s_0 \vee (p^s_0 \land (q^s_1 \vee (p^s_1 \land q^s_2)))$$

Thus, for the $n(n-1)$ terms (observe that from the sequence we are eliminating those that correspond to the last row of $M_d^+$ which is zeroed) the complete accept path of $V((\alpha_s)_{s\in[n^2]},c_T)$ is:

$$\bigwedge_{s=0}^{n(n-1)} \left[q^s_0 \vee (p^s_0 \land (q^s_1 \vee (p^s_1 \land q^s_2)))\right]$$

Meaning that for each term, check if it is $1$ or $0$ and if it is $1$, then compares through $c_T$. By SAT, verifying and input of $L$ is equivalent to find a valuation to that expression that makes it true. 

<br />

# 5. Conclusion.

As a summary, in this section we see what boolean formulas are and the NP's SAT problem, which ask wheter a boolean formula have a valuation making it true. 

We also see that SAT is NP-complete, meaning that is hard enough (in complexity terms) to polynomially reduce any other NP problem to SAT which eventually decays on the following corolary: any NP problem instance can be verified by verifying a SAT instance, this is; a correct valuation to a boolean formula that models the problem.
</brz>]]></content><author><name>German Sanmi</name></author><category term="Maths" /><category term="mathematics" /><category term="theory" /><summary type="html"><![CDATA[0. Index. Expressing problems and solutions as Boolean formulas. Boolean Logic. 2.1. Introduction. 2.2. Boolean Formulas. Propositional variables and connectives. 2.3. Boolean formulas and Valuations. SAT is NP-complete: Cook–Levin Theorem. 3.1. SAT – Boolean Satisfiability Problem. 3.2. NP-completeness. Reductions. 3.3. SAT is NP-complete. Examples. 4.1. Checking if a list is sorted using a boolean formula. 4.2. Map-coloring problem: Graph theory. 4.2.1. Introduction to Graph Theory. 4.2.1.1. Graphs and Subgraphs. Vertices and Edges. Neighborhood. 4.2.1.2. Graph coloring. 4.2.1.3. Plannar graphs. Drawings and faces. Euler’s formula. 4.2.1.4. Dual graphs. 4.2.2. Formuling the problems. Three-coloring problem. 4.2.2.1. Describing the problem. 4.2.2.2. Graph Encoding. 4.2.2.2.1. Matrix reduction. 4.2.2.2.2. Matrix Encoding. 4.2.2.3. Verifying L. Conclusion. 1. Expressing problems and solutions as Boolean formulas. What ties P and NP problems together is that both can be quickly verified. We remember that a verifier is a deterministic turing machine that operates an input and a witness and accepts a YES-instance of a given problem and rejects the NO-instances, on the other hand, we considered the witness of a YES-instance as a proof or certificate of the existance of that same instance. In order to model a problem statement we make uses of formal languages, specifically, of boolean formulas. It is true that: Verifying a solution to a problem in NP or P can be accomplished by verifying a solution to a boolean formula that models the problem. 2. Boolean Logic. 2.1. Introduction. The term boolean-logic refers to a formal framework for reasoning about propositions. It mainly consist of a formal language; an alphabet of symbols from which concatenations of symbols or simply strings are formed. This symbols can be either: Proposition is a statement with a unique, unambiguous truth value (either true or false). Connectives, symbols with a precise significancy that are use to relate primitive propositions to build more complex ones. Boolean logic formalizes reasoning with truth values. Its primitive objects are propositions (statements), and connectives that build new propositions from old or atomics ones. 2.2. Boolean Formulas. Propositional variables and conectives. Boolean Formulas As we say before, boolean-logic formalizes reasoning with truth values by relating propositions with connectives. In order to study those relations arises the boolean formulas, which abstract the logic relations between propositions using propositional variables. Propositional variables and Logical Connectives A propositional variable is mathematical object that stands for a proposition. Is not a preposition itself, it becames a preposition under a valuation, which maps the preposition variable to a truth value. It the most basic syntactic units, consider the following set; $ Var = {p_0,p_1,p_2,…} $, any $ p \in Var $ is a propositional variable. As a intuitional approach, a propositional variable stands for an unspecified statement, with lack of specific content, which eventually can by valuable as true or false becoming straight to a proposition: $ v: Var \rarr {0,1}$. Variables are syntactic placeholders; truth arises only after a valuation is chosen. On the other hand, the logical conectives are the symbols used to relate propositions or propositional variables resulting in other proposition (complex proposition). They are the grammar of propositional logic, this are also called as logical operators. For the following, consider $p, q \in Var$. NOT, This is an unary operator which assigns the opposite truth value of the original proposition: $p$ $\lnot p$ 1 0 0 1 AND, This is a binary operator which returns true iff both propositions are true: $p$ $q$ $p \land q$ 1 1 1 1 0 0 0 1 0 0 0 0 OR, This is a binary operator (inclusive disjunction) which returns true iff at least one proposition is true: $p$ $q$ $p \lor q$ 1 1 1 1 0 1 0 1 1 0 0 0 XOR, This is a binary operator (exclusive disjunction) which returns true iff exactly one proposition is true: $p$ $q$ $p \oplus q$ 1 1 0 1 0 1 0 1 1 0 0 0 IMPLICATION, This is a binary operator which returns false only when $p$ is true and $q$ is false: $p$ $q$ $p \to q$ 1 1 1 1 0 0 0 1 1 0 0 1 Equivalent identity: $p \to q \equiv \lnot p \lor q$ BICONDITIONAL (IFF), This is a binary operator which returns true iff both propositions have the same truth value: $p$ $q$ $p \leftrightarrow q$ 1 1 1 1 0 0 0 1 0 0 0 1 Equivalent identity: $p \leftrightarrow q \equiv (p \to q) \land (q \to p)$ The following relations between conectives are true: Name Symbol Read as Semantics (under valuation v) Negation $\lnot p$ not $p$ $(\lnot p)_v = \neg (p)_v$ Conjunction $p \land q$ $p$ and $q$ $(p \land q)_v = (p)_v \wedge (q)_v$ Disjunction (inclusive) $p \lor q$ $p$ or $q$ $(p \lor q)_v = (p)_v \vee (q)_v$ Implication $p \to q$ if $p$ then $q$ $(p \to q)_v = \neg (p)_v \vee\ (q)_v$ Biconditional $p \leftrightarrow q$ $p$ iff $q$ $(p \leftrightarrow q)_v = (p \to q)_v\wedge(q \to p )_v$ Exclusive OR $p \oplus q$ either $p$ or $q$, not both $(p \oplus q)_v = (p \lor q)_v \wedge \neg(p \land q)_v$ Note that, from the formulas above, we can safely assume that every complex formula can be put in terms of Negation, Conjuntion and Disjunction connectives ($\neg, \wedge, \vee$). To demonstrate the equivalences of those expressions all we need is to compare the truth tables of each formula to validate it. This way, a boolean formula is a well-formed syntactic object, semantically empty. Meaning that it does not have a truth value by itself until a valuation is performed. The valuation (or interpretation) is the process in which every propostional variable involved with a boolean formula adquires a truth value. It is defined as an application. Being $X = \Set{x_1,...,x_n}\subset Var$, then a interpretation of that set is an application as: $$ a: X \to \Set{0,1}$$ Often, since the propositional variables can be ordered, we can define $a$ as a string of the $\Set{0,1}$ alphabet satisfying $\vert a\vert = \vert X\vert $. Then when we fix a valuation that maps each propositional variable to under a truth value, the formula evaluates to a unique truth value as well. Thus; the boolean formulas are sintactically well formed strings involving prepositional variables and conectives which are suitable for be valuable or interpreted. They serve to plasm the relation about elements or statements represented in the propositional variables. ## 2.3. Boolean formulas and Valuations. Now, consider an example of arbitrary formula. $x_i \in Var: i = 1,2,3,4$, then $out$ is a boolean formula such as: $$ out = (x_1 \vee \neg x_2 \vee \neg x_3)\ \wedge\ (\neg x_2 \vee x_3 \vee x_4)\ \wedge\ (x_1 \vee x_3 \vee \neg x_4)\ \wedge\ (\neg x_2 \vee \neg x_3 \vee \neg x_4) $$ Then, the question is, can we find values for $x_i: i = 1,2,3,4$ such makes $out$ true? This can be reformuled as, exists at least one *valuation* $a : \{x_1,x_2,x_3,x_4\} \rarr \{0,1\}$ which makes $out_{a} = 1$? Lets consider, $a_0 = 1010$, which means $ a_0(x_1) = 1, \ a_0(x_2) = 0, \ a_0(x_3) = 1, \ a_0(x_4) = 0 $, then: $$ (out)_{a_0} = (1 \vee \neg 0 \vee \neg 1)\ \wedge\ (\neg 0 \vee 1 \vee 0)\ \wedge\ (1 \vee 1 \vee \neg 0)\ \wedge\ (\neg 0 \vee \neg 1 \vee \neg 0) = \\ = 1\ \wedge\ 1\ \wedge\ 1\ \wedge\ 1 = 1 $$ Observe that, for we can consider the following problem $\Pi$. Being $\Sigma = \Set{Var} \bigcup \Set{\vee, \land, \neg }$: $$\Pi: \Sigma^* \to \Set{0,1}$$ $$\Pi (B) = 1 \iff \exists a : (B)_a = 1$$ In this context, $a_0=1010$ is a witness for $B = out$. Considering a $V \in DTM$ that accepts a boolean formula $B$ of $m$ connectives and a evalution $a$. $V$ operates connectives simplifying expressions and obtaining the truth value, then we call $V$ our verifier and it would be $V(out,a_0) = 1$. Observe, that if it is $\Beta$ a boolean formula that has $m$ conectives, then $V(\Beta,a)$ operates simplfying one connective per step so it needs $m$ steps before give the truth value of $(B)_a$, thus is $t_V(n) \in \mathcal{O{(n^1)}}$ and runs in polynomial time, so; $\Pi \in NP$. # 3. SAT is NP-complete: Cook-Levin Theorem. The reason why we introduce before the boolean formulas and demonstrate that the language of all the satisfiiable boolean formulas is an $NP$ language is because we are about to introduce a very important statement: **all problems in $P$ and $NP$ can be verified by transforming them into boolean formulas and showing a solution to the formula.** ## 3.1. SAT - Boolean Satisfiability Problem. $SAT$, also known as the Boolean satisfiability problem, asks whether there exists an interpretation that satisfies a given Boolean formula. What we provide above is a concrete case of a more extended language. Given an alphabet $\Sigma$ with all you need to create a boolean formula and consider as $\text{Form} \subset \Sigma^*$ all those strings which, as boolean formulas, are considered well-formed (in the behalf of simplity we will act as we all know what "well-formed" means so we don't have to provide a formal description about what $\text{Form}$ is). Then, we can define $SAT$ language as: $$SAT := \Set{B | \exists a : (B)_a = 1} \subset \text{Form}$$ ## 3.2. NP-completness. Reductions. **Reduction. Karp reduction.** Conceptually, a *reduction* is a way to translate one problem $A$ into another problem $B$ such that solving $B$ (on the translated input) automatically solves $A$. It gets formalized as a a function that preserves membership between reductable languages. - First, we consider the **Many-one reduction (mapping reduction)**. Being $A,B \subseteq \Sigma^*$, then we say that $A \text{ is many-one reductible to } B$: $$A \leq_m B \iff \exists f : \Sigma^* \to \Sigma^* : \forall x \in A \iff f(x) \in B$$ - Then, we define the karp reduction as a polynomial-time many-one reduction. This is, if a exists a total function computable by a turing machine running in polynomial time. $$A \leq_p B \iff \exists f : \Sigma^* \to \Sigma^* : \Big( x \in A \leftrightarrow f(x) \in B \ \land \ \exists M \in TM : \big( \ t_M \in \mathcal{O}(n^k) \land M(x)=f(x) \ \ \forall x \in A\big)\Big)$$ Note that the term $M(x)$ is non-standard but is a license to refer to the computation of $x$ by $M$. **NP-completness** $NP-complete$ problems are the hardest of the problems to which solutions can be verified quickly. A problem $L$ is $NP-complete$ when satisfies: - $L \in NP$ - $L$ is $NP-hard$, this means; every other problem in $NP$ can be reduced to it in polynomial time: $$ \forall H \in NP \ \ H \leq_p L$$ So NP-hard problems are “hard enough” (in complexity terms) to subsume the whole class NP via polynomial-time reductions. ## 3.3. SAT is NP-complete. Suppose you have two binary numbers $P,Q$ and you want to know if $P&gt;Q$. This can be formuled in terms of decision problem Until this point, we have now enough tools to understand what the statment "$SAT$ is $NP-complete$" means: It means that any other problem in NP can be reduced in terms of SAT, or said in other terms, any instance of an $NP$ problem can be translate as an instance of $SAT$, this way; verifying an input of a NP decision problem is equivalent to verify the satisfiability of one concrete boolean formula. Let's see a bunch of examples: # 4. Examples. ## 4.1. Checking if a list is sorted using a boolean formula. Consider $p,q \in \Set{0,1} \wedge 1 &gt; 0$ it is: $$p &gt; q \iff p \ \land \neg q$$ $$p=q \iff (p \land q) \vee \neg (p \vee q)$$ Essentially meaning that $p &gt; q$ only if is $p$ is true and $q$ false. We can quicly check this result by comparing the true table: | $p$ | $q$ | $p &gt; q$ | $p \land \neg q$ | $p = q$ | $(p \land q) \vee \neg (p \vee q)$ | |:---:|:---:|:-----:|:---:|:---:|:---:| | 0 | 0 | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 0 | 0 | 0 | | 1 | 0 | 1 | 1 | 0 | 0 | | 1 | 1 | 0 | 0 | 1 | 1 | If we consider $A \in \Set{0,1}^*$ then is: $A := a_1...a_n : a_i \in \Set{0,1} \forall i \leq n \in \mathbb{N}$ (although we are not force to it, we always consider finites strings in this case). Now, being $P,Q \in \Set{0,1}^*$ interpreted both as a representation in base 2 of a numeric value (a binary number, can safely assume that $\vert P\vert = \vert Q\vert = n$, if not, we add zeros to the shortest string until the equiality is meeted) then it is $$P &gt; Q \iff \exists i \leq n:p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i$$ Let's demonstrate the statement above. 1. First, in order to see it clearly, lets understand that a decimal representation from $A$ can be obtained as: $$A_{10} = a_0·2^{n-1} ... + a_n·2^{n-n} = \sum_{t = 1}^n a_t·2^{n-t}$$ In order to demonstrate the statement above, first demonstrate that: $$a_i · 2^{n-i} &gt; \sum_{t = i+1}^n a_t·2^{n-t} \ \ \forall i \leq n : a_i \neq 0$$ Observe that since is $a_j \in \Set{0,1} \ \forall j &gt; i$, we can reduce the demonstration applying two index changes and summatories properties to a geometric sum: $$2^{n-i} &gt; \sum_{t = i+1}^n 2^{n-t} \ \underbrace{\iff}_{h = n-i} \ 2^h &gt; \sum_{t=i+1}^{h+i}2^{h+i-t} \underbrace{\iff}_{k=0} 2^h &gt; \sum_{k=0}^{h+i - (i+1)}2^{h+i-(k+i+1) } \iff 2^h &gt; \sum_{k=0}^{h-1} 2^{h-1 - k} = \sum_{k=0}^{h-1} 2^{k}$$ which is a well known result: $$S=\sum_{t=0}^{h-1}2^{t},\qquad 2S=\sum_{t=1}^{h}2^{t},\qquad 2S-S=2^{h}-1\ \Rightarrow\ S=2^{h}-1$$ 2. Reverse Implication: $\exists i \leq n:p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i \implies P &gt; Q$ Let's take $P_{10}$ and $Q_{10}$: $$P_{10} - Q_{10} = \sum_{t = 1}^n p_t·2^{n-t} - \sum_{t = 1}^n q_t·2^{n-t} =$$ $$= \sum_{t = 1}^i p_t·2^{n-t} - \sum_{t = 1}^i q_t·2^{n-t} + \sum_{t = i+1}^n p_t·2^{n-t} - \sum_{t = i+1}^n q_t·2^{n-t} $$ Since $p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i$, the above is: $$P_{10} - Q_{10} = p_i · 2^{n-i} + \sum_{t = i+1}^n p_t·2^{n-t} - \sum_{t = i+1}^n q_t·2^{n-t}$$ And, since $p_i,q_i \in \Set{0,1}$, due to **(1)** is: $$p_i · 2^{n-i} - \sum_{t = i+1}^n q_t·2^{n-t} &gt; 0 \ \Rightarrow \ P_{10} - Q_{10} &gt; 0$$ 3. Direct Implication: $ P &gt; Q \implies \exists i \leq n:p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i$, observe that: $$ P &gt; Q \iff P_{10} &gt; Q_{10} \iff \sum_{t = 1}^n p_t·2^{n-t} &gt; \sum_{t = 1}^n q_t·2^{n-t}$$ Then, let's assume that the implicated statement is not true and see that it triggers a contradiction: $$\neg(\exists i \leq n:p_i &gt; q_i \ \land \ p_j = q_j \ \forall j &lt; i) \iff \neg (p_i &gt; q_i) \ \ \forall i \leq n \ \vee \ \exists j &lt; i : \neg(p_j = q_j)$$ Let's observe that: - $\neg(p_i &gt; q_i) \iff (q_i &gt; p_i) \vee (p_i = q_i)$ $$(q &gt; p) \vee (p = q) \iff (q \land \neg p) \vee (p \land q) \vee \neg (p \vee q) \equiv q \land \cancel{(\neg p \vee p)}_\top \vee (\neg p \land \neg q) \equiv$$ $$\equiv (q \vee \neg p) \land \cancel{(q \vee \neg q)}_{\top} \equiv \neg(p \land \neg q) \iff \neg(p &gt; q)$$ - $\neg(p_j = q_j) \iff (p_i &gt; q_i) \vee (q_i &gt; p_i):$ $$\neg(p= q) \iff \neg[(p \land q) \vee \neg (p \vee q)] \equiv \neg(p \land q) \land (p \vee q) \equiv (\neg p \vee \neg q) \land (p \vee q) \equiv$$ $$\equiv [(\neg p \vee \neg q) \land p] \vee [(\neg p \vee \neg q) \land q] \equiv [\cancel{(\neg p \land p)}_\bot \vee (\neg q \land p)] \vee [(\neg p \land q) \vee \cancel{(\neg q \land q)}_\bot] \equiv$$ $$\equiv (p \land \neg q) \vee (q \land \neg p) \iff (p &gt; q) \vee (q &gt; p)$$ Thus, we have two ways to negate the premise: - First, we have the trivial cases: $$\forall i \leq n : \begin{cases} \ q_i &gt; p_i \\ \ p_i,q_i \in \Set{0,1} \end{cases} \implies p_i = 0 \land q_i =1 \ \ \forall i\leq n \implies Q_{10} &gt; P_{10}$$ $$\forall i \leq n : p_i = q_i \iff Q_{10} = P_{10}$$ - Then, we consider the second version: $$\exists i : p_i &gt; q_i \ \land \ \exists j&lt;i : p_j \neq q_j \Rightarrow \begin{cases} p_j &gt; q_j \\ q_j &gt; p_j \end{cases}$$ If $p_j &gt; q_j$ then we make i = j and reevaluate, then, we can safely assume that is $q_j &gt; p_j \ \land \ \neg \exists m &lt; j : p_m &gt; q_m $. Thus: $$Q_{10} - P_{10} = \sum_{t = 1}^j q_t·2^{n-t} - \sum_{t = 1}^j p_t·2^{n-t} + \sum_{t = j+1}^n q_t·2^{n-t} - \sum_{t = j+1}^n p_t·2^{n-t} = $$ $$ \sum_{t = j+1}^n q_t·2^{n-t} + q_j·2^{n-j} - \sum_{t = j+1}^n p_t·2^{n-t} - \cancel{p_j·2^{n-j}}_0 + \sum_{t = 1}^{j-1} q_t·2^{n-t} - \sum_{t = 1}^{j-1} p_t·2^{n-t} &gt; 0 $$ Let's observe that there are two differences but both of them are greater than $0$, the first one starting from the left is due to the result we demonstrate above along with the fact that $p_i,q_i \in \Set{0,1} \forall i \leq n$, the second one is due to the premise: $\neg \exists m &lt; j : p_m &gt; q_m $ This essentially justifies the existence of an algorithm that for $P,Q \in \Set{0,1}^*$ goes checking $p_i, q_i : i \leq n \in \mathbb{N}$ and accepts the input considering that for the first $i: p_i &gt; q_i \Rightarrow P &gt; Q$, if this condition is not meet, the algorithm rejects and is $\neg (P &gt; Q)$. ``` P1 = 1001 =&gt; ACCEPTS =&gt; p_4 &gt; q_4 =&gt; P &gt; Q Q1 = 1000 P2 = 1001 =&gt; REJECTS =&gt; P = Q Q2 = 1001 ``` Let's observe that the solution to this problem (the procedure of the algorithm) can model as a bolean formula: $$p_1 &gt; q_1 \vee (p_1 = q_1 \land p_2 &gt; q_2) \vee (p_1 = q_1 \land p_2 = q_2 \land p_3 &gt; q_3) ...$$ Which is similar to: $$\bigvee_{i=1}^{|P|} \Big[\bigwedge_{j=1}^{i -1} [p_j = q_j] \land (p_i &gt; q_i)\Big] \iff \bigvee_{i=1}^{|P|} \Big[\bigwedge_{j=1}^{i -1} \big[(p_j \land q_j) \vee \neg(p_j \vee q_j)\big] \land \big(p_i \land \neg q_i\big)\Big]$$ Lets observe that in the case $i=1$ results in an "empty conjunction" and an "empty disjunction", which by convention is: $$ \bigwedge_{j=1}^{1-1} p_j = q_j \iff \bigwedge_{j=1}^{0} (p_j \land q_j) \vee \neg(p_j \vee q_j) \iff \top \vee \neg \bot \equiv \top$$ Now, let's consider $\Pi_Q : Q \in \Set{0.1}^*$ the decision problemd defined as: $L_{\Pi_Q} := \Set{P \vert P &gt;Q}$. Then the boolean formula we just crafted above models the problem in the sense that, for any $x \in \Set{0,1}^*$: $$x \in L \iff (B_x)_x = \Bigg( \bigvee_{i=1}^{|x|} \Big[\bigwedge_{j=1}^{i -1} [x_j = q_j] \land (x_i &gt; q_i)\Big] \Bigg)_x= \top$$ Thus we define: $$f: \Set{0,1}^* \to \Sigma^*_{SAT}$$ $$ f(x) := B_x $$ This function satisfies the requisites of the karp reduction - $f$ is polynomically computable since we can define $V \in DTM$ that computes $(B)_x$ in polynomial time as we see above. - $f$ preserves ownership between $L$ and $SAT$, $x \in L \iff f(x) = B_x \in SAT$. So is $L_{\Pi_Q} \leq_p SAT$. Observe that in this case, despite we showed that we can verify a solution to a problem verifying a solution to a trivial formula, there is no witness. This is because this is a P problem, and in this specific case $V$ that computes $(B)_x$ is also de decider of $L$ so no aid is needed. This does not mean that there are $P$ in problems that admits verificators that needs witness as well. ## 4.2. Map-coloring problem: Graph theory. There is a problem knew as the *map-coloring problem*, which ask about for how many colors do you need (in the sense of minimum required) to color a map. The canonical result is the *Four Color Theorem*, which states that any planar map can be colored with at most four colors so that adjacent regions differ. The Four Color Theorem has 3-color variant, known as the 3-colorability problem which asks what maps admits being colored with no more than 3 colors. All this problematic is presented and understanded in the terminology of *Graph Theory*; which is the discipline of mathematics which occupies about the study of discrete relation's structures and his properties. ### 4.2.1. Introduction to Graph Theory. #### 4.2.1.1. Graphs and Subgraphs. Vertices and Edges. Neighborhood. We call as a **graph** to the pair $G := (V,E)$ where: - $V$ is a finite non-empty set whose elements are called *vertices*. - $E \subseteq \binom{V}{2}$ and his elements are called *edges*. As a brief apex, it is: $$ \binom{V}{2} := \Set{\Set{u,v} \subseteq V : u \neq v} $$ Where $\Set{u,v}$ is a not-ordered set (in contrast with $(u,v)$). Then, we have the following definitions: - If $\Set{u,v} \in E$, then $u,v \in V$ are say to be **adjacents**. - For $v \in V$, $N(v) := \Set{u \vert \Set{u,v} \in E} \subseteq V$ is the **neighborhood of $v$**, and $\vert N(v)\vert $ is called his **degree**. In general, is not safe to assume that $\vert N(v)\vert \geq 1 \ \forall v \in V$. We call $Iso(G) := \Set{v \in V : \vert N(v)\vert = 0}$ and the following relation can be verified: $$V = \bigcup_{v \in V} N(v) \cup Iso(G)$$ For a graph $G := (V,E)$: - A **subgraph** of $G$ is any set: $$H := (V_H, E_H) : V_H \subseteq V \land E_H \subseteq E \ \cap \ \binom{V_H}{2}$$ - An **induced subgraph** on $W \subseteq V$: $$G[W] := (W, E \cap \binom{W}{2})$$ - A **walk** is a finite sequence of adjacent vertices: $$v_0...,v_t:\Set{v_{i-1},v_i} \in E \ \ \forall i \leq t \in \mathbb{N}$$ - A **path** is a walk with all the vertices distinct: $$v_0...,v_t:\Set{v_{i-1},v_i} \in E \land v_i \neq v_j \ \ \forall i,j \in \mathbb{N}$$ - A **cycle** is a walk $v_0,...,v_{t-1},v_0$ where $v_0,...,v_{t-1}$ is a path. - A **complete** graph $G$ is a graph where every pair of vertices are connected by an edge: $$G := (V,E) : E = \binom{V}{2}$$ Observe that this means that $\vert N(v)\vert = \vert V\vert - 1$. Going back to isolated vertices, we say that $$G \text{ is connected } \iff \forall u,v \in V \ \exists \text{ a path}: u,w_1...,w_{t-1},v $$ #### 4.2.1.2. Graph coloring. Being, $G := (V,E)$, then a $k\text{-coloring}$ of $G$ is an application: $$c : V \to \Set{1,...,k} : \forall \Set{u,v} \in E \ \ c(u) \neq c(v)$$ For $G$, we define his **chromatic number** as the minimum number for which exists a coloration: $$\chi(G) := min\Set{k | \exists c : V \to \Set{1,...,k} \text{ is a } k\text{-coloring}}$$ Observe that this means that the Four Colour theorem exposes $\chi(G) \leq 4 \ \ \forall G$ and the 3-coloring problem ask whether, $\chi(G) \leq 3$. Let's observe that: 1. For a complete graph $K_n$ (where $\vert V_K\vert = n$), is: $\chi(K_n) = n$. - First, let's see that $c : V_K \to \Set{1,...,n}$ is *injective* ($\vert V_K\vert = \vert \Set{1,...,n}\vert $) and it verifies: $$\forall u,v \in V_K : u \neq v \implies c(u) \neq c(v)$$ Also, since $K_n$ is a complete graph, $\forall u,v \in V_K : u \neq v \iff \Set{u,v} \in E_K$, thus: $$\forall \Set{u,v} \in E_K \ \ c(u) \neq c(v)$$ And $c$ is a coloration. - Let's see now that $\neg (\exists i &lt; n : c : V_K \to \Set{1,...,i} \text{ is a coloration})$. Simply, considering $c : V_K \to \Set{1,...,i}$ with $ i &lt; n$, then $c$ is *no injective* and it verifies the *pigeonhole principle*: $$\exists u,v \in V_K : u \neq v \land c(u) = c(v)$$ Again, for $\forall u,v \in K_n \ \ u \neq v \iff \Set{u,v} \in E_K$ and thus: $$\exists \Set{u,v} \in E_K : c(u) = c(v)$$ And $c$ is no coloration. 2. For a cycle $C_n$, $\chi(C_n) = 2$ if $n$ is even and $\chi(C_n) = 3$ if $n$ is odd. First, let's define what a cycle graph is: $$C_n := (V_C, E_C) : \begin{cases} V_C = \Set{v_0,...,v_{n-1}} \\ E_C = \Set{\Set{v_{i-1},v_i} : i \in \Set{1,...,n-1}} \cup \Set{\Set{v_{n-1},v_0}} \end{cases}$$ Let's observe that, as defined, the sequence: $v_0,...,v_{n-1}$ is a path, thus $v_0,...,v_{n-1},v_0$ is a cycle. - Now, consider the case $\exists m : n = 2m$, then, we define: $$c : V_C \to \Set{1,2} : c(v_i) = \begin{cases} 1 \ \text{ if } i \text{ is even}\\ 2 \ \text{ if } i \text{ is odd} \end{cases}$$ It is clear that even and odd numbers alternates each in a consecutive numeric sequence. So: $$c(v_{i-1}) \neq c(v_i) \ \ \forall v_{i-1},v_i \in v_0,...,v_{n-1} \implies c(v_{i-1}) \neq c(v_i) \ \ \forall \Set{v_{i-1},v_i} \in E_C $$ For the same reason, if $n$ is even, then $n-1$ is odd and $c(v_{n-1}) \neq c(v_0)$, thus, in conclusion: $$c(u) \neq c(v) \ \ \forall \Set{u,v} \in E_C$$ And $c$ is a $2-coloring$ of $C_n$. Obviously since $E_C \neq \varnothing$ it can't be $\chi(C_n) = 1$. - If $n = 2m + 1$ and we suppose the existence of a $2-coloring$, $c$ over $C_n$, then: $$c(u) \neq c(v) \ \ \forall \Set{u,v} \in E_C \implies c(v_{i-1}) \neq c(v_i) \ \ \forall \Set{v_{i-1},v_i} \in E_C \iff$$ $$ \iff c(v_{i-1}) \neq c(v_i) \ \ \forall v_{i-1},v_i \in v_0,...,v_{n-1}$$ Or, in other words, any consecutive vertex in the path $v_0,...,v_{n-1}$ has different image under $c$. Thus, is easy to see that: - Since in a $2-coloring$ there are only two possible images values - And $n-1$ is even (because $n$ is odd), Then $v_0$ and $v_{n-1}$ share the same image under $c$ and it is: $$c(v_{n-1}) = c(v_0) \land \Set{v_{n-1},v_0} \in E_C$$ Triggering a contradiction with the $2-coloring$ requirement. Getting the example of $c$ provided above, is easy to see that: $$c : V_c \to \Set{1,2,3} : c(v_i) = \begin{cases} 1 \ \text{ if } i \text{ is even } \land i \neq n -1\\ 2 \ \text{ if } i \text{ is odd} \\ 3 \end{cases}$$ Is a $3-coloring$ of $C_n$. 3. **Bipartite Graphs**. A bipartite graph is a graph $G_B$ satisfying: $$G_B := (V_B,E_B): \begin{cases}V_B := A \sqcup B \ \ (V = A\cup B \land A \cap B = \varnothing) \\ E_B \subset \binom{V_B}{2} : a \in A \land b \in B \ \ \forall \Set{a,b} \in E_B \end{cases}$$ Then, consider $$c : V_B \to \Set{1,2} : c(v) =\begin{cases} 1 \ \ \text{ if } v \in A\\ 2 \ \ \text{ if } v \in B \end{cases}$$ Then: $$\forall \Set{u,v} \in E_B \ \ \begin{cases} u \in A \Rightarrow c(u) = 1 \\ v \in B \Rightarrow c(v) = 2 \end{cases} \implies c(u) \neq c(v)$$ And $c$ is a $2-coloring$ of $G_B$. Of course, $E_B \neq \varnothing \implies \chi(G_B) \neq 1$. 4. **2-colorability theorem**. The 2-colorability caracterization stands for, being $G := (V,E)$ a graph, then: $$\chi(G)=2 \iff G \text{ is bipartite } \iff \neg \exists\,\text{cycle } C \subseteq G : |C|\ \text{ is odd} $$ Observe that we already demonstrate that: - $G \text{ is bipartite } \implies \chi(G)=2$ - $\chi(G)=2 \implies \neg \exists\,\text{cycle } C \subseteq G : \vert C\vert \ \text{ is odd}$ (since all odd cycle has a 3 as a chromatic number). - $\chi(G)=2 \implies G \text{ is bipartite }$ Observe that $$\chi(G)=2 \implies \exists c :V \to \Set{1,2} : c(u) \neq c(v) \ \ \forall \set{u,v} \in E$$ We define: $$\begin{cases}A := \Set{u \in V | c(u) = 1} \\ B:= \Set{u \in V | c(u) = 2}\end{cases}$$ In this context, since $c$ is an application we have: - $v \in V \Rightarrow c(v) = 1 \vee c(v) =2 \Leftrightarrow v \in A \vee v \in B \Rightarrow V = A \cup B$ - $A \cap B = \varnothing$ - $\forall \Set{u,v} \in E \implies c(u) \neq c(v) \implies (u \in A \land v \in B) \vee (v \in A \land u \in B)$ Thus, $G$ verifies: $$\begin{cases}V := A \sqcup B \ \ (V = A\cup B \land A \cap B = \varnothing) \\ E \subset \binom{V}{2} : a \in A \land b \in B \ \ \forall \Set{a,b} \in E \end{cases}$$ Now, only last to demonstrate that: - $\neg \exists\,\text{cycle } C \subseteq G : \vert C\vert \ \text{ is odd} \implies G$ is bipartite. The premise can be negated in two ways: - First, $\neg \exists C \subseteq G : C \text{ is a cycle}$, then consider a vertex we call $r$ and: $A = \Set{u \vert dist(r,u) \text{ is even}}$ and $B = \Set{u \vert dist(r,u) \text{ is odd}}$. Then is pretty obvius that $A \cup B$ and we impose that $A \cap B = \varnothing$, let's observe that this impossition requires no odd cycles. Being $C \subseteq G : C \text{ is odd}$, then, $C:=v_0,...,v_{n-1},v_0$ where $v_0,...,v_{n-1}$ is a path and $\Set{v_{n-1},v_0} \in E$. Lets say $r : dist(r,v_0) \land r \notin C$. Then, since $C$ is a cycle there are two paths to measure the distance between $r$ and $v_{n-1}$: $$dist(r,v_{n-1}) = dist(r,v_0) + dist(v_0,v_{n-1})$$ Since $\Set{v_{n-1},v_0} \in E \Rightarrow dist(v_0,v_{n-1}) = 1 \Rightarrow dist(r,v_{n-1}) = 2 \text{ (even)}$, but also, since $C$ is odd, $n-1$ is even (meaning that $dist(v_0,v_{n-1})$ is even and $1 + dist(v_0,v_{n-1}) = dist(r,v_{n-1})$ is odd). So in summary: $A \cap B \neq \varnothing$ #### 4.2.1.3. Plannar graphs. Drawings and faces. Euler's formula. A *planar graph* is a graph that admits a graphical representation on a plane such its edges do not cross each other. For example, Complete graph $K_3$ do admit a representation in which the edges not cross, but $K_5$ do not. Let be $G:=(V,E)$ a finite simple graph, then an embedding of $G$ into $\mathbb{R}^2$ is a function $\phi: G \to \mathbb{R}^2$ that: - $\forall u,v \in V \ \ \left(\phi(u), \phi(v) \in \mathbb{R}^2 \land u \neq v \implies \phi(u) \neq \phi(v) \right)$ - $\forall e, f \in E \ \ \left( \phi(e) = \gamma_{e_1e_2}, \phi(f) = \gamma_{f_1f_2} \in \mathbb{R}^2 : e \neq f \implies \phi(e) \cap \phi(f) \subseteq \Set{\phi(e_1),\phi(e_2),\phi(f_1),\phi(f_2)} \right)$ Where $\gamma_{uv}$ is a simple arc (non-self-intersecting, continuous curve) from $\phi(u)$ to $\phi(v)$. $\phi$ maps the edges of $G$ ensuring that two different arcs only share endpoints as much. Then, $G$ is said to be planar if admits a embedding $\phi$ in $\mathbb{R}^2$ as above. Associated to a drawing of a planar graph are the so called *faces*, grouped in the set $F$; which are enclosed regions of the plane $\mathbb{R}^2$ by the planar drawing of the graph (here is included the unbound outer face extranl to the graph). The Euler's formula specifies that, for a complete planar graph $G:= (V,E)$, being $F$ the set of the faces of the drawing graph, then: $$|V| - |E| + |F| = 2$$ #### 4.2.1.4. Dual graphs. Given a connected planar graph $G$, then, the *dual graph* is what you get when you turn faces into vertices in a planar embedding of $G$. The drawing (planar embedding) cuts the plane into regions (faces), one unbounded “outside” face plus the bounded ones, then the dual $G^*$ is built by: - Putting one vertex inside each face of $G$. - For each $e \in E$ there exists one $e^* \in E^*$ crossing once $e$, connecting two faces. Formally; Being $G$ a connected planar graph and $\phi$ his drawing in $\mathbb{R}^2$. Then, we define the dual graph $G^*:= (V^*,E^*)$: $$\begin{align}V^* &amp;:= F = \Set{f : f \text{ is a face of }(G,\phi)} \\ E^* &amp;:= \Set{\Set{f_1,f_2} | \exists e \in E \text{ between } f_1 \text{ and } f_2 } \subseteq \binom{V^*}{2}\end{align}$$ Is important to understand that *Dual depends on the embedding*: Two different planar drawings of the same abstract planar graph can produce non-isomorphic duals. The dual is canonical only after you fix the embedding. In this context, a map coloring is equal to color a dual graph. A map representation is in fact a dual graph. ### 4.2.2. Formuling the problems. Three-coloring problem. #### 4.2.2.1. Describing the problem. With the notion we have gathered, then, the Four Color Theorem (the “all maps” statement), states that, for every planar graph $G$, the chromatic number is as much 4 $\chi(G) \leq 4$. It only required four colour to color every planar map. How ever, for example $\chi(K_4)=4$, so three colors is not always sufficent. And we can formulate the problem as the language: $$L := \Set{G | \chi(G)\leq 3}$$ How ever, in this terms, $G$ still a graph and not a string codificaction of a graph and it isn't a computable decision problem. #### 4.2.2.2. Graph Encoding. **Matrix reduction** Given a finite simple undirected graph $G :=(V,E) : \vert V\vert = d \in \mathbb{N}$, then consider the following elements: - Being $[d] := \Set{1,...,d} \subset \mathbb{N}$ the function $T$ such: $$T: V \to [d] : \Big(u \neq v \Rightarrow T(u) \neq T(v) \Big)\ \ \ \forall v,u \in V$$ Meaning that any vertex is mapped to a distinct natural number between $1$ and $\vert V\vert $. Observe that $T$ is bijective (our imposed condition makes it injective and since both domain and codomain have the same cardinal; from the injectivity we obtain the surjectivity and thus the bijectivity) and we can consider its inverse $T^{-1}$. - The function $T'$ such: $$\begin{align}T'&amp;: \binom{T(V)}{2} \to \Set{0,1} \\ T'(\Set{n,m}) &amp;= \begin{cases} \ 1 \ \ \ \Set{T^{-1}(n),T^{-1}(m)} \in E \\ \ 0 \ \ \ \Set{T^{-1}(n),T^{-1}(m)} \notin E\end{cases}\end{align}$$ We define $T'(E):=\Set{\Set{n,m} \vert T'(\Set{n,m}) = 1 } \subseteq \binom{T(V)}{2}$ - The matrix: $$M_{d} := (a_{ij})_{i,j \in T(V)} : a_{ij} = \begin{cases} \ 1 \ \ \ \Set{i,j} \in T'(E) \\ \ 0 \ \ \ \Set{i,j} \notin T'(E)\end{cases}$$ This is called the *edge matrix*, and it stores the edges of $G$ in form of entries up to one. Since this is a simmetric matrix, we end defining his upper part to evade redundances: $$M^+_{d} := (a^+_{ij})_{i,j \in T(V)} : a_{ij}^+ = \begin{cases} \ \ a_{ij} \ \ \ i &lt; j \\ \ \ 0 \ \ \ \ \ \ i \geq j\end{cases}$$ In this context, we can reduce $G$ to $M^+_{d}$ in the sense that $M^+_d$ has all the necesary information to craft an equivalent graph $G_T$ of $G$: $$M^+_d \to G_T \ := ([d], E_T) :E_T = \Set{\Set{i,j}:a^+_{ij} = 1 \land i &lt; j}$$ **Matrix Encoding** Let be $M_n := (a_{ij})_{i,j \in [n]}$, then, we can reorganize the $a_{ij}$ elements by following rows: $$\langle M_n \rangle : = (a_{11}...,a_{1n},a_{21},...,a_{nn}) = (\alpha_s)_{s \in [n^2]} : a_{ij} = \alpha_{n·(i-1) + j}$$ Let's see how to reconstruct $M_n$ from the sequence $(\alpha_s)_{s \in [n^2]}$. Let's think that in $M_n$, each row is a group of $n$ elements and each colum is a number between $1$ and $n$, thus the euclidian division fits well giving us as a final result: $$(\alpha_s)_{s \in [n^2]} \to (a_{ij})_{i,j \in [n]}: \begin{cases} i =\left\lfloor \frac{s-1}{n}\right\rfloor +1 \\ j = ((s-1) \text{mod } n) +1 \end{cases}$$ Observe that each row of $M_n$ is a set of $n$ elements, thus is in our interest to decompose any index $\alpha_m$ in terms of $n$ through the Euclid Division theorem. Being $$\alpha_m \in (\alpha_s)_{s \in [n^2]} \implies \exists p,q \in \mathbb{N} : m = np + q \land 0 \leq q &lt; n$$ Observe that this expression is telling us two things: 1. $p$ tell us how many times is $m$ contained in $n$. This is related with how many rows $\alpha_m$ is down as $a_{ij}$ on $M_n$. 2. $q$ how much is left over to $m$ to be a $n$-multiple. This is related with how many columns has left to the left $\alpha_m$ as $a_{ij}$ on $M_n$. Both of them are related to the position of $\alpha_m$ as $a_{ij} \in M_n$ but not in a straight way. Specifically, this equation has two problems: - First, $q$ adjusts just fine to the colum place $j$ in the sense that correctly defines the position $p·n \leq m \leq (p + 1)·n$ but $q$ do not exists in an interval compatible with $j$, since $q \in [0,n-1] \cap \mathbb{N}$ and $j \in [n]$. Thus, we have to find a similar expression of the euclid division between $m$ and $n$ that fits $q$ in the correct set of values: $$m = np + q : 0 \leq q &lt; n \iff m-1 = np+ (q-1) : 0 \leq q-1 &lt; n \implies q\in [n]$$ This expresion correctly defines $q$ in a compatible way with $j$. Clearing $q$ we obtain: $$j = q = ((m-1)\text{mod } n) +1$$ - Now, we have a similar problem with the rows. As we said above, the expression tells us the number of times that $n$ fits on $m$. Traduced to $M_n$ if $p=0 \implies i=1, p = 1 \implies i = 2$, and so on. Thus, $i = p + 1$, again clearing we have: $$i = p + 1 = \left\lfloor \frac{m-1}{n}\right\rfloor +1$$ Where $\left\lfloor \frac{a}{b}\right\rfloor$, denotes the entire divison of $a$ between $b$. Note that, to obtain $i$ we did not cleared from $m = p·n + q$ but from $m-1 = p·n + (q-1)$, since the last accurately identifies $j \leftrightarrow q$, in the first expression this do not happen and thus there are unaccuracies from some edgy cases like for example $m$ being multiple of $n$. #### 4.2.2.3. Forming the problem. **Conceptual definition** Given a $G:=(V,E)$ and a function $c:V \to \Set{1,2,3}$, then if: $$\forall \Set{u,v} \in E, \ c(u) \neq c(v) \iff c \text{ is a coloration on G} \implies \chi(G) \leq 3$$ This essentially means that, conceptually, we can ensure that $\chi(G) \leq 3$ if the function $c$ defined as above is indeed a coloration by checking that there are no neighbours vertex with the same color. **Formalizing the language** Given the alphabet $\Sigma = \Set{0,1}$, then we just see above that any graph $G:=(V,E):\vert V \vert = n$ can be reduced to a square matrix $M^+_n$ and then to a string of $(\alpha_s)_{s\in[n^2]} \in \Sigma^*$. Now, lets define: $$c_T: [n] \to \Set{\alpha, \beta, \gamma} : c_T(i) = \begin{cases}\alpha \ \ \ \ c(u) = 1 \\ \beta \ \ \ \ c(u) = 2 \\ \gamma \ \ \ \ c(u) = 3 \end{cases} \ \ \land \ \ u = T^{-1}(i) $$ Observe that as defined; $c$ is a coloration on $G:=(V,E)$ iff $c_T$ is a coloration of $G_T:=([d],E_T)$, since: $$c(u) \neq c(v) \ \ \forall \Set{u,v} \in E \iff c_T(i) \neq c_T(j) \ \ \forall \Set{i,j} \in E_T$$ Thus, applying $c_T$ to the sucession $(\alpha_s)_{s\in[n^2]}$ and $i,j$ translation. The language to decide is: $$L = \Set{(\alpha_s)_{s\in[n^2]} | \exists c_T : [n] \to \Set{\alpha, \beta, \gamma}: c_T\left(\left\lfloor \frac{s-1}{n}\right\rfloor +1\right) \neq c_T\left(((s-1) \text{mod } n) +1\right) \ \ \forall s : \alpha_s=1}$$ #### 4.2.2.4. Verifying L. In this terms, we can think in a verifier that admits a sucesion and a function as described above $V((\alpha_s)_{s\in[n^2]} ,c_T)$ and goes iterating over each term of the sequence $\alpha_s$ performing: 0. $\begin{cases} s \leq n(n-1) \to (1) \land \alpha_s (q_1) \\ s&gt; n(n-1) \to \text{ACCEPT STATE}\end{cases}$ 1. $\begin{cases} \alpha_s = 1 \to (2) \land \alpha_s \\ \alpha_s = 0 \to (0) \land \alpha_{s+1}\end{cases}$ 2. $\begin{cases} c_T\left(\left\lfloor \frac{s-1}{n}\right\rfloor +1\right) = c_T\left(((s-1)\mod n) +1\right) \to \text{ REJECT STATE } \\ c_T\left(\left\lfloor \frac{s-1}{n}\right\rfloor +1\right) \neq c_T\left(((s-1)\mod n) +1\right) \to (0) \land \alpha_{s+1}\end{cases}$ Let's observe that calling each step $p^s_i,q^s_i$ for the term $s$ of the sequence from $i=0,1,2$, a non-rejected path for the term $\alpha_s \in (\alpha_s)_{s\in[n^2]}$ by $V$ can be described as: $$q^s_0 \vee (p^s_0 \land (q^s_1 \vee (p^s_1 \land q^s_2)))$$ Thus, for the $n(n-1)$ terms (observe that from the sequence we are eliminating those that correspond to the last row of $M_d^+$ which is zeroed) the complete accept path of $V((\alpha_s)_{s\in[n^2]},c_T)$ is: $$\bigwedge_{s=0}^{n(n-1)} \left[q^s_0 \vee (p^s_0 \land (q^s_1 \vee (p^s_1 \land q^s_2)))\right]$$ Meaning that for each term, check if it is $1$ or $0$ and if it is $1$, then compares through $c_T$. By SAT, verifying and input of $L$ is equivalent to find a valuation to that expression that makes it true. # 5. Conclusion. As a summary, in this section we see what boolean formulas are and the NP's SAT problem, which ask wheter a boolean formula have a valuation making it true. We also see that SAT is NP-complete, meaning that is hard enough (in complexity terms) to polynomially reduce any other NP problem to SAT which eventually decays on the following corolary: any NP problem instance can be verified by verifying a SAT instance, this is; a correct valuation to a boolean formula that models the problem.]]></summary></entry><entry><title type="html">Race Conditions.</title><link href="http://localhost:4000/posts/2025/12/28/RaceCondition/" rel="alternate" type="text/html" title="Race Conditions." /><published>2025-12-28T10:00:00+01:00</published><updated>2025-12-28T10:00:00+01:00</updated><id>http://localhost:4000/posts/2025/12/28/RaceCondition</id><content type="html" xml:base="http://localhost:4000/posts/2025/12/28/RaceCondition/"><![CDATA[<h3 id="1-definition">1. Definition.</h3>

<h4 id="11-race-condition-definition">1.1. Race Condition definition.</h4>

<p><em>Race Condition</em> is a term than refers to a set of bugs which arises when the behavior of a system depends on the relative timing or ordering of events, and that timing isn't properly controlled. The "race" is between two or more operations that need to happen in a specific order to produce correct results, but the system fails in guaranteeing that order.</p>

<p>A race condition emerges from a gap between checking a condition and acting on it. During that window—however brief—the state can change, invalidating the assumption your code just made.</p>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">file_exists</span><span class="p">(</span><span class="s">"/tmp/data"</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Window of vulnerability here</span>
    <span class="n">open_and_read</span><span class="p">(</span><span class="s">"/tmp/data"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the gap between checking and opening the file, some other process can interfere with it as a shared object.</p>

<p>We difference between two types of races condition in this course:</p>

<ul>
  <li><strong>TOCTOU (Time-of-Check to Time-of-Use)</strong> — the example above. You check something, then use it, assuming the check remains valid.</li>
  <li><strong>Double Fetch</strong> — A double fetch occurs when kernel code reads the same user-space memory location twice, assuming the value remains constant between reads. Since user-space memory is under attacker control, a malicious thread can modify the value between the two fetches, breaking the kernel's assumptions.</li>
</ul>

<p>The following diagram shows the TOCTOU race condition in-detail:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        PROCESS 1 (Victim)                    SHARED                   PROCESS 2 (Attacker)
              │                               RESOURCE (file)                 │
    Time      │                                  │                            │
      │       │                                  │                            │
      │       │  ┌─────────┐                     │                            │
      │       │  │ Verify()│                     │                            │
      │       │  │  Read ──────────────────────► │                            │
      │       │  └─────────┘                     │                            │
      │       │                                  │                            │
      │       │                                  |                            |
      │       │                                  │                            │
      │       │                                  │                            │
      │       │                                  |                            │
      │       │                                  |                            │
      │       │                                  |                            │
      │       │                                  │          Write             │
      │       │                                  │   ◄───────────────────     │
      │       │                                  │   (Attacker changes        │
      │       │                                  │    the resource)           │
      │       │                                  │                            │
      │       │              Write               │                            │ 
      │       │    ◄─────────────────────────    │  (Now operates on          │
      │       │                                  │   attacker-controlled      │
      │       │                                  │   resource!)               │
      │       │                                  │                            │
      │       │   TIME OF USE                    │                            │
      ▼       ▼                                  ▼                            ▼
</code></pre></div></div>

<p>If is well compassed, the writter can change the resource between the check and the use.</p>

<p><br /></p>

<h3 id="2-exercises">2. Exercises.</h3>

<h4 id="21-cve-2021-4207">2.1. CVE-2021-4207.</h4>

<p>QEMU is an emulation and virtualization system. In the context of this bug, it's being used as a virtualization system, specifically via the use of the paravirtualized framebuffer video accelerator device, QXL. Paravirtualization is when you don't run an unmodified OS within the hypervisor, but instead run a modified one, that is aware of the hypervisor, and takes actions to make virtualization easier.</p>

<p>In the context of this attack, the guest VM is the attacker, and the QEMU hypervisor is the target. The attacker wants to break out of the virtualization, and gain code execution on the enclosing host, by exploiting a vulnerability in QEMU.</p>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QEMUCursor</span> <span class="o">*</span><span class="nf">cursor_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">QEMUCursor</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">datasize</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QEMUCursor</span><span class="p">)</span> <span class="o">+</span> <span class="n">datasize</span><span class="p">);</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">qxl_unpack_chunks</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">PCIQXLDevice</span> <span class="o">*</span><span class="n">qxl</span><span class="p">,</span> <span class="n">QXLDataChunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">group_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">max_chunks</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">bytes</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">qxl_phys2virt</span><span class="p">(</span><span class="n">qxl</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">next_chunk</span><span class="p">,</span> <span class="n">group_id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">max_chunks</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_chunks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//XENO: cursor points to Guest OS shared memory, and is thus ACID</span>
<span class="k">static</span> <span class="n">QEMUCursor</span> <span class="o">*</span><span class="nf">qxl_cursor</span><span class="p">(</span><span class="n">PCIQXLDevice</span> <span class="o">*</span><span class="n">qxl</span><span class="p">,</span> <span class="n">QXLCursor</span> <span class="o">*</span><span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">group_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">QEMUCursor</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">and_mask</span><span class="p">,</span> <span class="o">*</span><span class="n">xor_mask</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">cursor_alloc</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">hot_x</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">hot_spot_x</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">hot_y</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">hot_spot_y</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">SPICE_CURSOR_TYPE_MONO</span><span class="p">:</span>
        <span class="cm">/* Assume that the full cursor is available in a single chunk. */</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cursor_get_mono_bpl</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s: bad monochrome cursor %ux%u with size %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">__func__</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">and_mask</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">chunk</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
        <span class="n">xor_mask</span> <span class="o">=</span> <span class="n">and_mask</span> <span class="o">+</span> <span class="n">cursor_get_mono_bpl</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
        <span class="n">cursor_set_mono</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mh">0xffffff</span><span class="p">,</span> <span class="mh">0x000000</span><span class="p">,</span> <span class="n">xor_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">and_mask</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qxl</span><span class="o">-&gt;</span><span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cursor_print_ascii_art</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">"qxl/mono"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">SPICE_CURSOR_TYPE_ALPHA</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
        <span class="n">qxl_unpack_chunks</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">qxl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">chunk</span><span class="p">,</span> <span class="n">group_id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qxl</span><span class="o">-&gt;</span><span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cursor_print_ascii_art</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">"qxl/alpha"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s: not implemented: type %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">__func__</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>

<span class="nl">fail:</span>
    <span class="n">cursor_put</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Check that the cursor resource is fetched twice in the code.</p>

<ul>
  <li>
    <p>First, as parameters in the cursor_alloc() function, which returns a pointer to a cursor structu which some fields had been filled through the passed parameters:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">QEMUCursor</span> <span class="o">*</span><span class="nf">cursor_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">QEMUCursor</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">datasize</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

      <span class="n">c</span> <span class="o">=</span> <span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QEMUCursor</span><span class="p">)</span> <span class="o">+</span> <span class="n">datasize</span><span class="p">);</span>
      <span class="n">c</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
      <span class="n">c</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
      <span class="n">c</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">QEMUCursor</span> <span class="o">*</span><span class="nf">qxl_cursor</span><span class="p">(</span><span class="n">PCIQXLDevice</span> <span class="o">*</span><span class="n">qxl</span><span class="p">,</span> <span class="n">QXLCursor</span> <span class="o">*</span><span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">group_id</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">QEMUCursor</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
      <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">and_mask</span><span class="p">,</span> <span class="o">*</span><span class="n">xor_mask</span><span class="p">;</span>
      <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

      <span class="n">c</span> <span class="o">=</span> <span class="n">cursor_alloc</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
      <span class="c1">//...</span>
</code></pre></div>    </div>

    <p><br /></p>
  </li>
  <li>
    <p>Later, the code enters in a switch statement in which again access some cursor's specific fields to fill a variable (size), and then all along with the previously crafted 'c' structure, it call qxl_unpack_chunks() function:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//...</span>
  <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
  <span class="n">qxl_unpack_chunks</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">qxl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">chunk</span><span class="p">,</span> <span class="n">group_id</span><span class="p">);</span>
  <span class="c1">//...</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>This as a fact of matters constitutes a double fectch's race condition vulnerability.</p>

<p>The code is accesing twice an user-controlled resources (cursor height and weight) assuming that this resource value is constant between the calls and in is relating those two value in the execution flow:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">qxl_unpack_chunks</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">PCIQXLDevice</span> <span class="o">*</span><span class="n">qxl</span><span class="p">,</span> <span class="n">QXLDataChunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">group_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">max_chunks</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">bytes</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">qxl_phys2virt</span><span class="p">(</span><span class="n">qxl</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">next_chunk</span><span class="p">,</span> <span class="n">group_id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">max_chunks</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_chunks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Inside the function above, a memcpy() operation, which is including <em>bytes</em> bytes of chunk-&gt;data (cursor user-controlled data field) on dest + offset. Thus, since bytes comes from our second fetch of the controlled parameters <em>heigh</em> and <em>weight</em> and <em>dest + offset</em> is the c structure, previously allocated with the first fetch, there can be a missleading between the allocation space and the number of bytes being copied leading to a heap-buffer overflow.</p>

<p>Note that this do not enters on the TOCTOU group of Race Conditions since no check is being made, just the same value fetched twice on the same procedure.</p>

<p><br /></p>

<h4 id="22-cve-2020-7460">2.2. CVE-2020-7460.</h4>

<p>System calls are a mechanism for kernelspace to perform an action on userspace's behalf. FreeBSD implements the sendmsg() system call, to send messages from sockets:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">sendmsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div></div>

<p>The <em>struct msghdr *msg parameter</em> has <em>void *msg_control</em> and <em>socklen_t msg_controllen</em> fields, which represent an ancillary data buffer in userspace that the kernel should process in <em>freebsd32_copyin_control()</em>. The anticipated layout of this memory is shown below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────────────────────────────────────────────────────────────┐
│                          msg_control buffer                                 │
├───────────┬───────────┬───────────┬───────────┬───────────┬─────────────────┤
│  cmsg_len │  cmsg_len │  cmsg_len │  cmsg_len │  cmsg_len │    cmsg_len     │
│  (header) │   bytes   │  (header) │   bytes   │  (header) │     bytes       │
│           │  (data)   │           │  (data)   │           │    (data)       │
└───────────┴─────┬─────┴───────────┴─────┬─────┴───────────┴────────┬────────┘
                  │                       │                          │
                  ▼                       ▼                          ▼
            data length            data length                 data length
          derived from           derived from                derived from
             cmsg_len               cmsg_len                    cmsg_len
</code></pre></div></div>

<p>Consider now the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//XENO: buf is an ACID address/contents userspace buffer, buflen is also ACID</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">freebsd32_copyin_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">**</span><span class="n">mp</span><span class="p">,</span> <span class="n">caddr_t</span> <span class="n">buf</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">msglen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">buflen</span> <span class="o">=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="n">buflen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="n">MCLBYTES</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/*
	 * Iterate over the buffer and get the length of each message
	 * in there. This has 32-bit alignment and padding. Use it to
	 * determine the length of these messages when using 64-bit
	 * alignment and padding.
	 */</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msglen</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msglen</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="n">msglen</span> <span class="o">=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">msglen</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">+=</span> <span class="n">msglen</span><span class="p">;</span>
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">))</span> <span class="o">-</span>
		    <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MCLBYTES</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">m_get</span><span class="p">(</span><span class="n">M_WAITOK</span><span class="p">,</span> <span class="n">MT_CONTROL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MLEN</span><span class="p">)</span>
		<span class="n">MCLGET</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M_WAITOK</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">md</span> <span class="o">=</span> <span class="n">mtod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msglen</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u_int</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span><span class="p">;</span>
		<span class="n">msglen</span> <span class="o">=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>

		<span class="cm">/* Modify the message length to account for alignment. */</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u_int</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span> <span class="o">=</span> <span class="n">msglen</span> <span class="o">+</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">))</span> <span class="o">-</span>
		    <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>

		<span class="n">md</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span> <span class="o">+</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
		<span class="n">buflen</span> <span class="o">-=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>

		<span class="n">msglen</span> <span class="o">-=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">msglen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">md</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span> <span class="o">+</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">msglen</span><span class="p">;</span>
			<span class="n">buflen</span> <span class="o">-=</span> <span class="n">msglen</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">m_free</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the code there are two fetches of data from the buffer:</p>

<ul>
  <li>
    <p>First, from the while loop, the program takes data from the userspace shared memory buffer onto the <em>msglen</em> memory address. In this first while loop, this extracted data ends up in the <em>len</em> variable which later will be part of the <em>m</em>'s structure length field <em>m-&gt;m_len = len;</em>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msglen</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msglen</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">))</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
      <span class="n">msglen</span> <span class="o">=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">msglen</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
      <span class="n">idx</span> <span class="o">+=</span> <span class="n">msglen</span><span class="p">;</span>
      <span class="n">msglen</span> <span class="o">+=</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">))</span> <span class="o">-</span>
          <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
      <span class="n">len</span> <span class="o">+=</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MCLBYTES</span><span class="p">)</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

  <span class="n">m</span> <span class="o">=</span> <span class="n">m_get</span><span class="p">(</span><span class="n">M_WAITOK</span><span class="p">,</span> <span class="n">MT_CONTROL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MLEN</span><span class="p">)</span>
      <span class="n">MCLGET</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M_WAITOK</span><span class="p">);</span>
  <span class="n">m</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
  <span class="n">md</span> <span class="o">=</span> <span class="n">mtod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Then, a second while loop enters in which a second fetch happens and the potential modified data from the shared buffer endsup in <em>msglen</em>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">while</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="n">msglen</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u_int</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span><span class="p">;</span>
      <span class="c1">//...</span>
      <span class="n">msglen</span> <span class="o">-=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">msglen</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="n">md</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span> <span class="o">+</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>
          <span class="n">buf</span> <span class="o">+=</span> <span class="n">msglen</span><span class="p">;</span>
          <span class="n">buflen</span> <span class="o">-=</span> <span class="n">msglen</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Let's observe carefully that in the first fetch a memory space gets alloced in md, later the data gets again retrieved from the buffer and is used to write data on the previous allocated space, if the first fetch allocates a small memory region, the second fetch could lead to a overcopy leading to a heapbuffer overflow.</p>

<p><br /></p>

<h4 id="23-cve-2021-34514-blackswan">2.3. CVE-2021-34514. "BlackSwan".</h4>

<p>ALPC (Advanced Local Procedure Call) is a mechanism for communicating userspace to userspace, userspace to kernelspace, or kernelspace to kernelspace. Unlike the original LPC technology, ALPC is asynchronous, to improve performance through parallelism. Another performance improvement is using shared memory, to reduce data copy frequency.</p>

<p>Let's check the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Heavily simplified pseudocode for the vulnerable function</span>
<span class="kt">void</span> <span class="nf">AlpcpCompleteDispatchMessage</span><span class="p">(</span><span class="n">_ALPC_DISPATCH_CONTEXT</span> <span class="o">*</span><span class="n">DispatchContext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_ALPC_PORT</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="n">_KALPC_MESSAGE</span> <span class="o">*</span><span class="n">message</span><span class="p">;</span>
	<span class="n">_ALPC_COMPLETION_LIST</span> <span class="o">*</span><span class="n">completionList</span><span class="p">;</span>
	<span class="n">_ALPC_MESSAGE_ATTRIBUTES</span> <span class="o">*</span><span class="n">attributes</span><span class="p">;</span>
	<span class="n">_PORT_MESSAGE</span> <span class="o">*</span><span class="n">userMappedMessage</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">userMappedMessageData</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">completionBufferOffset</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bufferLength</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alignmentPadding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">DispatchContext</span><span class="o">-&gt;</span><span class="n">TargetPort</span><span class="p">;</span>
	<span class="n">message</span> <span class="o">=</span> <span class="n">DispatchContext</span><span class="o">-&gt;</span><span class="n">Message</span><span class="p">;</span>
	<span class="n">completionList</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">CompletionList</span><span class="p">;</span>
	<span class="n">bufferLength</span> <span class="o">=</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">PortMessage</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">s1</span><span class="p">.</span><span class="n">TotalLength</span><span class="p">;</span>
	<span class="n">bufferLength</span> <span class="o">+=</span> <span class="n">completionList</span><span class="o">-&gt;</span><span class="n">AttributeSize</span> <span class="o">+</span> <span class="n">alignmentPadding</span><span class="p">;</span>

	<span class="c1">// Finds free space in the completion list</span>
	<span class="n">completionBufferOffset</span> <span class="o">=</span> <span class="n">AlpcpAllocateCompletionBuffer</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">bufferLength</span><span class="p">);</span>

	<span class="n">userMappedMessage</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PORT_MESSAGE</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">completionList</span><span class="o">-&gt;</span><span class="n">Data</span> <span class="o">+</span>
                                                       <span class="n">completionBufferOffset</span><span class="p">);</span>

	<span class="c1">// Message header is copied into shared user memory</span>
	<span class="o">*</span><span class="n">userMappedMessage</span> <span class="o">=</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">PortMessage</span><span class="p">;</span>
	<span class="n">userMappedMessageData</span> <span class="o">=</span> <span class="n">userMappedMessage</span> <span class="o">+</span> <span class="mh">0x1</span><span class="p">;</span>

	<span class="c1">// Copy message body into shared user memory</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">DataUserVa</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0</span><span class="p">){</span>
		<span class="n">AlpcpReadMessageData</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">userMappedMessageData</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">AlpcpGetDataFromUserVaSafe</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">userMappedMessageData</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">completionList</span><span class="o">-&gt;</span><span class="n">AttributeFlags</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="c1">// Calulate offset and copy attributes into shared user memory</span>
		<span class="n">attributes</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ALPC_MESSAGE_ATTRIBUTES</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span><span class="n">uintptr</span> <span class="n">t</span><span class="p">)</span> <span class="n">userMappedMessage</span> <span class="o">+</span>	<span class="n">userMappedMessage</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">s1</span><span class="p">.</span><span class="n">TotalLength</span> <span class="o">+</span> <span class="n">alignmentPadding</span><span class="p">);</span>

		<span class="n">attributes</span><span class="o">-&gt;</span><span class="n">AllocatedAttributes</span> <span class="o">=</span> <span class="n">completionList</span><span class="o">-&gt;</span><span class="n">AttributeFlags</span><span class="p">;</span>
		<span class="n">attributes</span><span class="o">-&gt;</span><span class="n">ValidAttributes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">AlpcpExposeAttributes</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">completionList</span><span class="o">-&gt;</span><span class="n">AttributeFlags</span><span class="p">,</span> <span class="n">attributes</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Consider that the code is essentially using the information from the parameter to first allocate space for the message in what would be the first fetch:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bufferLength</span> <span class="o">=</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">PortMessage</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">s1</span><span class="p">.</span><span class="n">TotalLength</span><span class="p">;</span> <span class="c1">//1st fetch</span>
<span class="n">bufferLength</span> <span class="o">+=</span> <span class="n">completionList</span><span class="o">-&gt;</span><span class="n">AttributeSize</span> <span class="o">+</span> <span class="n">alignmentPadding</span><span class="p">;</span>

<span class="c1">// Finds free space in the completion list</span>
<span class="n">completionBufferOffset</span> <span class="o">=</span> <span class="n">AlpcpAllocateCompletionBuffer</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">bufferLength</span><span class="p">);</span>

<span class="n">userMappedMessage</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PORT_MESSAGE</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">completionList</span><span class="o">-&gt;</span><span class="n">Data</span> <span class="o">+</span> <span class="n">completionBufferOffset</span><span class="p">);</span>
</code></pre></div></div>

<p>Is worth to mention that what is passed as a parameter is a memory address to a shared memory region and what is being assignated in the stackframe of the function are fields from the structure pointed by te address passed as a parameter, this are, essentially more address in the form of "address + offset". This means that, despite this address being stored in the stackframe, this address referes to contents lying in a memory region the user controls and thus are suscetible to change between fetchs (race condition).</p>

<p>Then, the message is copied onto the alloced region in a second fetch:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Message header is copied into shared user memory</span>
<span class="o">*</span><span class="n">userMappedMessage</span> <span class="o">=</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">PortMessage</span><span class="p">;</span>
<span class="n">userMappedMessageData</span> <span class="o">=</span> <span class="n">userMappedMessage</span> <span class="o">+</span> <span class="mh">0x1</span><span class="p">;</span>

<span class="c1">// Copy message body into shared user memory</span>
<span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">DataUserVa</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0</span><span class="p">){</span>
    <span class="n">AlpcpReadMessageData</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">userMappedMessageData</span><span class="p">);</span> <span class="c1">//2nd fetch</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">AlpcpGetDataFromUserVaSafe</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">userMappedMessageData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As we say before, the contents of the buffer may be changed between fetches, leading first to an underallocation and later changing the contents to lead to an overcopy trigerring a heap-buffer overflow.</p>

<p>There is also another posibility since there is a third fetch:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">completionList</span><span class="o">-&gt;</span><span class="n">AttributeFlags</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">)</span>	<span class="p">{</span>
    <span class="c1">// Calulate offset and copy attributes into shared user memory</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ALPC_MESSAGE_ATTRIBUTES</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span><span class="n">uintptr</span> <span class="n">t</span><span class="p">)</span> <span class="n">userMappedMessage</span> <span class="o">+</span> <span class="n">userMappedMessage</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">s1</span><span class="p">.</span><span class="n">TotalLength</span> <span class="o">+</span> <span class="n">alignmentPadding</span><span class="p">);</span>

    <span class="n">attributes</span><span class="o">-&gt;</span><span class="n">AllocatedAttributes</span> <span class="o">=</span> <span class="n">completionList</span><span class="o">-&gt;</span><span class="n">AttributeFlags</span><span class="p">;</span>
    <span class="n">attributes</span><span class="o">-&gt;</span><span class="n">ValidAttributes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">AlpcpExposeAttributes</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">completionList</span><span class="o">-&gt;</span><span class="n">AttributeFlags</span><span class="p">,</span> <span class="n">attributes</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>]]></content><author><name>German Sanmi</name></author><category term="Past Blogs" /><category term="Binary Exploitation" /><category term="memory-corruption" /><category term="exploits" /><summary type="html"><![CDATA[1. Definition. 1.1. Race Condition definition. Race Condition is a term than refers to a set of bugs which arises when the behavior of a system depends on the relative timing or ordering of events, and that timing isn't properly controlled. The "race" is between two or more operations that need to happen in a specific order to produce correct results, but the system fails in guaranteeing that order. A race condition emerges from a gap between checking a condition and acting on it. During that window—however brief—the state can change, invalidating the assumption your code just made. Consider the following code: if (file_exists("/tmp/data")) { // Window of vulnerability here open_and_read("/tmp/data"); } In the gap between checking and opening the file, some other process can interfere with it as a shared object. We difference between two types of races condition in this course: TOCTOU (Time-of-Check to Time-of-Use) — the example above. You check something, then use it, assuming the check remains valid. Double Fetch — A double fetch occurs when kernel code reads the same user-space memory location twice, assuming the value remains constant between reads. Since user-space memory is under attacker control, a malicious thread can modify the value between the two fetches, breaking the kernel's assumptions. The following diagram shows the TOCTOU race condition in-detail: PROCESS 1 (Victim) SHARED PROCESS 2 (Attacker) │ RESOURCE (file) │ Time │ │ │ │ │ │ │ │ │ ┌─────────┐ │ │ │ │ │ Verify()│ │ │ │ │ │ Read ──────────────────────► │ │ │ │ └─────────┘ │ │ │ │ │ │ │ │ | | │ │ │ │ │ │ │ │ │ │ | │ │ │ | │ │ │ | │ │ │ │ Write │ │ │ │ ◄─────────────────── │ │ │ │ (Attacker changes │ │ │ │ the resource) │ │ │ │ │ │ │ Write │ │ │ │ ◄───────────────────────── │ (Now operates on │ │ │ │ attacker-controlled │ │ │ │ resource!) │ │ │ │ │ │ │ TIME OF USE │ │ ▼ ▼ ▼ ▼ If is well compassed, the writter can change the resource between the check and the use. 2. Exercises. 2.1. CVE-2021-4207. QEMU is an emulation and virtualization system. In the context of this bug, it's being used as a virtualization system, specifically via the use of the paravirtualized framebuffer video accelerator device, QXL. Paravirtualization is when you don't run an unmodified OS within the hypervisor, but instead run a modified one, that is aware of the hypervisor, and takes actions to make virtualization easier. In the context of this attack, the guest VM is the attacker, and the QEMU hypervisor is the target. The attacker wants to break out of the virtualization, and gain code execution on the enclosing host, by exploiting a vulnerability in QEMU. Consider the following C code: QEMUCursor *cursor_alloc(int width, int height) { QEMUCursor *c; int datasize = width * height * sizeof(uint32_t); c = g_malloc0(sizeof(QEMUCursor) + datasize); c-&gt;width = width; c-&gt;height = height; c-&gt;refcount = 1; return c; } static void qxl_unpack_chunks(void *dest, size_t size, PCIQXLDevice *qxl, QXLDataChunk *chunk, uint32_t group_id) { uint32_t max_chunks = 32; size_t offset = 0; size_t bytes; for (;;) { bytes = MIN(size - offset, chunk-&gt;data_size); memcpy(dest + offset, chunk-&gt;data, bytes); offset += bytes; if (offset == size) { return; } chunk = qxl_phys2virt(qxl, chunk-&gt;next_chunk, group_id); if (!chunk) { return; } max_chunks--; if (max_chunks == 0) { return; } } } //XENO: cursor points to Guest OS shared memory, and is thus ACID static QEMUCursor *qxl_cursor(PCIQXLDevice *qxl, QXLCursor *cursor, uint32_t group_id) { QEMUCursor *c; uint8_t *and_mask, *xor_mask; size_t size; c = cursor_alloc(cursor-&gt;header.width, cursor-&gt;header.height); c-&gt;hot_x = cursor-&gt;header.hot_spot_x; c-&gt;hot_y = cursor-&gt;header.hot_spot_y; switch (cursor-&gt;header.type) { case SPICE_CURSOR_TYPE_MONO: /* Assume that the full cursor is available in a single chunk. */ size = 2 * cursor_get_mono_bpl(c) * c-&gt;height; if (size != cursor-&gt;data_size) { fprintf(stderr, "%s: bad monochrome cursor %ux%u with size %u\n", __func__, c-&gt;width, c-&gt;height, cursor-&gt;data_size); goto fail; } and_mask = cursor-&gt;chunk.data; xor_mask = and_mask + cursor_get_mono_bpl(c) * c-&gt;height; cursor_set_mono(c, 0xffffff, 0x000000, xor_mask, 1, and_mask); if (qxl-&gt;debug &gt; 2) { cursor_print_ascii_art(c, "qxl/mono"); } break; case SPICE_CURSOR_TYPE_ALPHA: size = sizeof(uint32_t) * cursor-&gt;header.width * cursor-&gt;header.height; qxl_unpack_chunks(c-&gt;data, size, qxl, &amp;cursor-&gt;chunk, group_id); if (qxl-&gt;debug &gt; 2) { cursor_print_ascii_art(c, "qxl/alpha"); } break; default: fprintf(stderr, "%s: not implemented: type %d\n", __func__, cursor-&gt;header.type); goto fail; } return c; fail: cursor_put(c); return NULL; } Check that the cursor resource is fetched twice in the code. First, as parameters in the cursor_alloc() function, which returns a pointer to a cursor structu which some fields had been filled through the passed parameters: QEMUCursor *cursor_alloc(int width, int height) { QEMUCursor *c; int datasize = width * height * sizeof(uint32_t); c = g_malloc0(sizeof(QEMUCursor) + datasize); c-&gt;width = width; c-&gt;height = height; c-&gt;refcount = 1; return c; } static QEMUCursor *qxl_cursor(PCIQXLDevice *qxl, QXLCursor *cursor, uint32_t group_id) { QEMUCursor *c; uint8_t *and_mask, *xor_mask; size_t size; c = cursor_alloc(cursor-&gt;header.width, cursor-&gt;header.height); //... Later, the code enters in a switch statement in which again access some cursor's specific fields to fill a variable (size), and then all along with the previously crafted 'c' structure, it call qxl_unpack_chunks() function: //... size = sizeof(uint32_t) * cursor-&gt;header.width * cursor-&gt;header.height; qxl_unpack_chunks(c-&gt;data, size, qxl, &amp;cursor-&gt;chunk, group_id); //... This as a fact of matters constitutes a double fectch's race condition vulnerability. The code is accesing twice an user-controlled resources (cursor height and weight) assuming that this resource value is constant between the calls and in is relating those two value in the execution flow: static void qxl_unpack_chunks(void *dest, size_t size, PCIQXLDevice *qxl, QXLDataChunk *chunk, uint32_t group_id) { uint32_t max_chunks = 32; size_t offset = 0; size_t bytes; for (;;) { bytes = MIN(size - offset, chunk-&gt;data_size); memcpy(dest + offset, chunk-&gt;data, bytes); offset += bytes; if (offset == size) { return; } chunk = qxl_phys2virt(qxl, chunk-&gt;next_chunk, group_id); if (!chunk) { return; } max_chunks--; if (max_chunks == 0) { return; } } } Inside the function above, a memcpy() operation, which is including bytes bytes of chunk-&gt;data (cursor user-controlled data field) on dest + offset. Thus, since bytes comes from our second fetch of the controlled parameters heigh and weight and dest + offset is the c structure, previously allocated with the first fetch, there can be a missleading between the allocation space and the number of bytes being copied leading to a heap-buffer overflow. Note that this do not enters on the TOCTOU group of Race Conditions since no check is being made, just the same value fetched twice on the same procedure. 2.2. CVE-2020-7460. System calls are a mechanism for kernelspace to perform an action on userspace's behalf. FreeBSD implements the sendmsg() system call, to send messages from sockets: ssize_t sendmsg(int s, const struct msghdr *msg, int flags); The struct msghdr *msg parameter has void *msg_control and socklen_t msg_controllen fields, which represent an ancillary data buffer in userspace that the kernel should process in freebsd32_copyin_control(). The anticipated layout of this memory is shown below: ┌─────────────────────────────────────────────────────────────────────────────┐ │ msg_control buffer │ ├───────────┬───────────┬───────────┬───────────┬───────────┬─────────────────┤ │ cmsg_len │ cmsg_len │ cmsg_len │ cmsg_len │ cmsg_len │ cmsg_len │ │ (header) │ bytes │ (header) │ bytes │ (header) │ bytes │ │ │ (data) │ │ (data) │ │ (data) │ └───────────┴─────┬─────┴───────────┴─────┬─────┴───────────┴────────┬────────┘ │ │ │ ▼ ▼ ▼ data length data length data length derived from derived from derived from cmsg_len cmsg_len cmsg_len Consider now the following C code: //XENO: buf is an ACID address/contents userspace buffer, buflen is also ACID static int freebsd32_copyin_control(struct mbuf **mp, caddr_t buf, u_int buflen) { struct mbuf *m; void *md; u_int idx, len, msglen; int error; buflen = FREEBSD32_ALIGN(buflen); if (buflen &gt; MCLBYTES) return (EINVAL); /* * Iterate over the buffer and get the length of each message * in there. This has 32-bit alignment and padding. Use it to * determine the length of these messages when using 64-bit * alignment and padding. */ idx = 0; len = 0; while (idx &lt; buflen) { error = copyin(buf + idx, &amp;msglen, sizeof(msglen)); if (error) return (error); if (msglen &lt; sizeof(struct cmsghdr)) return (EINVAL); msglen = FREEBSD32_ALIGN(msglen); if (idx + msglen &gt; buflen) return (EINVAL); idx += msglen; msglen += CMSG_ALIGN(sizeof(struct cmsghdr)) - FREEBSD32_ALIGN(sizeof(struct cmsghdr)); len += CMSG_ALIGN(msglen); } if (len &gt; MCLBYTES) return (EINVAL); m = m_get(M_WAITOK, MT_CONTROL); if (len &gt; MLEN) MCLGET(m, M_WAITOK); m-&gt;m_len = len; md = mtod(m, void *); while (buflen &gt; 0) { error = copyin(buf, md, sizeof(struct cmsghdr)); if (error) break; msglen = *(u_int *)md; msglen = FREEBSD32_ALIGN(msglen); /* Modify the message length to account for alignment. */ *(u_int *)md = msglen + CMSG_ALIGN(sizeof(struct cmsghdr)) - FREEBSD32_ALIGN(sizeof(struct cmsghdr)); md = (char *)md + CMSG_ALIGN(sizeof(struct cmsghdr)); buf += FREEBSD32_ALIGN(sizeof(struct cmsghdr)); buflen -= FREEBSD32_ALIGN(sizeof(struct cmsghdr)); msglen -= FREEBSD32_ALIGN(sizeof(struct cmsghdr)); if (msglen &gt; 0) { error = copyin(buf, md, msglen); if (error) break; md = (char *)md + CMSG_ALIGN(msglen); buf += msglen; buflen -= msglen; } } if (error) m_free(m); else *mp = m; return (error); } In the code there are two fetches of data from the buffer: First, from the while loop, the program takes data from the userspace shared memory buffer onto the msglen memory address. In this first while loop, this extracted data ends up in the len variable which later will be part of the m's structure length field m-&gt;m_len = len;: while (idx &lt; buflen) { error = copyin(buf + idx, &amp;msglen, sizeof(msglen)); if (error) return (error); if (msglen &lt; sizeof(struct cmsghdr)) return (EINVAL); msglen = FREEBSD32_ALIGN(msglen); if (idx + msglen &gt; buflen) return (EINVAL); idx += msglen; msglen += CMSG_ALIGN(sizeof(struct cmsghdr)) - FREEBSD32_ALIGN(sizeof(struct cmsghdr)); len += CMSG_ALIGN(msglen); } if (len &gt; MCLBYTES) return (EINVAL); m = m_get(M_WAITOK, MT_CONTROL); if (len &gt; MLEN) MCLGET(m, M_WAITOK); m-&gt;m_len = len; md = mtod(m, void *); Then, a second while loop enters in which a second fetch happens and the potential modified data from the shared buffer endsup in msglen: while (buflen &gt; 0) { error = copyin(buf, md, sizeof(struct cmsghdr)); if (error) break; msglen = *(u_int *)md; //... msglen -= FREEBSD32_ALIGN(sizeof(struct cmsghdr)); if (msglen &gt; 0) { error = copyin(buf, md, msglen); if (error) break; md = (char *)md + CMSG_ALIGN(msglen); buf += msglen; buflen -= msglen; } } Let's observe carefully that in the first fetch a memory space gets alloced in md, later the data gets again retrieved from the buffer and is used to write data on the previous allocated space, if the first fetch allocates a small memory region, the second fetch could lead to a overcopy leading to a heapbuffer overflow. 2.3. CVE-2021-34514. "BlackSwan". ALPC (Advanced Local Procedure Call) is a mechanism for communicating userspace to userspace, userspace to kernelspace, or kernelspace to kernelspace. Unlike the original LPC technology, ALPC is asynchronous, to improve performance through parallelism. Another performance improvement is using shared memory, to reduce data copy frequency. Let's check the following code: // Heavily simplified pseudocode for the vulnerable function void AlpcpCompleteDispatchMessage(_ALPC_DISPATCH_CONTEXT *DispatchContext) { _ALPC_PORT *port; _KALPC_MESSAGE *message; _ALPC_COMPLETION_LIST *completionList; _ALPC_MESSAGE_ATTRIBUTES *attributes; _PORT_MESSAGE *userMappedMessage; void *userMappedMessageData; uint32_t completionBufferOffset; uint32_t bufferLength; uint32_t alignmentPadding = 0; port = DispatchContext-&gt;TargetPort; message = DispatchContext-&gt;Message; completionList = port-&gt;CompletionList; bufferLength = message-&gt;PortMessage.u1.s1.TotalLength; bufferLength += completionList-&gt;AttributeSize + alignmentPadding; // Finds free space in the completion list completionBufferOffset = AlpcpAllocateCompletionBuffer(port, bufferLength); userMappedMessage = (_PORT_MESSAGE *) ((uintptr_t) completionList-&gt;Data + completionBufferOffset); // Message header is copied into shared user memory *userMappedMessage = message-&gt;PortMessage; userMappedMessageData = userMappedMessage + 0x1; // Copy message body into shared user memory if (message-&gt;DataUserVa == (void *)0x0){ AlpcpReadMessageData(message, userMappedMessageData); } else { AlpcpGetDataFromUserVaSafe(message, userMappedMessageData); } if (completionList-&gt;AttributeFlags != 0x0) { // Calulate offset and copy attributes into shared user memory attributes = (_ALPC_MESSAGE_ATTRIBUTES *) ( (uintptr t) userMappedMessage + userMappedMessage-&gt;u1.s1.TotalLength + alignmentPadding); attributes-&gt;AllocatedAttributes = completionList-&gt;AttributeFlags; attributes-&gt;ValidAttributes = 0; AlpcpExposeAttributes(port, 0, message, completionList-&gt;AttributeFlags, attributes); } //... } Consider that the code is essentially using the information from the parameter to first allocate space for the message in what would be the first fetch: bufferLength = message-&gt;PortMessage.u1.s1.TotalLength; //1st fetch bufferLength += completionList-&gt;AttributeSize + alignmentPadding; // Finds free space in the completion list completionBufferOffset = AlpcpAllocateCompletionBuffer(port, bufferLength); userMappedMessage = (_PORT_MESSAGE *) ((uintptr_t) completionList-&gt;Data + completionBufferOffset); Is worth to mention that what is passed as a parameter is a memory address to a shared memory region and what is being assignated in the stackframe of the function are fields from the structure pointed by te address passed as a parameter, this are, essentially more address in the form of "address + offset". This means that, despite this address being stored in the stackframe, this address referes to contents lying in a memory region the user controls and thus are suscetible to change between fetchs (race condition). Then, the message is copied onto the alloced region in a second fetch: // Message header is copied into shared user memory *userMappedMessage = message-&gt;PortMessage; userMappedMessageData = userMappedMessage + 0x1; // Copy message body into shared user memory if (message-&gt;DataUserVa == (void *)0x0){ AlpcpReadMessageData(message, userMappedMessageData); //2nd fetch } else { AlpcpGetDataFromUserVaSafe(message, userMappedMessageData); } As we say before, the contents of the buffer may be changed between fetches, leading first to an underallocation and later changing the contents to lead to an overcopy trigerring a heap-buffer overflow. There is also another posibility since there is a third fetch: if (completionList-&gt;AttributeFlags != 0x0) { // Calulate offset and copy attributes into shared user memory attributes = (_ALPC_MESSAGE_ATTRIBUTES *) ( (uintptr t) userMappedMessage + userMappedMessage-&gt;u1.s1.TotalLength + alignmentPadding); attributes-&gt;AllocatedAttributes = completionList-&gt;AttributeFlags; attributes-&gt;ValidAttributes = 0; AlpcpExposeAttributes(port, 0, message, completionList-&gt;AttributeFlags, attributes); }]]></summary></entry><entry><title type="html">Introducción al Cálculo</title><link href="http://localhost:4000/posts/2025/12/25/MathTest/" rel="alternate" type="text/html" title="Introducción al Cálculo" /><published>2025-12-25T10:00:00+01:00</published><updated>2025-12-25T10:00:00+01:00</updated><id>http://localhost:4000/posts/2025/12/25/MathTest</id><content type="html" xml:base="http://localhost:4000/posts/2025/12/25/MathTest/"><![CDATA[<h2 id="teorema-fundamental-del-cálculo">Teorema fundamental del cálculo</h2>

<p>La derivada de una integral es:</p>

\[\frac{d}{dx}\int_a^x f(t)dt = f(x)\]

<h2 id="ecuaciones-inline">Ecuaciones inline</h2>

<p>También puedes usar ecuaciones dentro del texto, por ejemplo la famosa ecuación de Einstein \(E = mc^2\) o la identidad de Euler \(e^{i\pi} + 1 = 0\).</p>

<h2 id="más-ejemplos">Más ejemplos</h2>

<p>La fórmula cuadrática:</p>

\[x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}\]

<p>Serie de Taylor:</p>

\[f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(a)}{n!}(x-a)^n\]

<p>Límite importante:</p>

\[\lim_{x \to 0} \frac{\sin x}{x} = 1\]

<h2 id="matrices">Matrices</h2>

\[\begin{pmatrix}
a &amp; b \\
c &amp; d
\end{pmatrix}
\begin{pmatrix}
x \\
y
\end{pmatrix}
=
\begin{pmatrix}
ax + by \\
cx + dy
\end{pmatrix}\]

\[\mathcal{O}(n^c)\]

\[\frac{a}{c}, \frac{b}{c} \in \mathbb{Z}\]

\[\nexists  d \in \mathbb{Z} : \frac{a}{c}, \frac{b}{c} \in \mathbb{Z}  \land   d &gt; c\]

\[\exists (q_1,r_1) \in \mathbb{Z}^2\]

\[b&gt;r_1&gt;=0\]

<p>By definition, the greater common divisor of two integer <em>a</em> and <em>b</em> (notated as <em>gcd(a,b)</em>), is the greater integer that divides those two numbers, this is, an integer <em>c</em> that satisfies:</p>

\[\frac{a}{c}, \frac{b}{c} \in \mathbb{Z}\]

\[\nexists  d \in \mathbb{Z} : \frac{a}{c}, \frac{b}{c} \in \mathbb{Z}  \land   d &gt; c\]

<p>Let's consider \(a,b \in \mathbb{Z}\) (we can safely assume that is \(a&gt;b\), otherwise \(gcd(a,b) = gcd(a,a) = a\)). Then:</p>

\[\exists (q_1,r_1) \in \mathbb{Z}^2 : a = b·q_1 + r_1\]

<p>Being \(b&gt;r_1&gt;=0\). For this same reason, it's also true that:</p>

\[\exists (q_2,r_2) \in \mathbb{Z}^2 : b = r_1·q_2 + r_2 \land b &gt; r_1 &gt; r_2 &gt;=0\]

<p>Aware that this process is finite, since the sequence \(b, r_1, r_2\), and so on are strictly positive and decremental, this \(\exists n \mathbb{N} : r_n = 0\).</p>

<p>Since this is just an approach, we don't gonna demonstrate the generic case, although is also easy to extrapolate from a concrete case.</p>

<p>Let's suppose that \(r_3 = 0\), thus we would have:</p>

\[a = b·q_1 + r_1 = (r_1·q_2 + r_2) + r_1 = [(r_2·q_3 + \cancel{r_3})q_2 + r_2] + r_2·q_3 + \cancel{r_3} = r_2·(q_3q_2 + 1 + q_3)\]

<p>Now is obvious that \(\frac{a}{r_2} \in \mathbb{Z}\), also is evident that \(\frac{b}{r_2} \in \mathbb{Z}\) so this number meets the first condition, it divides the two integers.</p>

<p>Also, consider that every divisor of \(a\) and \(b\) is also divisor of the remainder:</p>

\[\forall d \in \mathbb{Z} d | a \land d | b \implies d | a \% b\]

<p>And also happens that:</p>

\[d | a \% b  \implies d | b \% (a \% b)\]

<p>This means that the first remainder which is also a divisor of a and b is in fact the greatest common divisor since each other divisor also divide it for being a reminder.</p>]]></content><author><name>German Sanmi</name></author><category term="Maths" /><category term="mathematics" /><category term="theory" /><summary type="html"><![CDATA[Teorema fundamental del cálculo La derivada de una integral es: \[\frac{d}{dx}\int_a^x f(t)dt = f(x)\] Ecuaciones inline También puedes usar ecuaciones dentro del texto, por ejemplo la famosa ecuación de Einstein \(E = mc^2\) o la identidad de Euler \(e^{i\pi} + 1 = 0\). Más ejemplos La fórmula cuadrática: \[x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}\] Serie de Taylor: \[f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(a)}{n!}(x-a)^n\] Límite importante: \[\lim_{x \to 0} \frac{\sin x}{x} = 1\] Matrices \[\begin{pmatrix} a &amp; b \\ c &amp; d \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} ax + by \\ cx + dy \end{pmatrix}\] \[\mathcal{O}(n^c)\] \[\frac{a}{c}, \frac{b}{c} \in \mathbb{Z}\] \[\nexists d \in \mathbb{Z} : \frac{a}{c}, \frac{b}{c} \in \mathbb{Z} \land d &gt; c\] \[\exists (q_1,r_1) \in \mathbb{Z}^2\] \[b&gt;r_1&gt;=0\] By definition, the greater common divisor of two integer a and b (notated as gcd(a,b)), is the greater integer that divides those two numbers, this is, an integer c that satisfies: \[\frac{a}{c}, \frac{b}{c} \in \mathbb{Z}\] \[\nexists d \in \mathbb{Z} : \frac{a}{c}, \frac{b}{c} \in \mathbb{Z} \land d &gt; c\] Let's consider \(a,b \in \mathbb{Z}\) (we can safely assume that is \(a&gt;b\), otherwise \(gcd(a,b) = gcd(a,a) = a\)). Then: \[\exists (q_1,r_1) \in \mathbb{Z}^2 : a = b·q_1 + r_1\] Being \(b&gt;r_1&gt;=0\). For this same reason, it's also true that: \[\exists (q_2,r_2) \in \mathbb{Z}^2 : b = r_1·q_2 + r_2 \land b &gt; r_1 &gt; r_2 &gt;=0\] Aware that this process is finite, since the sequence \(b, r_1, r_2\), and so on are strictly positive and decremental, this \(\exists n \mathbb{N} : r_n = 0\). Since this is just an approach, we don't gonna demonstrate the generic case, although is also easy to extrapolate from a concrete case. Let's suppose that \(r_3 = 0\), thus we would have: \[a = b·q_1 + r_1 = (r_1·q_2 + r_2) + r_1 = [(r_2·q_3 + \cancel{r_3})q_2 + r_2] + r_2·q_3 + \cancel{r_3} = r_2·(q_3q_2 + 1 + q_3)\] Now is obvious that \(\frac{a}{r_2} \in \mathbb{Z}\), also is evident that \(\frac{b}{r_2} \in \mathbb{Z}\) so this number meets the first condition, it divides the two integers. Also, consider that every divisor of \(a\) and \(b\) is also divisor of the remainder: \[\forall d \in \mathbb{Z} d | a \land d | b \implies d | a \% b\] And also happens that: \[d | a \% b \implies d | b \% (a \% b)\] This means that the first remainder which is also a divisor of a and b is in fact the greatest common divisor since each other divisor also divide it for being a reminder.]]></summary></entry><entry><title type="html">Uninitialize Data Access.</title><link href="http://localhost:4000/posts/2025/12/23/UDA/" rel="alternate" type="text/html" title="Uninitialize Data Access." /><published>2025-12-23T10:00:00+01:00</published><updated>2025-12-23T10:00:00+01:00</updated><id>http://localhost:4000/posts/2025/12/23/UDA</id><content type="html" xml:base="http://localhost:4000/posts/2025/12/23/UDA/"><![CDATA[<h3 id="1-definition">1. Definition.</h3>

<h4 id="11-preface-initialize-vs-uninitialize-data">1.1. Preface. Initialize vs Uninitialize data.</h4>

<p>First, let's introduce two memory regions in which the program data-storage happens at runtime, the stack and the heap.</p>

<ul>
  <li>
    <p>The <em>stack</em> is a LIFO structure in which fixed-size data within the function stackframe's owner scope gets stored.</p>
  </li>
  <li>
    <p>The <em>heap</em> is an amount of memory available to get chunk-divided and manually allocated as required at runtime by the program generally for runtime-defined size data.</p>
  </li>
</ul>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>High addresses (0x7FFF...)
┌─────────────────────────────────┐
│                                 │
│            STACK                │
│                                 │
│   - Local variables             │
│   - Function parameters         │
│   - Return addresses            │
│   - Saved frame pointers        │
│                                 │
│      ↓ grows downward ↓         │
├─────────────────────────────────┤
│                                 │
│                                 │
│                                 │
│        (unmapped space)         │
│                                 │
│                                 │
│                                 │
├─────────────────────────────────┤
│      ↑ grows upward ↑           │
│                                 │
│            HEAP                 │
│                                 │
│   - malloc()/calloc() chunks    │
│   - Dynamic allocations         │
│   - Heap metadata               │
│                                 │
.                                 .
.                                 .
.                                 .

Low addresses (0x0000...)
</code></pre></div></div>

<p><br /></p>

<p>In the case of the stack, the allocations happens when the compiler expands the stackframe to make space for new variables by pulling the RSP register down (SUB rsp, 0x20; for example). Then it starts by copying or reading data from that expansion (MOV eax, dword ptr [rbp-4]).</p>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BEFORE: SUB rsp, 0x20             AFTER: SUB rsp, 0x20
                    
┌─────────────────────┐           ┌─────────────────────┐
│   Return Address    │           │   Return Address    │
├─────────────────────┤           ├─────────────────────┤
│     Saved RBP       │           │     Saved RBP       │
├─────────────────────┤◄─ RBP,RSP ├─────────────────────┤ ◄─ RBP
│                     │           │                     │
│                     │           │  Local Variables    │
│                     │           │     (0x20 bytes)    │
│    (unmapped)       │           │                     │
│                     │           ├─────────────────────┤ ◄─ RSP
│                     │           │                     │
│                     │           │    (unmapped)       │
└─────────────────────┘           └─────────────────────┘
Low addresses                     Low addresses

    RSP pulled down → space alloced in the stack 
</code></pre></div></div>

<p><br /></p>

<p>In the case of the heap, a manual request of x bytes of data is sent and then, a fixed-size memory chunk gets alloced and usually a pointer with the first address of this chunk is stored in the stack.</p>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BEFORE: malloc(0x20)              AFTER: malloc(0x20)

HEAP:                             HEAP:
┌─────────────────────┐           ┌─────────────────────┐
│                     │           │    Heap Metadata    │
│                     │           ├─────────────────────┤◄─ returned ptr, stored as a local variable in the stack
│   (available)       │           │                     │
│                     │           │   Allocated Chunk   │ 
│                     │           │     (0x20 bytes)    │
│                     │           │                     │
└─────────────────────┘           ├─────────────────────┤
                                  │    (available)      │
                                  └─────────────────────┘
</code></pre></div></div>

<p><br /></p>

<p>This is the way in which data gets alloced in memory at runtime when a program is executing. This essentially means that the OS reserves space for the data that is about to be stored. Observe that the stack and the heap always posees data, this means that the alloced memory regions are very likely to posees data even before to be alloced again for a reuse. The memory region which has no data placed in since it was alloced is labeled as <em>uninitialized</em>, then, when the data is placed in this is <em>initialize data</em>.</p>

<p>This distinction about data present in a memory region before use it and data written into a memory region is important to understand the vulnerability we are about to explain.</p>

<p><br /></p>

<h4 id="12-uda-definition">1.2. UDA definition.</h4>

<p>UDA, Uninitialize Data Access, is a vulnerability which arises when a program reads from memory that was allocated but never explicitly set to a known value, this is; when a program access to uninitialized data.</p>

<p>As we say before, when a program needs to write into memory it first needs to allocate space, when this space gets alloced then the program uses this memory-chunk placing data into it and once this process finish and this chunk serves no-purpouse (if the programmer has good "programming habits") this chunk gets presumibly <em>freed</em> which means that this block of data is labeled as <em>available</em> again to be recycled. However, free does not mean clear or zero-cleared, this means; the previously written data does not get erased from a freed chunk (this is called "garbage data"), is just released from the program's allocator perspective to be reused later but, in the mean while.</p>

<p>This is the key to understand this vulnerability, when a program request a memory chunk, this uninitilize structure offers data that can still be accesed, read it and retrieved.</p>

<p>Is worth to note that exploiting this kind of vulnerabilities is not trivial, since a good understanding of memory layout is needed in order to understand what is being accesed when an uninitialize variable is used as the following example shows.</p>

<p><br /></p>

<h3 id="2-examples">2. Examples.</h3>

<h4 id="21-trivial-example-1-uad1c">2.1. Trivial Example 1: uad1.c</h4>

<p>Let's consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Uninitialized Data Access 1 (stack) - uda1.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">uda_func</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"We all know that %x is leet, right?</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">acid_setter_func</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"We all know that %x is leet, right?</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x1337</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"argc = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]){</span>
        <span class="n">acid_setter_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">uda_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code doesn't have a explicty security issue (despite the Stack-Buffer Overflow in which we are not interested in) but is usefull to understand how recently used memory is accessible thorugh uninitialized data.</p>

<p>If we track the execution-flow of the code we can see that first, we declare a zero-cleared stack buffer and a signed integer.</p>

<p>Then, if the program has been executed among with a cli-parameter argument, it store that parameter within the buffer and in a apparently convoluted way, store this value in i integer. The way in which this assignation is performed ensures the control of an integer-width value.</p>

<ul>
  <li>First, take the address of buf[0].</li>
  <li>Then cast it as a pointer to an integer, this means that now, the address points to a 4-bytes width data (instead of 1 byte).</li>
  <li>Then dereference the contents of that pointer (4 bytes) and store it in <em>i</em>.</li>
</ul>

<p>Now, if buf[0] is not null, then it calls to <em>acid_setter_func()</em> which declares and initialites a variable which later is used in a printf function.</p>

<p>Later, calls <em>uda_func()</em> which barely do the same but with uninitialize data, only declares <em>i</em> and then proceeds to use it.</p>

<p>If we compile the code and execute the following binary we will get the following results:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./test AAAA
argc <span class="o">=</span> 2
We all know that 41414141 is leet, right?
We all know that 41414141 is leet, right?
</code></pre></div></div>

<p>We can see that the second line, provided by <em>uda_func()</em> is accessing the data stored in the memory allocated space for an uninitialized declared variable.</p>

<p>Is worth to note that UDA depends on a good memory layout understanding in order to comprehend what is being accesed. The reason why <em>i</em> variables holds the same value in this specific case is due to layout similarity and call-proximity in code of <em>uda_func()</em> and <em>acid_setter_func()</em> as is represented in the following diagram:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HIGHER ADDRESSES
│
▼

┌────────────────────────────────┐
│          main() frame          │
└────────────────────────────────┘


STEP 1: call acid_setter_func()

┌────────────────────────────────┐
│          main() frame          │
├────────────────────────────────┤
│    acid_setter_func() frame    │
│                                │
│    int i = 0x41414141  ← WRITE │
└────────────────────────────────┘


STEP 2: return — frame retracts

┌────────────────────────────────┐
│          main() frame          │
├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─  ┤
│                                │
│    (0x41414141 still here)     │
│                                │
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─  ┘


STEP 3: call uda_func()

┌────────────────────────────────┐
│          main() frame          │
├────────────────────────────────┤
│       uda_func() frame         │
│                                │
│    int i;          ← READ      │
│    (gets 0x41414141)           │
└────────────────────────────────┘

│
▼
LOWER ADDRESSES
</code></pre></div></div>

<p><br /></p>

<p>In order to understand it better, lets take the dissasembly for both functions:</p>

<ul>
  <li>
    <p>First, the dissasembly for <em>acid_setter_func()</em>:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>r2 <span class="nt">-e</span> asm.sub.var<span class="o">=</span><span class="nb">false</span> <span class="nt">-A</span> <span class="nt">-qc</span> <span class="s2">"aaa; s sym.acid_setter_func;pdf"</span> <span class="nb">test
  </span>Warning: run r2 with <span class="nt">-e</span> bin.cache<span class="o">=</span><span class="nb">true </span>to fix relocations <span class="k">in </span>disassembly
              <span class="p">;</span> CALL XREF from main @ 0x126c
  ┌ 53: sym.acid_setter_func <span class="o">(</span>int64_t arg1<span class="o">)</span><span class="p">;</span>
  │           <span class="p">;</span> var int64_t var_18h @ rbp-0x18
  │           <span class="p">;</span> var int64_t var_4h @ rbp-0x4
  │           <span class="p">;</span> arg int64_t arg1 @ rdi
  │           0x000011b5      f30f1efa       endbr64
  │           0x000011b9      55             push rbp
  │           0x000011ba      4889e5         mov rbp, rsp
  │           0x000011bd      4883ec20       sub rsp, 0x20
  │           0x000011c1      48897de8       mov qword <span class="o">[</span>rbp - 0x18], rdi <span class="p">;</span> arg1
  │           0x000011c5      488b45e8       mov rax, qword <span class="o">[</span>rbp - 0x18]
  │           0x000011c9      8b00           mov eax, dword <span class="o">[</span>rax]
  │           0x000011cb      8945fc         mov dword <span class="o">[</span>rbp - 4], eax
  │           0x000011ce      8b45fc         mov eax, dword <span class="o">[</span>rbp - 4]
  │           0x000011d1      89c6           mov esi, eax
  │           0x000011d3      488d052e0e00.  lea rax, str.We_all_know_that__x_is_leet__right__n <span class="p">;</span> 0x2008 <span class="p">;</span> <span class="s2">"We all know that %x is leet, right?</span><span class="se">\n</span><span class="s2">"</span>
  │           0x000011da      4889c7         mov rdi, rax                <span class="p">;</span> const char <span class="k">*</span>format
  │           0x000011dd      b800000000     mov eax, 0
  │           0x000011e2      e8a9feffff     call sym.imp.printf         <span class="p">;</span> int <span class="nb">printf</span><span class="o">(</span>const char <span class="k">*</span>format<span class="o">)</span>
  │           0x000011e7      90             nop
  │           0x000011e8      c9             leave
  └           0x000011e9      c3             ret
</code></pre></div>    </div>

    <p>We can intuit the stack layout from the stackframe prologue, it expands the stack by 0x20:</p>

    <pre><code class="language-assem">  push rbp
  mov rbp, rsp
  sub rsp, 0x20
</code></pre>

    <p>Then, since this is GCC compiler in Unix-like system, it follows System V convention, it pass rdi (parameter <em>i</em>) to the location "rbp-0x18" and from there it ends up in "rbp-4":</p>

    <pre><code class="language-assem">  mov qword [rbp - 0x18], rdi ; arg1
  mov rax, qword [rbp - 0x18]
  mov eax, dword [rax]
  mov dword [rbp - 4], eax
  mov eax, dword [rbp - 4]
</code></pre>

    <p>Lets note that when the function finish, before RET, LEAVE instruction is executed which restore stackframe, LEAVE is equivalent to:</p>

    <pre><code class="language-assem">  mov rsp, rbp    ; restore RSP to where it was before the function
  pop rbp         ; restore caller's RBP
</code></pre>
  </li>
  <li>
    <p>Lets now check the <em>uda_func()</em> dissasembly:</p>

    <pre><code class="language-assem">  $ r2 -e asm.sub.var=false -A -qc "aaa; s sym.uda_func;pdf" test
  Warning: run r2 with -e bin.cache=true to fix relocations in disassembly
              ; CALL XREF from main @ 0x1278
  ┌ 44: sym.uda_func (int64_t arg1);
  │           ; var int64_t var_18h @ rbp-0x18
  │           ; var int64_t var_4h @ rbp-0x4
  │           ; arg int64_t arg1 @ rdi
  │           0x00001189      f30f1efa       endbr64
  │           0x0000118d      55             push rbp
  │           0x0000118e      4889e5         mov rbp, rsp
  │           0x00001191      4883ec20       sub rsp, 0x20
  │           0x00001195      48897de8       mov qword [rbp - 0x18], rdi ; arg1
  │           0x00001199      8b45fc         mov eax, dword [rbp - 4]
  │           0x0000119c      89c6           mov esi, eax

  [...]
</code></pre>

    <p>The code continues but we don't need more than what we have. First, the stack expands 0x20 (the same as the previous function) and the parameter ends again in "rbp-4" to later move this to ESI (register-passed for second parameter through System V convention) to later pass it to printf() function.</p>

    <p>This means that is essentially accessing the 32-bits data which were written by the previous function. This result in an UDA vulnerability.</p>

    <p><br /></p>
  </li>
</ul>

<h4 id="22-trivial-example-2-uda2c">2.2. Trivial Example 2: uda2.c</h4>

<p>Consider now the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Uninitialized Data Access 1 (stack) - uda1.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">uda_func</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"We all know that %x is leet, right?</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">acid_setter_func</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"We all know that %x is leet, right?</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x1337</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"argc = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
                <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]){</span>
                <span class="n">acid_setter_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">uda_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code is pretty the same than above with the small difference that now <em>uda_func()</em> is returning <em>i</em> and this value is being implemented as the len parameter of a memcpy() call.</p>

<p>Now is easy to understand that this suppose a bigger danger than the previous example.</p>

<p>Following the flow explained in the example above, the user-controlled data set in memory by <em>acid_setter_func()</em> is then retrieved by <em>uda_func()</em> and placed in a memcpy() operation potentially triggering a SBO.</p>

<p><br /></p>

<h4 id="23-trivial-example-3-heapc">2.3. Trivial Example 3. Heap.c</h4>

<p>Consider now the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Uninitialized Data Access 2 (heap) - uda2.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="cp">#define BUF_SIZE 1024
</span>
<span class="kt">void</span> <span class="nf">opt_realloc</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span> <span class="n">buf1</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">buf2</span><span class="p">){</span>
    <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">buf1</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">buf2</span><span class="p">);</span>
    <span class="o">*</span><span class="n">buf2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">);</span> <span class="c1">//XENO: Note, I switched the order of allocs</span>
    <span class="o">*</span><span class="n">buf1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">);</span> <span class="c1">//XENO: This was based on system-specific knowledge</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"buf1 addr = %p, buf2 addr = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">buf1</span><span class="p">,</span> <span class="o">*</span><span class="n">buf2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">buf1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">buf2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">buf1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"buf1 addr = %p, buf2 addr = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf1</span><span class="p">,</span> <span class="n">buf2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"argc = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">buf2</span><span class="p">,</span> <span class="sc">'!'</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">buf1</span><span class="p">[</span><span class="mi">0</span><span class="p">]){</span>
        <span class="n">opt_realloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"At %p+%d:</span><span class="se">\t</span><span class="s"> %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">buf2</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"At %p+%d:</span><span class="se">\t</span><span class="s"> %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"At the end of the day, the important thing is: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf1</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This time we are involving heap-memory region.</p>

<p>First, we define two pointers to which we assignate a memory chunk with malloc:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span> <span class="n">buf1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">buf2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">);</span>
</code></pre></div></div>

<p>Then we cast <em>buf1</em> to pointer to a integer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">buf1</span><span class="p">;</span>
</code></pre></div></div>

<p>And if we, along with the program, pass a cli-parameter, then the buffer gets fulfilled amd then we call the opt_realloc() function which is a wrapper around malloc in which we free a pointer and then alloc and assign a memory chunk to this pointer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">opt_realloc</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span> <span class="n">buf1</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">buf2</span><span class="p">){</span>
    <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">buf1</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">buf2</span><span class="p">);</span>
    <span class="o">*</span><span class="n">buf2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">);</span> <span class="c1">//XENO: Note, I switched the order of allocs</span>
    <span class="o">*</span><span class="n">buf1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">);</span> <span class="c1">//XENO: This was based on system-specific knowledge</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"buf1 addr = %p, buf2 addr = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">buf1</span><span class="p">,</span> <span class="o">*</span><span class="n">buf2</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//...</span>
<span class="k">if</span><span class="p">(</span><span class="n">buf1</span><span class="p">[</span><span class="mi">0</span><span class="p">]){</span>
    <span class="n">opt_realloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Due to how the system behaves, in this case once you free a memroy chunk and inmediately assign it, you have assigned the same memory chunk as before, this means that, despite gets realloced, <em>buf1</em> and <em>buf2</em> has no changed at this point.</p>

<p>Then, we simply read from this uninitialized structures:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"At %p+%d:</span><span class="se">\t</span><span class="s"> %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">buf2</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"At %p+%d:</span><span class="se">\t</span><span class="s"> %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"At the end of the day, the important thing is: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf1</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<p>Reach this point, if we compile the binary and execute it we obtain the following output:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./test "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
buf1 addr = 0x581a809a32a0, buf2 addr = 0x581a809a36b0
argc = 2
buf1 addr = 0x581a809a32a0, buf2 addr = 0x581a809a36b0
At 0x581a809a32a0+0:     81a809a3
At 0x581a809a32a0+4:     5
At 0x581a809a32a0+8:     0
At 0x581a809a32a0+12:    0         ; Some of the previous data gets has been erased
At 0x581a809a32a0+16:    41414141  ; AAAA
At 0x581a809a32a0+20:    41414141
At 0x581a809a32a0+24:    41414141
At 0x581a809a32a0+28:    41414141
At 0x581a809a32a0+32:    41414141
At 0x581a809a32a0+36:    41414141
At 0x581a809a32a0+40:    41414141
At 0x581a809a32a0+44:    41414141
At 0x581a809a32a0+48:    41414141

At 0x581a809a36b0+0:     1323b03
At 0x581a809a36b0+4:     581f
At 0x581a809a36b0+8:     0
At 0x581a809a36b0+12:    0
At 0x581a809a36b0+16:    21212121
At 0x581a809a36b0+20:    21212121
At 0x581a809a36b0+24:    21212121
At 0x581a809a36b0+28:    21212121
At 0x581a809a36b0+32:    21212121
At 0x581a809a36b0+36:    21212121
At 0x581a809a36b0+40:    21212121
At 0x581a809a36b0+44:    21212121
At 0x581a809a36b0+48:    21212121
At the end of the day, the important thing is: 41414141
</code></pre></div></div>

<p>We can see that, despite being both buffer freed, the previous allocated data still accesible, this is essentially an UDA vulnerability.</p>

<p><br /></p>

<h3 id="3-common-roots">3. Common Roots.</h3>

<p>Among the common causes that leads to a UDA vulnerability are:</p>

<ul>
  <li>Not initializing local variables at declaration time.</li>
  <li>No initializing heap data at allocation time.</li>
  <li>Only partially initializing structs &amp; objects.</li>
  <li>Accidental failure to initialize down an uncommon control flow path.</li>
</ul>

<p>If a codebase uses a lot function pointers / callbacks / indirect control flow, it is far more difficult for a human auditor to confidently assess. In such cases tooling and automated analysis (e.g. MemorySanitizer and/or a Fuzzer) should be brought to bear.</p>

<p><br /></p>

<h3 id="4-exercises">4. Exercises.</h3>

<h4 id="41-cve-2022-1809">4.1. CVE-2022-1809.</h4>

<p>Radare2 is a reverse engineering tool, often used to analyze potentially-malicious binaries such as malware, therefore all values that come from the binary need to be treated as ACID.</p>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="c1">//XENO: Structure that isn't completely initialized</span>
<span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="cm">/* vtables */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">RAnal</span> <span class="o">*</span><span class="n">anal</span><span class="p">;</span>
	<span class="n">RAnalCPPABI</span> <span class="n">abi</span><span class="p">;</span>
	<span class="n">ut8</span> <span class="n">word_size</span><span class="p">;</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">read_addr</span><span class="p">)</span> <span class="p">(</span><span class="n">RAnal</span> <span class="o">*</span><span class="n">anal</span><span class="p">,</span> <span class="n">ut64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ut64</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span> <span class="n">RVTableContext</span><span class="p">;</span>

<span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="c1">//XENO: Part of the path where incomplete initialized occurs</span>
<span class="c1">//////////////////////////////////////////////////////////////////////</span>

<span class="c1">//XENO: assume the following fields are ACID based on a malicious ACID binary under analysis:</span>
<span class="c1">//XENO: anal-&gt;config-&gt;bits, anal-&gt;cur-&gt;arch</span>

<span class="n">R_API</span> <span class="n">bool</span> <span class="nf">r_anal_vtable_begin</span><span class="p">(</span><span class="n">RAnal</span> <span class="o">*</span><span class="n">anal</span><span class="p">,</span> <span class="n">RVTableContext</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">anal</span> <span class="o">=</span> <span class="n">anal</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">abi</span> <span class="o">=</span> <span class="n">anal</span><span class="o">-&gt;</span><span class="n">cxxabi</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ut8</span><span class="p">)</span> <span class="p">(</span><span class="n">anal</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">is_arm</span> <span class="o">=</span> <span class="n">anal</span><span class="o">-&gt;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">arch</span> <span class="o">&amp;&amp;</span> <span class="n">r_str_startswith</span> <span class="p">(</span><span class="n">anal</span><span class="o">-&gt;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">,</span> <span class="s">"arm"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_arm</span> <span class="o">&amp;&amp;</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">be</span> <span class="o">=</span> <span class="n">anal</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">big_endian</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">read_addr</span> <span class="o">=</span> <span class="n">be</span><span class="o">?</span> <span class="n">vtable_read_addr_be8</span> <span class="o">:</span> <span class="n">vtable_read_addr_le8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">read_addr</span> <span class="o">=</span> <span class="n">be</span><span class="o">?</span> <span class="n">vtable_read_addr_be16</span> <span class="o">:</span> <span class="n">vtable_read_addr_le16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">read_addr</span> <span class="o">=</span> <span class="n">be</span><span class="o">?</span> <span class="n">vtable_read_addr_be32</span> <span class="o">:</span> <span class="n">vtable_read_addr_le32</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span><span class="p">:</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">read_addr</span> <span class="o">=</span> <span class="n">be</span><span class="o">?</span> <span class="n">vtable_read_addr_be64</span> <span class="o">:</span> <span class="n">vtable_read_addr_le64</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="c1">//XENO: Part of the path where uninitialized access occurs eventually</span>
<span class="c1">//////////////////////////////////////////////////////////////////////</span>


<span class="n">R_API</span> <span class="kt">void</span> <span class="nf">r_anal_list_vtables</span><span class="p">(</span><span class="n">RAnal</span> <span class="o">*</span><span class="n">anal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rad</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">RVTableContext</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">r_anal_vtable_begin</span> <span class="p">(</span><span class="n">anal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">noMethodName</span> <span class="o">=</span> <span class="s">"No Name found"</span><span class="p">;</span>
	<span class="n">RVTableMethodInfo</span> <span class="o">*</span><span class="n">curMethod</span><span class="p">;</span>
	<span class="n">RListIter</span> <span class="o">*</span><span class="n">vtableIter</span><span class="p">;</span>
	<span class="n">RVTableInfo</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

	<span class="n">RList</span> <span class="o">*</span><span class="n">vtables</span> <span class="o">=</span> <span class="n">r_anal_vtable_search</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
<span class="c1">//XENO: snip</span>
<span class="p">}</span>

<span class="n">R_API</span> <span class="n">RList</span> <span class="o">*</span><span class="nf">r_anal_vtable_search</span><span class="p">(</span><span class="n">RVTableContext</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">RAnal</span> <span class="o">*</span><span class="n">anal</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">anal</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anal</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RList</span> <span class="o">*</span><span class="n">vtables</span> <span class="o">=</span> <span class="n">r_list_newf</span> <span class="p">((</span><span class="n">RListFree</span><span class="p">)</span><span class="n">r_anal_vtable_info_free</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vtables</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RList</span> <span class="o">*</span><span class="n">sections</span> <span class="o">=</span> <span class="n">anal</span><span class="o">-&gt;</span><span class="n">binb</span><span class="p">.</span><span class="n">get_sections</span> <span class="p">(</span><span class="n">anal</span><span class="o">-&gt;</span><span class="n">binb</span><span class="p">.</span><span class="n">bin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sections</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r_list_free</span> <span class="p">(</span><span class="n">vtables</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r_cons_break_push</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">RListIter</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="n">RBinSection</span> <span class="o">*</span><span class="n">section</span><span class="p">;</span>
	<span class="n">r_list_foreach</span> <span class="p">(</span><span class="n">sections</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r_cons_is_breaked</span> <span class="p">())</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vtable_section_can_contain_vtables</span> <span class="p">(</span><span class="n">section</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ut64</span> <span class="n">startAddress</span> <span class="o">=</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">;</span>
		<span class="n">ut64</span> <span class="n">endAddress</span> <span class="o">=</span> <span class="n">startAddress</span> <span class="o">+</span> <span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">vsize</span><span class="p">)</span> <span class="o">-</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
		<span class="n">ut64</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">endAddress</span> <span class="o">-</span> <span class="n">startAddress</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">&gt;</span> <span class="n">ST32_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">startAddress</span> <span class="o">&lt;=</span> <span class="n">endAddress</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r_cons_is_breaked</span> <span class="p">())</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anal</span><span class="o">-&gt;</span><span class="n">iob</span><span class="p">.</span><span class="n">is_valid_offset</span> <span class="p">(</span><span class="n">anal</span><span class="o">-&gt;</span><span class="n">iob</span><span class="p">.</span><span class="n">io</span><span class="p">,</span> <span class="n">startAddress</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vtable_is_addr_vtable_start</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">startAddress</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">RVTableInfo</span> <span class="o">*</span><span class="n">vtable</span> <span class="o">=</span> <span class="n">r_anal_vtable_parse_at</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">startAddress</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vtable</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">r_list_append</span> <span class="p">(</span><span class="n">vtables</span><span class="p">,</span> <span class="n">vtable</span><span class="p">);</span>
					<span class="n">ut64</span> <span class="n">size</span> <span class="o">=</span> <span class="n">r_anal_vtable_info_get_size</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">vtable</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">startAddress</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">startAddress</span> <span class="o">+=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="c1">//XENO: snip</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">vtable_is_addr_vtable_start</span><span class="p">(</span><span class="n">RVTableContext</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="n">RBinSection</span> <span class="o">*</span><span class="n">section</span><span class="p">,</span> <span class="n">ut64</span> <span class="n">curAddress</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">abi</span> <span class="o">==</span> <span class="n">R_ANAL_CPP_ABI_MSVC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">vtable_is_addr_vtable_start_msvc</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">curAddress</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">abi</span> <span class="o">==</span> <span class="n">R_ANAL_CPP_ABI_ITANIUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">vtable_is_addr_vtable_start_itanium</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">curAddress</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">r_return_val_if_reached</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">vtable_is_addr_vtable_start_msvc</span><span class="p">(</span><span class="n">RVTableContext</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="n">ut64</span> <span class="n">curAddress</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">RAnalRef</span> <span class="o">*</span><span class="n">xref</span><span class="p">;</span>
	<span class="n">RListIter</span> <span class="o">*</span><span class="n">xrefIter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curAddress</span> <span class="o">||</span> <span class="n">curAddress</span> <span class="o">==</span> <span class="n">UT64_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curAddress</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vtable_is_value_in_text_section</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">curAddress</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="c1">//XENO: snip</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">vtable_is_value_in_text_section</span><span class="p">(</span><span class="n">RVTableContext</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="n">ut64</span> <span class="n">curAddress</span><span class="p">,</span> <span class="n">ut64</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//value at the current address</span>
	<span class="n">ut64</span> <span class="n">curAddressValue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">read_addr</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">anal</span><span class="p">,</span> <span class="n">curAddress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curAddressValue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//if the value is in text section</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">vtable_addr_in_text_section</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">curAddressValue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">curAddressValue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<p>Let's reorganize de code to understand it better:</p>

<ul>
  <li>
    <p>First, <em>r_anal_list_vtables()</em> calls both <em>r_anal_vtable_begin()</em> which initializes the previously declared variable <em>context</em> and <em>r_anal_vtable_search()</em> also with <em>context</em> passed as parameter. Let's observe that the parameter <em>anal-&gt;config-&gt;bits</em> is user-controlled, and thus, <em>context-&gt;word_size</em> also is and due to this, there is a margin in which the <em>read_addr</em> field does not get initialized:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">R_API</span> <span class="n">bool</span> <span class="nf">r_anal_vtable_begin</span><span class="p">(</span><span class="n">RAnal</span> <span class="o">*</span><span class="n">anal</span><span class="p">,</span> <span class="n">RVTableContext</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">context</span><span class="o">-&gt;</span><span class="n">anal</span> <span class="o">=</span> <span class="n">anal</span><span class="p">;</span>
  <span class="n">context</span><span class="o">-&gt;</span><span class="n">abi</span> <span class="o">=</span> <span class="n">anal</span><span class="o">-&gt;</span><span class="n">cxxabi</span><span class="p">;</span>
  <span class="n">context</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ut8</span><span class="p">)</span> <span class="p">(</span><span class="n">anal</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
  <span class="c1">//...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//Depending on the case, context-&gt;read_addr get assigned a value except in default case.</span>
  <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">R_API</span> <span class="kt">void</span> <span class="nf">r_anal_list_vtables</span><span class="p">(</span><span class="n">RAnal</span> <span class="o">*</span><span class="n">anal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rad</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">RVTableContext</span> <span class="n">context</span><span class="p">;</span>
  <span class="n">r_anal_vtable_begin</span> <span class="p">(</span><span class="n">anal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
  <span class="c1">//...</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Then, <em>r_anal_vtable_search()</em> calls <em>vtable_is_addr_vtable_start()</em> which calls <em>vtable_is_addr_vtable_start_msvc()</em> as well and this one to <em>vtable_is_value_in_text_section()</em> which attemps to read from <em>context-&gt;read_addr</em>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">static</span> <span class="n">bool</span> <span class="nf">vtable_is_value_in_text_section</span><span class="p">(</span><span class="n">RVTableContext</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="n">ut64</span> <span class="n">curAddress</span><span class="p">,</span> <span class="n">ut64</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//value at the current address</span>
  <span class="n">ut64</span> <span class="n">curAddressValue</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">read_addr</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">anal</span><span class="p">,</span> <span class="n">curAddress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curAddressValue</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//...</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>This is an unintialized memory region being readed, leading to Uninitialized Data Access vulnerability.</p>

<p><br /></p>

<h4 id="42-cve-2021-3608">4.2. CVE-2021-3608.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="c1">//XENO: Structure that isn't completely initialized</span>
<span class="c1">//////////////////////////////////////////////////////////////////////</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">PvrdmaRing</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_RING_NAME_SZ</span><span class="p">];</span>
    <span class="n">PCIDevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">max_elems</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">elem_sz</span><span class="p">;</span>
    <span class="n">PvrdmaRingState</span> <span class="o">*</span><span class="n">ring_state</span><span class="p">;</span> <span class="cm">/* used only for unmap */</span>
    <span class="kt">int</span> <span class="n">npages</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PvrdmaRing</span><span class="p">;</span>

<span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="c1">//XENO: Part of the path where incomplete initialized occurs AND uninitialized usage occurs</span>
<span class="c1">//////////////////////////////////////////////////////////////////////</span>

<span class="c1">//XENO: Assume dir_addr and num_pages are ACID</span>
<span class="c1">//XENO: And assume that if the 2nd argument to rdma_pci_dma_map() is ACID</span>
<span class="c1">//XENO: then it's basically just mapping more ACID data/structs into memory</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_dev_ring</span><span class="p">(</span><span class="n">PvrdmaRing</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="n">PvrdmaRingState</span> <span class="o">**</span><span class="n">ring_state</span><span class="p">,</span>
                         <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PCIDevice</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span>
                         <span class="n">dma_addr_t</span> <span class="n">dir_addr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">num_pages</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">dir</span> <span class="o">=</span> <span class="n">rdma_pci_dma_map</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">dir_addr</span><span class="p">,</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rdma_error_report</span><span class="p">(</span><span class="s">"Failed to map to page directory (ring %s)"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">tbl</span> <span class="o">=</span> <span class="n">rdma_pci_dma_map</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbl</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rdma_error_report</span><span class="p">(</span><span class="s">"Failed to map to page table (ring %s)"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out_free_dir</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">ring_state</span> <span class="o">=</span> <span class="n">rdma_pci_dma_map</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">tbl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">ring_state</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rdma_error_report</span><span class="p">(</span><span class="s">"Failed to map to ring state (ring %s)"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out_free_tbl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* RX ring is the second */</span>
    <span class="p">(</span><span class="o">*</span><span class="n">ring_state</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">pvrdma_ring_init</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">,</span>
                          <span class="p">(</span><span class="n">PvrdmaRingState</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">ring_state</span><span class="p">,</span>
                          <span class="p">(</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">TARGET_PAGE_SIZE</span> <span class="o">/</span>
                          <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvrdma_cqne</span><span class="p">),</span>
                          <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvrdma_cqne</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">dma_addr_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tbl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out_free_ring_state</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">goto</span> <span class="n">out_free_tbl</span><span class="p">;</span>

<span class="nl">out_free_ring_state:</span>
    <span class="n">rdma_pci_dma_unmap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="o">*</span><span class="n">ring_state</span><span class="p">,</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>

<span class="nl">out_free_tbl:</span>
    <span class="n">rdma_pci_dma_unmap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">tbl</span><span class="p">,</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>

<span class="nl">out_free_dir:</span>
    <span class="n">rdma_pci_dma_unmap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>

<span class="nl">out:</span>
    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pvrdma_ring_init</span><span class="p">(</span><span class="n">PvrdmaRing</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PCIDevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                     <span class="n">PvrdmaRingState</span> <span class="o">*</span><span class="n">ring_state</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">max_elems</span><span class="p">,</span>
                     <span class="kt">size_t</span> <span class="n">elem_sz</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">pstrcpy</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">MAX_RING_NAME_SZ</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="n">ring</span><span class="o">-&gt;</span><span class="n">ring_state</span> <span class="o">=</span> <span class="n">ring_state</span><span class="p">;</span>
    <span class="n">ring</span><span class="o">-&gt;</span><span class="n">max_elems</span> <span class="o">=</span> <span class="n">max_elems</span><span class="p">;</span>
    <span class="n">ring</span><span class="o">-&gt;</span><span class="n">elem_sz</span> <span class="o">=</span> <span class="n">elem_sz</span><span class="p">;</span>
    <span class="cm">/* TODO: Give a moment to think if we want to redo driver settings
    qatomic_set(&amp;ring-&gt;ring_state-&gt;prod_tail, 0);
    qatomic_set(&amp;ring-&gt;ring_state-&gt;cons_head, 0);
    */</span>
    <span class="n">ring</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
    <span class="n">ring</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">g_malloc</span><span class="p">(</span><span class="n">npages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span> <span class="c1">//XENO: array of npages pointers</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbl</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">rdma_error_report</span><span class="p">(</span><span class="s">"npages=%d but tbl[%d] is NULL"</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ring</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdma_pci_dma_map</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tbl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
            <span class="n">rdma_error_report</span><span class="p">(</span><span class="s">"Failed to map to page %d in ring %s"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out_free:</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rdma_pci_dma_unmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">TARGET_PAGE_SIZE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">g_free</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>

<span class="nl">out:</span>
    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let's observe that <em>dir_addr</em> being user-controlled implies <em>tbl</em> being user-controlled (along with <em>num_pages</em>) which both are passed as parameters to <em>pvrdma_ring_init()</em></p>

<p>In this function, <em>num_pages</em> assumes the form of <em>npages</em> and <em>tbl</em> as <em>tbl</em> pointer, as two separate user-controller values, and there exists the following loop:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbl</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">rdma_error_report</span><span class="p">(</span><span class="s">"npages=%d but tbl[%d] is NULL"</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//...</span>
</code></pre></div></div>

<p>Observe that there are checking the same number of <em>tbl</em> entries and <em>npages</em>, however, since this two values are user-controlled, eventually a huge <em>npages</em> value and a small <em>tbl</em> array can lead to the program try to access undefenied, not-initialize, <em>tbl</em> entires, leading to Uninitialize Data Access vulnerability.</p>

<p><br /></p>

<h4 id="43-cve-2022-26712">4.3. CVE-2022-26712.</h4>

<p>Processes on macOS and iOS can use XPC (Mac OS X inter-Process Communication) to send data between each other. XPC (cross-process communication) is Apple's IPC mechanism for communication between processes, heavily used for privilege separation. When you send a message via XPC, you're crossing process boundaries—different address spaces—so the data must be serialized (convert data to a stream of bytes to be reconstructed later).</p>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xpc_object_t</span> <span class="n">content</span> <span class="o">=</span> <span class="n">xpc_dictionary_get_value</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="s">"source"</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">xpc_array_get_count</span><span class="p">(</span><span class="n">content</span><span class="p">);</span> <span class="c1">//XENO: count SACI, based on number of array elements sent</span>
<span class="kt">size_t</span> <span class="o">*</span><span class="n">descriptors</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="o">*</span><span class="n">accessBeginPointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">count</span> <span class="o">*</span> <span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">accessDataLength</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">count</span> <span class="o">*</span> <span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">mappedBaseAddress</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">mappedLength</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">count</span> <span class="o">*</span> <span class="mi">3</span><span class="p">];</span>

<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">accessBeginPointer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">accessDataLength</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mappedBaseAddress</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mappedLength</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">xpc_object_t</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">xpc_array_get_value</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">xpc_get_type</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">==</span> <span class="n">XPC_TYPE_DATA</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">xpc_get_type</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">==</span> <span class="n">XPC_TYPE_SHMEM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">xpc_object_t</span> <span class="n">map</span> <span class="o">=</span> <span class="n">xpc_array_get_value</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">xpc_array_get_uint64</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mh">0xFFF</span><span class="p">),</span> <span class="c1">//XENO: offset SACI</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">xpc_array_get_uint64</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>                      <span class="c1">//XENO: size ACID</span>

    <span class="kt">size_t</span> <span class="n">mapped_address</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">mapped_size</span> <span class="o">=</span> <span class="n">xpc_shmem_map</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapped_address</span><span class="p">);</span>   <span class="c1">//XENO: mapped_size ACID</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">mapped_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="c1">// cleanup</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mappedLength</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">munmap</span><span class="p">(</span><span class="n">mappedBaseAddress</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">mappedLength</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">free</span><span class="p">(</span><span class="n">descriptors</span><span class="p">);</span>
</code></pre></div></div>

<p>Lets observe the following line:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="o">*</span><span class="n">descriptors</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div></div>

<p>Considering that count is in some form user-controlled and integer overflow can be present in the mathematic operation within the malloc passed parameter leading to an underallocation for <em>descriptor</em> pointer.</p>

<p>Then, some pointers are defined through <em>descriptor</em> pointer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="o">*</span><span class="n">accessBeginPointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">count</span> <span class="o">*</span> <span class="mi">0</span><span class="p">],</span> 
        <span class="o">*</span><span class="n">accessDataLength</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">count</span> <span class="o">*</span> <span class="mi">1</span><span class="p">],</span> 
        <span class="o">*</span><span class="n">mappedBaseAddress</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> 
        <span class="o">*</span><span class="n">mappedLength</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descriptors</span><span class="p">[</span><span class="n">count</span> <span class="o">*</span> <span class="mi">3</span><span class="p">];</span> <span class="c1">//&lt;-- Interesting</span>
</code></pre></div></div>

<p>Observe that, despite some assignations are being made, the descriptors pointer still not-initialize memery regions.</p>

<p>Thus, below, in the for loop, since count is a big value, eventually Out-Of-Bounds write and read happens:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mappedLength</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">//...</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="44-cve-2022-29968">4.4. CVE-2022-29968.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="c1">//XENO: Structure that isn't completely initialized</span>
<span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="k">struct</span> <span class="n">io_kiocb</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_rw</span>		<span class="n">rw</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_poll_iocb</span>	<span class="n">poll</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_poll_update</span>	<span class="n">poll_update</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_accept</span>	<span class="n">accept</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_sync</span>		<span class="n">sync</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_cancel</span>	<span class="n">cancel</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_timeout</span>	<span class="n">timeout</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_timeout_rem</span>	<span class="n">timeout_rem</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_connect</span>	<span class="n">connect</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_sr_msg</span>	<span class="n">sr_msg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_open</span>		<span class="n">open</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_close</span>		<span class="n">close</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_rsrc_update</span>	<span class="n">rsrc_update</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_fadvise</span>	<span class="n">fadvise</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_madvise</span>	<span class="n">madvise</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_epoll</span>		<span class="n">epoll</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_splice</span>	<span class="n">splice</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_provide_buf</span>	<span class="n">pbuf</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_statx</span>		<span class="n">statx</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_shutdown</span>	<span class="n">shutdown</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_rename</span>	<span class="n">rename</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_unlink</span>	<span class="n">unlink</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_mkdir</span>		<span class="n">mkdir</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_symlink</span>	<span class="n">symlink</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_hardlink</span>	<span class="n">hardlink</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">io_msg</span>		<span class="n">msg</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">u8</span>				<span class="n">opcode</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">iopoll_completed</span><span class="p">;</span>
	<span class="n">u16</span>				<span class="n">buf_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">flags</span><span class="p">;</span>

	<span class="n">u64</span>				<span class="n">user_data</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">result</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span>			<span class="n">cflags</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">fd</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">io_ring_ctx</span>		<span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>		<span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">percpu_ref</span>		<span class="o">*</span><span class="n">fixed_rsrc_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_mapped_ubuf</span>		<span class="o">*</span><span class="n">imu</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">io_wq_work_node</span>	<span class="n">comp_list</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">apoll_events</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">atomic_t</span>			<span class="n">refs</span><span class="p">;</span>
	<span class="n">atomic_t</span>			<span class="n">poll_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_task_work</span>		<span class="n">io_task_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>		<span class="n">hash_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">async_poll</span>		<span class="o">*</span><span class="n">apoll</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">async_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_buffer</span>		<span class="o">*</span><span class="n">kbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_kiocb</span>			<span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span>		<span class="o">*</span><span class="n">creds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_wq_work</span>		<span class="n">work</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="c1">//XENO: Part of the path where incomplete initialization occurs</span>
<span class="c1">//////////////////////////////////////////////////////////////////////</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">io_rw_init_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rw</span><span class="p">.</span><span class="n">kiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_ring_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">file</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">mode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req_ffs_set</span><span class="p">(</span><span class="n">req</span><span class="p">))</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">io_file_get_flags</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">REQ_F_SUPPORT_NOWAIT_BIT</span><span class="p">;</span>

	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">=</span> <span class="n">iocb_flags</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kiocb_set_rw_flags</span><span class="p">(</span><span class="n">kiocb</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rw</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_NOWAIT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">io_file_supports_nowait</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REQ_F_NOWAIT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORING_SETUP_IOPOLL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_DIRECT</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">iopoll</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

		<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">|=</span> <span class="n">IOCB_HIPRI</span> <span class="o">|</span> <span class="n">IOCB_ALLOC_CACHE</span><span class="p">;</span>
		<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_complete</span> <span class="o">=</span> <span class="n">io_complete_rw_iopoll</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">iopoll_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_HIPRI</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_complete</span> <span class="o">=</span> <span class="n">io_complete_rw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">io_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">issue_flags</span><span class="p">){</span>
	<span class="k">struct</span> <span class="n">io_rw_state</span> <span class="n">__s</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iovec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rw</span><span class="p">.</span><span class="n">kiocb</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">force_nonblock</span> <span class="o">=</span> <span class="n">issue_flags</span> <span class="o">&amp;</span> <span class="n">IO_URING_F_NONBLOCK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_async_rw</span> <span class="o">*</span><span class="n">rw</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req_has_async_data</span><span class="p">(</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">io_import_iovec</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iovec</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">issue_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REQ_F_BUFFER_SELECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">io_import_iovec</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iovec</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">issue_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rw</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">async_data</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">;</span>
		<span class="n">iov_iter_restore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter_state</span><span class="p">);</span>
		<span class="n">iovec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">io_rw_init_file</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">FMODE_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iovec</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">iov_iter_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">force_nonblock</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">io_file_supports_nowait</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">io_setup_async_rw</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">iovec</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span> <span class="o">?:</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">|=</span> <span class="n">IOCB_NOWAIT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOCB_NOWAIT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ppos</span> <span class="o">=</span> <span class="n">io_kiocb_update_pos</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rw_verify_area</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iovec</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">io_iter_do_read</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REQ_F_REISSUE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REQ_F_REISSUE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">IORING_OP_READ</span> <span class="o">&amp;&amp;</span> <span class="n">file_can_poll</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force_nonblock</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORING_SETUP_IOPOLL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REQ_F_NOWAIT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">force_nonblock</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REQ_F_NOWAIT</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">need_read_all</span><span class="p">(</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iov_iter_restore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter_state</span><span class="p">);</span>

	<span class="n">ret2</span> <span class="o">=</span> <span class="n">io_setup_async_rw</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">iovec</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="n">iovec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rw</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">async_data</span><span class="p">;</span>
	<span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">iov_iter_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">rw</span><span class="o">-&gt;</span><span class="n">bytes_done</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">iov_iter_save_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter_state</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_rw_should_retry</span><span class="p">(</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOCB_WAITQ</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">io_iter_do_read</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOCB_WAITQ</span><span class="p">;</span>
		<span class="n">iov_iter_restore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">iter_state</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">kiocb_done</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">issue_flags</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iovec</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iovec</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//////////////////////////////////////////////////////////////////////</span>
<span class="c1">//XENO: Part of the path where uninitialized access occurs eventually</span>
<span class="c1">//////////////////////////////////////////////////////////////////////</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">io_do_iopoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_ring_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force_nonspin</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_wq_work_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">poll_flags</span> <span class="o">=</span> <span class="n">BLK_POLL_NOSLEEP</span><span class="p">;</span>
	<span class="n">DEFINE_IO_COMP_BATCH</span><span class="p">(</span><span class="n">iob</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nr_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">poll_multi_queue</span> <span class="o">||</span> <span class="n">force_nonspin</span><span class="p">)</span>
		<span class="n">poll_flags</span> <span class="o">|=</span> <span class="n">BLK_POLL_ONESHOT</span><span class="p">;</span>

	<span class="n">wq_list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">iopoll_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">io_kiocb</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_kiocb</span><span class="p">,</span> <span class="n">comp_list</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rw</span><span class="p">.</span><span class="n">kiocb</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">iopoll_completed</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">iopoll</span><span class="p">(</span><span class="n">kiocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iob</span><span class="p">,</span> <span class="n">poll_flags</span><span class="p">);</span> <span class="c1">//XENO: This calls iocb_bio_iopoll</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">poll_flags</span> <span class="o">|=</span> <span class="n">BLK_POLL_ONESHOT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq_list_empty</span><span class="p">(</span><span class="n">iob</span><span class="p">.</span><span class="n">req_list</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">iopoll_completed</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq_list_empty</span><span class="p">(</span><span class="n">iob</span><span class="p">.</span><span class="n">req_list</span><span class="p">))</span>
		<span class="n">iob</span><span class="p">.</span><span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iob</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">wq_list_for_each_resume</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">io_kiocb</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_kiocb</span><span class="p">,</span> <span class="n">comp_list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp_load_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">iopoll_completed</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">nr_events</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REQ_F_CQE_SKIP</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">__io_fill_cqe_req</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span> <span class="n">io_put_kbuf</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nr_events</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">io_commit_cqring</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">io_cqring_ev_posted_iopoll</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">start</span> <span class="o">?</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">:</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">iopoll_list</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
	<span class="n">wq_list_cut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">iopoll_list</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">io_free_batch_list</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nr_events</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">iocb_bio_iopoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_comp_batch</span> <span class="o">*</span><span class="n">iob</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">bio</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">&amp;&amp;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_poll</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">iob</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bio_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_comp_batch</span> <span class="o">*</span><span class="n">iob</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="n">blk_qc_t</span> <span class="n">cookie</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_cookie</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cookie</span> <span class="o">==</span> <span class="n">BLK_QC_T_NONE</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">QUEUE_FLAG_POLL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">blk_flush_plug</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">plug</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_enter</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">BLK_MQ_REQ_NOWAIT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_is_mq</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">blk_mq_poll</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">iob</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">disk</span> <span class="o">&amp;&amp;</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">poll_bio</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">poll_bio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">iob</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">blk_queue_exit</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Check that the code that attempts to initialize <em>struct kiocb *kiocb</em> struct by the function <em>io_rw_init_file()</em>, and later in <em>iocb_bio_iopoll()</em> attempts to use <em>kiocb-&gt;private</em> field which is uninitialize, thus <em>bio</em> now has uninitilize data and barely all the operations performed with <em>bio</em> in *bio_poll() *are dangerous and potentially vulnerable since the code is making decisions with undefined data.</p>

<p><br /></p>]]></content><author><name>German Sanmi</name></author><category term="Past Blogs" /><category term="Binary Exploitation" /><category term="memory-corruption" /><category term="exploits" /><summary type="html"><![CDATA[1. Definition. 1.1. Preface. Initialize vs Uninitialize data. First, let's introduce two memory regions in which the program data-storage happens at runtime, the stack and the heap. The stack is a LIFO structure in which fixed-size data within the function stackframe's owner scope gets stored. The heap is an amount of memory available to get chunk-divided and manually allocated as required at runtime by the program generally for runtime-defined size data. High addresses (0x7FFF...) ┌─────────────────────────────────┐ │ │ │ STACK │ │ │ │ - Local variables │ │ - Function parameters │ │ - Return addresses │ │ - Saved frame pointers │ │ │ │ ↓ grows downward ↓ │ ├─────────────────────────────────┤ │ │ │ │ │ │ │ (unmapped space) │ │ │ │ │ │ │ ├─────────────────────────────────┤ │ ↑ grows upward ↑ │ │ │ │ HEAP │ │ │ │ - malloc()/calloc() chunks │ │ - Dynamic allocations │ │ - Heap metadata │ │ │ . . . . . . Low addresses (0x0000...) In the case of the stack, the allocations happens when the compiler expands the stackframe to make space for new variables by pulling the RSP register down (SUB rsp, 0x20; for example). Then it starts by copying or reading data from that expansion (MOV eax, dword ptr [rbp-4]). BEFORE: SUB rsp, 0x20 AFTER: SUB rsp, 0x20 ┌─────────────────────┐ ┌─────────────────────┐ │ Return Address │ │ Return Address │ ├─────────────────────┤ ├─────────────────────┤ │ Saved RBP │ │ Saved RBP │ ├─────────────────────┤◄─ RBP,RSP ├─────────────────────┤ ◄─ RBP │ │ │ │ │ │ │ Local Variables │ │ │ │ (0x20 bytes) │ │ (unmapped) │ │ │ │ │ ├─────────────────────┤ ◄─ RSP │ │ │ │ │ │ │ (unmapped) │ └─────────────────────┘ └─────────────────────┘ Low addresses Low addresses RSP pulled down → space alloced in the stack In the case of the heap, a manual request of x bytes of data is sent and then, a fixed-size memory chunk gets alloced and usually a pointer with the first address of this chunk is stored in the stack. BEFORE: malloc(0x20) AFTER: malloc(0x20) HEAP: HEAP: ┌─────────────────────┐ ┌─────────────────────┐ │ │ │ Heap Metadata │ │ │ ├─────────────────────┤◄─ returned ptr, stored as a local variable in the stack │ (available) │ │ │ │ │ │ Allocated Chunk │ │ │ │ (0x20 bytes) │ │ │ │ │ └─────────────────────┘ ├─────────────────────┤ │ (available) │ └─────────────────────┘ This is the way in which data gets alloced in memory at runtime when a program is executing. This essentially means that the OS reserves space for the data that is about to be stored. Observe that the stack and the heap always posees data, this means that the alloced memory regions are very likely to posees data even before to be alloced again for a reuse. The memory region which has no data placed in since it was alloced is labeled as uninitialized, then, when the data is placed in this is initialize data. This distinction about data present in a memory region before use it and data written into a memory region is important to understand the vulnerability we are about to explain. 1.2. UDA definition. UDA, Uninitialize Data Access, is a vulnerability which arises when a program reads from memory that was allocated but never explicitly set to a known value, this is; when a program access to uninitialized data. As we say before, when a program needs to write into memory it first needs to allocate space, when this space gets alloced then the program uses this memory-chunk placing data into it and once this process finish and this chunk serves no-purpouse (if the programmer has good "programming habits") this chunk gets presumibly freed which means that this block of data is labeled as available again to be recycled. However, free does not mean clear or zero-cleared, this means; the previously written data does not get erased from a freed chunk (this is called "garbage data"), is just released from the program's allocator perspective to be reused later but, in the mean while. This is the key to understand this vulnerability, when a program request a memory chunk, this uninitilize structure offers data that can still be accesed, read it and retrieved. Is worth to note that exploiting this kind of vulnerabilities is not trivial, since a good understanding of memory layout is needed in order to understand what is being accesed when an uninitialize variable is used as the following example shows. 2. Examples. 2.1. Trivial Example 1: uad1.c Let's consider the following code: // Uninitialized Data Access 1 (stack) - uda1.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; void uda_func(int * p){ int i; printf("We all know that %x is leet, right?\n", i); } void acid_setter_func(int * p){ int i = *p; printf("We all know that %x is leet, right?\n", i); } int main(int argc, char * argv[]){ char buf[8] = {0}; int i = 0x1337; printf("argc = %d\n", argc); if(argc &gt; 1){ strcpy(buf, argv[1]); i = *(int *)(&amp;buf[0]); } if(buf[0]){ acid_setter_func(&amp;i); } uda_func(&amp;i); return 0; } This code doesn't have a explicty security issue (despite the Stack-Buffer Overflow in which we are not interested in) but is usefull to understand how recently used memory is accessible thorugh uninitialized data. If we track the execution-flow of the code we can see that first, we declare a zero-cleared stack buffer and a signed integer. Then, if the program has been executed among with a cli-parameter argument, it store that parameter within the buffer and in a apparently convoluted way, store this value in i integer. The way in which this assignation is performed ensures the control of an integer-width value. First, take the address of buf[0]. Then cast it as a pointer to an integer, this means that now, the address points to a 4-bytes width data (instead of 1 byte). Then dereference the contents of that pointer (4 bytes) and store it in i. Now, if buf[0] is not null, then it calls to acid_setter_func() which declares and initialites a variable which later is used in a printf function. Later, calls uda_func() which barely do the same but with uninitialize data, only declares i and then proceeds to use it. If we compile the code and execute the following binary we will get the following results: $ ./test AAAA argc = 2 We all know that 41414141 is leet, right? We all know that 41414141 is leet, right? We can see that the second line, provided by uda_func() is accessing the data stored in the memory allocated space for an uninitialized declared variable. Is worth to note that UDA depends on a good memory layout understanding in order to comprehend what is being accesed. The reason why i variables holds the same value in this specific case is due to layout similarity and call-proximity in code of uda_func() and acid_setter_func() as is represented in the following diagram: HIGHER ADDRESSES │ ▼ ┌────────────────────────────────┐ │ main() frame │ └────────────────────────────────┘ STEP 1: call acid_setter_func() ┌────────────────────────────────┐ │ main() frame │ ├────────────────────────────────┤ │ acid_setter_func() frame │ │ │ │ int i = 0x41414141 ← WRITE │ └────────────────────────────────┘ STEP 2: return — frame retracts ┌────────────────────────────────┐ │ main() frame │ ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤ │ │ │ (0x41414141 still here) │ │ │ └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘ STEP 3: call uda_func() ┌────────────────────────────────┐ │ main() frame │ ├────────────────────────────────┤ │ uda_func() frame │ │ │ │ int i; ← READ │ │ (gets 0x41414141) │ └────────────────────────────────┘ │ ▼ LOWER ADDRESSES In order to understand it better, lets take the dissasembly for both functions: First, the dissasembly for acid_setter_func(): $ r2 -e asm.sub.var=false -A -qc "aaa; s sym.acid_setter_func;pdf" test Warning: run r2 with -e bin.cache=true to fix relocations in disassembly ; CALL XREF from main @ 0x126c ┌ 53: sym.acid_setter_func (int64_t arg1); │ ; var int64_t var_18h @ rbp-0x18 │ ; var int64_t var_4h @ rbp-0x4 │ ; arg int64_t arg1 @ rdi │ 0x000011b5 f30f1efa endbr64 │ 0x000011b9 55 push rbp │ 0x000011ba 4889e5 mov rbp, rsp │ 0x000011bd 4883ec20 sub rsp, 0x20 │ 0x000011c1 48897de8 mov qword [rbp - 0x18], rdi ; arg1 │ 0x000011c5 488b45e8 mov rax, qword [rbp - 0x18] │ 0x000011c9 8b00 mov eax, dword [rax] │ 0x000011cb 8945fc mov dword [rbp - 4], eax │ 0x000011ce 8b45fc mov eax, dword [rbp - 4] │ 0x000011d1 89c6 mov esi, eax │ 0x000011d3 488d052e0e00. lea rax, str.We_all_know_that__x_is_leet__right__n ; 0x2008 ; "We all know that %x is leet, right?\n" │ 0x000011da 4889c7 mov rdi, rax ; const char *format │ 0x000011dd b800000000 mov eax, 0 │ 0x000011e2 e8a9feffff call sym.imp.printf ; int printf(const char *format) │ 0x000011e7 90 nop │ 0x000011e8 c9 leave └ 0x000011e9 c3 ret We can intuit the stack layout from the stackframe prologue, it expands the stack by 0x20: push rbp mov rbp, rsp sub rsp, 0x20 Then, since this is GCC compiler in Unix-like system, it follows System V convention, it pass rdi (parameter i) to the location "rbp-0x18" and from there it ends up in "rbp-4": mov qword [rbp - 0x18], rdi ; arg1 mov rax, qword [rbp - 0x18] mov eax, dword [rax] mov dword [rbp - 4], eax mov eax, dword [rbp - 4] Lets note that when the function finish, before RET, LEAVE instruction is executed which restore stackframe, LEAVE is equivalent to: mov rsp, rbp ; restore RSP to where it was before the function pop rbp ; restore caller's RBP Lets now check the uda_func() dissasembly: $ r2 -e asm.sub.var=false -A -qc "aaa; s sym.uda_func;pdf" test Warning: run r2 with -e bin.cache=true to fix relocations in disassembly ; CALL XREF from main @ 0x1278 ┌ 44: sym.uda_func (int64_t arg1); │ ; var int64_t var_18h @ rbp-0x18 │ ; var int64_t var_4h @ rbp-0x4 │ ; arg int64_t arg1 @ rdi │ 0x00001189 f30f1efa endbr64 │ 0x0000118d 55 push rbp │ 0x0000118e 4889e5 mov rbp, rsp │ 0x00001191 4883ec20 sub rsp, 0x20 │ 0x00001195 48897de8 mov qword [rbp - 0x18], rdi ; arg1 │ 0x00001199 8b45fc mov eax, dword [rbp - 4] │ 0x0000119c 89c6 mov esi, eax [...] The code continues but we don't need more than what we have. First, the stack expands 0x20 (the same as the previous function) and the parameter ends again in "rbp-4" to later move this to ESI (register-passed for second parameter through System V convention) to later pass it to printf() function. This means that is essentially accessing the 32-bits data which were written by the previous function. This result in an UDA vulnerability. 2.2. Trivial Example 2: uda2.c Consider now the following code: // Uninitialized Data Access 1 (stack) - uda1.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; int uda_func(int * p){ int i; printf("We all know that %x is leet, right?\n", i); return i; } void acid_setter_func(int * p){ int i = *p; printf("We all know that %x is leet, right?\n", i); } int main(int argc, char * argv[]){ char buf[8] = {0}; int i = 0x1337; printf("argc = %d\n", argc); if(argc &gt; 1){ strcpy(buf, argv[1]); i = *(int *)(&amp;buf[0]); } if(buf[0]){ acid_setter_func(&amp;i); } memcpy(buf, argv[1], uda_func(&amp;i)); return 0; } This code is pretty the same than above with the small difference that now uda_func() is returning i and this value is being implemented as the len parameter of a memcpy() call. Now is easy to understand that this suppose a bigger danger than the previous example. Following the flow explained in the example above, the user-controlled data set in memory by acid_setter_func() is then retrieved by uda_func() and placed in a memcpy() operation potentially triggering a SBO. 2.3. Trivial Example 3. Heap.c Consider now the following code: // Uninitialized Data Access 2 (heap) - uda2.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define BUF_SIZE 1024 void opt_realloc(char ** buf1, char ** buf2){ free(*buf1); free(*buf2); *buf2 = malloc(BUF_SIZE); //XENO: Note, I switched the order of allocs *buf1 = malloc(BUF_SIZE); //XENO: This was based on system-specific knowledge printf("buf1 addr = %p, buf2 addr = %p\n", *buf1, *buf2); } int main(int argc, char * argv[]){ char * buf1 = malloc(BUF_SIZE); char * buf2 = malloc(BUF_SIZE); int * i = (int *)buf1; printf("buf1 addr = %p, buf2 addr = %p\n", buf1, buf2); printf("argc = %d\n", argc); if(argc &gt; 1){ strcpy(buf1, argv[1]); memset(buf2, '!', BUF_SIZE); } if(buf1[0]){ opt_realloc(&amp;buf1, &amp;buf2); } for(unsigned int j = 0; j &lt; strlen(argv[1])/4; j++){ printf("At %p+%d:\t %x\n", i, j*4, *(int *)(i+j)); } i = (int *)buf2; printf("\n"); for(unsigned int j = 0; j &lt; strlen(argv[1])/4; j++){ printf("At %p+%d:\t %x\n", i, j*4, *(int *)(i+j)); } printf("At the end of the day, the important thing is: %x\n", *(int *)&amp;buf1[16]); return 0; } This time we are involving heap-memory region. First, we define two pointers to which we assignate a memory chunk with malloc: char * buf1 = malloc(BUF_SIZE); char * buf2 = malloc(BUF_SIZE); Then we cast buf1 to pointer to a integer: int * i = (int *)buf1; And if we, along with the program, pass a cli-parameter, then the buffer gets fulfilled amd then we call the opt_realloc() function which is a wrapper around malloc in which we free a pointer and then alloc and assign a memory chunk to this pointer: void opt_realloc(char ** buf1, char ** buf2){ free(*buf1); free(*buf2); *buf2 = malloc(BUF_SIZE); //XENO: Note, I switched the order of allocs *buf1 = malloc(BUF_SIZE); //XENO: This was based on system-specific knowledge printf("buf1 addr = %p, buf2 addr = %p\n", *buf1, *buf2); } //... if(buf1[0]){ opt_realloc(&amp;buf1, &amp;buf2); } Due to how the system behaves, in this case once you free a memroy chunk and inmediately assign it, you have assigned the same memory chunk as before, this means that, despite gets realloced, buf1 and buf2 has no changed at this point. Then, we simply read from this uninitialized structures: for(unsigned int j = 0; j &lt; strlen(argv[1])/4; j++){ printf("At %p+%d:\t %x\n", i, j*4, *(int *)(i+j)); } i = (int *)buf2; printf("\n"); for(unsigned int j = 0; j &lt; strlen(argv[1])/4; j++){ printf("At %p+%d:\t %x\n", i, j*4, *(int *)(i+j)); } printf("At the end of the day, the important thing is: %x\n", *(int *)&amp;buf1[16]); return 0; Reach this point, if we compile the binary and execute it we obtain the following output: $ ./test "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" buf1 addr = 0x581a809a32a0, buf2 addr = 0x581a809a36b0 argc = 2 buf1 addr = 0x581a809a32a0, buf2 addr = 0x581a809a36b0 At 0x581a809a32a0+0: 81a809a3 At 0x581a809a32a0+4: 5 At 0x581a809a32a0+8: 0 At 0x581a809a32a0+12: 0 ; Some of the previous data gets has been erased At 0x581a809a32a0+16: 41414141 ; AAAA At 0x581a809a32a0+20: 41414141 At 0x581a809a32a0+24: 41414141 At 0x581a809a32a0+28: 41414141 At 0x581a809a32a0+32: 41414141 At 0x581a809a32a0+36: 41414141 At 0x581a809a32a0+40: 41414141 At 0x581a809a32a0+44: 41414141 At 0x581a809a32a0+48: 41414141 At 0x581a809a36b0+0: 1323b03 At 0x581a809a36b0+4: 581f At 0x581a809a36b0+8: 0 At 0x581a809a36b0+12: 0 At 0x581a809a36b0+16: 21212121 At 0x581a809a36b0+20: 21212121 At 0x581a809a36b0+24: 21212121 At 0x581a809a36b0+28: 21212121 At 0x581a809a36b0+32: 21212121 At 0x581a809a36b0+36: 21212121 At 0x581a809a36b0+40: 21212121 At 0x581a809a36b0+44: 21212121 At 0x581a809a36b0+48: 21212121 At the end of the day, the important thing is: 41414141 We can see that, despite being both buffer freed, the previous allocated data still accesible, this is essentially an UDA vulnerability. 3. Common Roots. Among the common causes that leads to a UDA vulnerability are: Not initializing local variables at declaration time. No initializing heap data at allocation time. Only partially initializing structs &amp; objects. Accidental failure to initialize down an uncommon control flow path. If a codebase uses a lot function pointers / callbacks / indirect control flow, it is far more difficult for a human auditor to confidently assess. In such cases tooling and automated analysis (e.g. MemorySanitizer and/or a Fuzzer) should be brought to bear. 4. Exercises. 4.1. CVE-2022-1809. Radare2 is a reverse engineering tool, often used to analyze potentially-malicious binaries such as malware, therefore all values that come from the binary need to be treated as ACID. Consider the following C code: ////////////////////////////////////////////////////////////////////// //XENO: Structure that isn't completely initialized ////////////////////////////////////////////////////////////////////// /* vtables */ typedef struct { RAnal *anal; RAnalCPPABI abi; ut8 word_size; bool (*read_addr) (RAnal *anal, ut64 addr, ut64 *buf); } RVTableContext; ////////////////////////////////////////////////////////////////////// //XENO: Part of the path where incomplete initialized occurs ////////////////////////////////////////////////////////////////////// //XENO: assume the following fields are ACID based on a malicious ACID binary under analysis: //XENO: anal-&gt;config-&gt;bits, anal-&gt;cur-&gt;arch R_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) { context-&gt;anal = anal; context-&gt;abi = anal-&gt;cxxabi; context-&gt;word_size = (ut8) (anal-&gt;config-&gt;bits / 8); const bool is_arm = anal-&gt;cur-&gt;arch &amp;&amp; r_str_startswith (anal-&gt;cur-&gt;arch, "arm"); if (is_arm &amp;&amp; context-&gt;word_size &lt; 4) { context-&gt;word_size = 4; } const bool be = anal-&gt;config-&gt;big_endian; switch (context-&gt;word_size) { case 1: context-&gt;read_addr = be? vtable_read_addr_be8 : vtable_read_addr_le8; break; case 2: context-&gt;read_addr = be? vtable_read_addr_be16 : vtable_read_addr_le16; break; case 4: context-&gt;read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32; break; case 8: context-&gt;read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64; break; default: return false; } return true; } ////////////////////////////////////////////////////////////////////// //XENO: Part of the path where uninitialized access occurs eventually ////////////////////////////////////////////////////////////////////// R_API void r_anal_list_vtables(RAnal *anal, int rad) { RVTableContext context; r_anal_vtable_begin (anal, &amp;context); const char *noMethodName = "No Name found"; RVTableMethodInfo *curMethod; RListIter *vtableIter; RVTableInfo *table; RList *vtables = r_anal_vtable_search (&amp;context); //XENO: snip } R_API RList *r_anal_vtable_search(RVTableContext *context) { RAnal *anal = context-&gt;anal; if (!anal) { return NULL; } RList *vtables = r_list_newf ((RListFree)r_anal_vtable_info_free); if (!vtables) { return NULL; } RList *sections = anal-&gt;binb.get_sections (anal-&gt;binb.bin); if (!sections) { r_list_free (vtables); return NULL; } r_cons_break_push (NULL, NULL); RListIter *iter; RBinSection *section; r_list_foreach (sections, iter, section) { if (r_cons_is_breaked ()) { break; } if (!vtable_section_can_contain_vtables (section)) { continue; } ut64 startAddress = section-&gt;vaddr; ut64 endAddress = startAddress + (section-&gt;vsize) - context-&gt;word_size; ut64 ss = endAddress - startAddress; if (ss &gt; ST32_MAX) { break; } while (startAddress &lt;= endAddress) { if (r_cons_is_breaked ()) { break; } if (!anal-&gt;iob.is_valid_offset (anal-&gt;iob.io, startAddress, 0)) { break; } if (vtable_is_addr_vtable_start (context, section, startAddress)) { RVTableInfo *vtable = r_anal_vtable_parse_at (context, startAddress); if (vtable) { r_list_append (vtables, vtable); ut64 size = r_anal_vtable_info_get_size (context, vtable); if (size &gt; 0) { startAddress += size; continue; } } } startAddress += context-&gt;word_size; } } //XENO: snip } static bool vtable_is_addr_vtable_start(RVTableContext *context, RBinSection *section, ut64 curAddress) { if (context-&gt;abi == R_ANAL_CPP_ABI_MSVC) { return vtable_is_addr_vtable_start_msvc (context, curAddress); } if (context-&gt;abi == R_ANAL_CPP_ABI_ITANIUM) { return vtable_is_addr_vtable_start_itanium (context, section, curAddress); } r_return_val_if_reached (false); return false; } static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) { RAnalRef *xref; RListIter *xrefIter; if (!curAddress || curAddress == UT64_MAX) { return false; } if (curAddress &amp;&amp; !vtable_is_value_in_text_section (context, curAddress, NULL)) { return false; } //XENO: snip } static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) { //value at the current address ut64 curAddressValue; if (!context-&gt;read_addr (context-&gt;anal, curAddress, &amp;curAddressValue)) { return false; } //if the value is in text section bool ret = vtable_addr_in_text_section (context, curAddressValue); if (value) { *value = curAddressValue; } return ret; } Let's reorganize de code to understand it better: First, r_anal_list_vtables() calls both r_anal_vtable_begin() which initializes the previously declared variable context and r_anal_vtable_search() also with context passed as parameter. Let's observe that the parameter anal-&gt;config-&gt;bits is user-controlled, and thus, context-&gt;word_size also is and due to this, there is a margin in which the read_addr field does not get initialized: R_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) { context-&gt;anal = anal; context-&gt;abi = anal-&gt;cxxabi; context-&gt;word_size = (ut8) (anal-&gt;config-&gt;bits / 8); //... switch (context-&gt;word_size) { //Depending on the case, context-&gt;read_addr get assigned a value except in default case. default: return false; } return true; } R_API void r_anal_list_vtables(RAnal *anal, int rad) { RVTableContext context; r_anal_vtable_begin (anal, &amp;context); //... } Then, r_anal_vtable_search() calls vtable_is_addr_vtable_start() which calls vtable_is_addr_vtable_start_msvc() as well and this one to vtable_is_value_in_text_section() which attemps to read from context-&gt;read_addr: static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) { //value at the current address ut64 curAddressValue; if (!context-&gt;read_addr (context-&gt;anal, curAddress, &amp;curAddressValue)) { return false; } //... This is an unintialized memory region being readed, leading to Uninitialized Data Access vulnerability. 4.2. CVE-2021-3608. Consider the following C code: ////////////////////////////////////////////////////////////////////// //XENO: Structure that isn't completely initialized ////////////////////////////////////////////////////////////////////// typedef struct PvrdmaRing { char name[MAX_RING_NAME_SZ]; PCIDevice *dev; uint32_t max_elems; size_t elem_sz; PvrdmaRingState *ring_state; /* used only for unmap */ int npages; void **pages; } PvrdmaRing; ////////////////////////////////////////////////////////////////////// //XENO: Part of the path where incomplete initialized occurs AND uninitialized usage occurs ////////////////////////////////////////////////////////////////////// //XENO: Assume dir_addr and num_pages are ACID //XENO: And assume that if the 2nd argument to rdma_pci_dma_map() is ACID //XENO: then it's basically just mapping more ACID data/structs into memory static int init_dev_ring(PvrdmaRing *ring, PvrdmaRingState **ring_state, const char *name, PCIDevice *pci_dev, dma_addr_t dir_addr, uint32_t num_pages) { uint64_t *dir, *tbl; int rc = 0; dir = rdma_pci_dma_map(pci_dev, dir_addr, TARGET_PAGE_SIZE); if (!dir) { rdma_error_report("Failed to map to page directory (ring %s)", name); rc = -ENOMEM; goto out; } tbl = rdma_pci_dma_map(pci_dev, dir[0], TARGET_PAGE_SIZE); if (!tbl) { rdma_error_report("Failed to map to page table (ring %s)", name); rc = -ENOMEM; goto out_free_dir; } *ring_state = rdma_pci_dma_map(pci_dev, tbl[0], TARGET_PAGE_SIZE); if (!*ring_state) { rdma_error_report("Failed to map to ring state (ring %s)", name); rc = -ENOMEM; goto out_free_tbl; } /* RX ring is the second */ (*ring_state)++; rc = pvrdma_ring_init(ring, name, pci_dev, (PvrdmaRingState *)*ring_state, (num_pages - 1) * TARGET_PAGE_SIZE / sizeof(struct pvrdma_cqne), sizeof(struct pvrdma_cqne), (dma_addr_t *)&amp;tbl[1], (dma_addr_t)num_pages - 1); if (rc) { rc = -ENOMEM; goto out_free_ring_state; } goto out_free_tbl; out_free_ring_state: rdma_pci_dma_unmap(pci_dev, *ring_state, TARGET_PAGE_SIZE); out_free_tbl: rdma_pci_dma_unmap(pci_dev, tbl, TARGET_PAGE_SIZE); out_free_dir: rdma_pci_dma_unmap(pci_dev, dir, TARGET_PAGE_SIZE); out: return rc; } int pvrdma_ring_init(PvrdmaRing *ring, const char *name, PCIDevice *dev, PvrdmaRingState *ring_state, uint32_t max_elems, size_t elem_sz, dma_addr_t *tbl, uint32_t npages) { int i; int rc = 0; pstrcpy(ring-&gt;name, MAX_RING_NAME_SZ, name); ring-&gt;dev = dev; ring-&gt;ring_state = ring_state; ring-&gt;max_elems = max_elems; ring-&gt;elem_sz = elem_sz; /* TODO: Give a moment to think if we want to redo driver settings qatomic_set(&amp;ring-&gt;ring_state-&gt;prod_tail, 0); qatomic_set(&amp;ring-&gt;ring_state-&gt;cons_head, 0); */ ring-&gt;npages = npages; ring-&gt;pages = g_malloc(npages * sizeof(void *)); //XENO: array of npages pointers for (i = 0; i &lt; npages; i++) { if (!tbl[i]) { rdma_error_report("npages=%d but tbl[%d] is NULL", npages, i); continue; } ring-&gt;pages[i] = rdma_pci_dma_map(dev, tbl[i], TARGET_PAGE_SIZE); if (!ring-&gt;pages[i]) { rc = -ENOMEM; rdma_error_report("Failed to map to page %d in ring %s", i, name); goto out_free; } memset(ring-&gt;pages[i], 0, TARGET_PAGE_SIZE); } goto out; out_free: while (i--) { rdma_pci_dma_unmap(dev, ring-&gt;pages[i], TARGET_PAGE_SIZE); } g_free(ring-&gt;pages); out: return rc; } Let's observe that dir_addr being user-controlled implies tbl being user-controlled (along with num_pages) which both are passed as parameters to pvrdma_ring_init() In this function, num_pages assumes the form of npages and tbl as tbl pointer, as two separate user-controller values, and there exists the following loop: for (i = 0; i &lt; npages; i++) { if (!tbl[i]) { rdma_error_report("npages=%d but tbl[%d] is NULL", npages, i); continue; } //... Observe that there are checking the same number of tbl entries and npages, however, since this two values are user-controlled, eventually a huge npages value and a small tbl array can lead to the program try to access undefenied, not-initialize, tbl entires, leading to Uninitialize Data Access vulnerability. 4.3. CVE-2022-26712. Processes on macOS and iOS can use XPC (Mac OS X inter-Process Communication) to send data between each other. XPC (cross-process communication) is Apple's IPC mechanism for communication between processes, heavily used for privilege separation. When you send a message via XPC, you're crossing process boundaries—different address spaces—so the data must be serialized (convert data to a stream of bytes to be reconstructed later). Consider the following code: xpc_object_t content = xpc_dictionary_get_value(req, "source"); size_t count = xpc_array_get_count(content); //XENO: count SACI, based on number of array elements sent size_t *descriptors = malloc(sizeof(size_t) * 4 * count); size_t *accessBeginPointer = &amp;descriptors[count * 0], *accessDataLength = &amp;descriptors[count * 1], *mappedBaseAddress = &amp;descriptors[count * 2], *mappedLength = &amp;descriptors[count * 3]; for(size_t i = 0; i &lt; count; i++) { accessBeginPointer[i] = accessDataLength[i] = mappedBaseAddress[i] = mappedLength[i] = 0; xpc_object_t chunk = xpc_array_get_value(content, i); if(xpc_get_type(chunk) == XPC_TYPE_DATA) { /*...*/ } else if(xpc_get_type(chunk) == XPC_TYPE_SHMEM) { xpc_object_t map = xpc_array_get_value(chunk, 0); size_t offset = min(xpc_array_get_uint64(chunk, 1), 0xFFF), //XENO: offset SACI size = xpc_array_get_uint64(chunk, 2); //XENO: size ACID size_t mapped_address; size_t mapped_size = xpc_shmem_map(map, &amp;mapped_address); //XENO: mapped_size ACID size = min(size, mapped_size - offset); // ... } } // ... // cleanup for(size_t index = 0; index &lt; count; index++) { if(mappedLength[index]) { munmap(mappedBaseAddress[index], mappedLength[index]); } } free(descriptors); Lets observe the following line: size_t *descriptors = malloc(sizeof(size_t) * 4 * count); Considering that count is in some form user-controlled and integer overflow can be present in the mathematic operation within the malloc passed parameter leading to an underallocation for descriptor pointer. Then, some pointers are defined through descriptor pointer: size_t *accessBeginPointer = &amp;descriptors[count * 0], *accessDataLength = &amp;descriptors[count * 1], *mappedBaseAddress = &amp;descriptors[count * 2], *mappedLength = &amp;descriptors[count * 3]; //&lt;-- Interesting Observe that, despite some assignations are being made, the descriptors pointer still not-initialize memery regions. Thus, below, in the for loop, since count is a big value, eventually Out-Of-Bounds write and read happens: for(size_t index = 0; index &lt; count; index++) { if(mappedLength[index]) { //... 4.4. CVE-2022-29968. Consider the following C code: ////////////////////////////////////////////////////////////////////// //XENO: Structure that isn't completely initialized ////////////////////////////////////////////////////////////////////// struct io_kiocb { union { struct file *file; struct io_rw rw; struct io_poll_iocb poll; struct io_poll_update poll_update; struct io_accept accept; struct io_sync sync; struct io_cancel cancel; struct io_timeout timeout; struct io_timeout_rem timeout_rem; struct io_connect connect; struct io_sr_msg sr_msg; struct io_open open; struct io_close close; struct io_rsrc_update rsrc_update; struct io_fadvise fadvise; struct io_madvise madvise; struct io_epoll epoll; struct io_splice splice; struct io_provide_buf pbuf; struct io_statx statx; struct io_shutdown shutdown; struct io_rename rename; struct io_unlink unlink; struct io_mkdir mkdir; struct io_symlink symlink; struct io_hardlink hardlink; struct io_msg msg; }; u8 opcode; u8 iopoll_completed; u16 buf_index; unsigned int flags; u64 user_data; u32 result; union { u32 cflags; int fd; }; struct io_ring_ctx *ctx; struct task_struct *task; struct percpu_ref *fixed_rsrc_refs; struct io_mapped_ubuf *imu; union { struct io_wq_work_node comp_list; int apoll_events; }; atomic_t refs; atomic_t poll_refs; struct io_task_work io_task_work; struct hlist_node hash_node; struct async_poll *apoll; void *async_data; struct io_buffer *kbuf; struct io_kiocb *link; const struct cred *creds; struct io_wq_work work; }; ////////////////////////////////////////////////////////////////////// //XENO: Part of the path where incomplete initialization occurs ////////////////////////////////////////////////////////////////////// static int io_rw_init_file(struct io_kiocb *req, fmode_t mode) { struct kiocb *kiocb = &amp;req-&gt;rw.kiocb; struct io_ring_ctx *ctx = req-&gt;ctx; struct file *file = req-&gt;file; int ret; if (unlikely(!file || !(file-&gt;f_mode &amp; mode))) return -EBADF; if (!io_req_ffs_set(req)) req-&gt;flags |= io_file_get_flags(file) &lt;&lt; REQ_F_SUPPORT_NOWAIT_BIT; kiocb-&gt;ki_flags = iocb_flags(file); ret = kiocb_set_rw_flags(kiocb, req-&gt;rw.flags); if (unlikely(ret)) return ret; if ((kiocb-&gt;ki_flags &amp; IOCB_NOWAIT) || ((file-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; !io_file_supports_nowait(req))) req-&gt;flags |= REQ_F_NOWAIT; if (ctx-&gt;flags &amp; IORING_SETUP_IOPOLL) { if (!(kiocb-&gt;ki_flags &amp; IOCB_DIRECT) || !file-&gt;f_op-&gt;iopoll) return -EOPNOTSUPP; kiocb-&gt;ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE; kiocb-&gt;ki_complete = io_complete_rw_iopoll; req-&gt;iopoll_completed = 0; } else { if (kiocb-&gt;ki_flags &amp; IOCB_HIPRI) return -EINVAL; kiocb-&gt;ki_complete = io_complete_rw; } return 0; } static int io_read(struct io_kiocb *req, unsigned int issue_flags){ struct io_rw_state __s, *s = &amp;__s; struct iovec *iovec; struct kiocb *kiocb = &amp;req-&gt;rw.kiocb; bool force_nonblock = issue_flags &amp; IO_URING_F_NONBLOCK; struct io_async_rw *rw; ssize_t ret, ret2; loff_t *ppos; if (!req_has_async_data(req)) { ret = io_import_iovec(READ, req, &amp;iovec, s, issue_flags); if (unlikely(ret &lt; 0)) return ret; } else { if (req-&gt;flags &amp; REQ_F_BUFFER_SELECT) { ret = io_import_iovec(READ, req, &amp;iovec, s, issue_flags); if (unlikely(ret &lt; 0)) return ret; } rw = req-&gt;async_data; s = &amp;rw-&gt;s; iov_iter_restore(&amp;s-&gt;iter, &amp;s-&gt;iter_state); iovec = NULL; } ret = io_rw_init_file(req, FMODE_READ); if (unlikely(ret)) { kfree(iovec); return ret; } req-&gt;result = iov_iter_count(&amp;s-&gt;iter); if (force_nonblock) { if (unlikely(!io_file_supports_nowait(req))) { ret = io_setup_async_rw(req, iovec, s, true); return ret ?: -EAGAIN; } kiocb-&gt;ki_flags |= IOCB_NOWAIT; } else { kiocb-&gt;ki_flags &amp;= ~IOCB_NOWAIT; } ppos = io_kiocb_update_pos(req); ret = rw_verify_area(READ, req-&gt;file, ppos, req-&gt;result); if (unlikely(ret)) { kfree(iovec); return ret; } ret = io_iter_do_read(req, &amp;s-&gt;iter); if (ret == -EAGAIN || (req-&gt;flags &amp; REQ_F_REISSUE)) { req-&gt;flags &amp;= ~REQ_F_REISSUE; if (req-&gt;opcode == IORING_OP_READ &amp;&amp; file_can_poll(req-&gt;file)) return -EAGAIN; if (!force_nonblock &amp;&amp; !(req-&gt;ctx-&gt;flags &amp; IORING_SETUP_IOPOLL)) goto done; if (req-&gt;flags &amp; REQ_F_NOWAIT) goto done; ret = 0; } else if (ret == -EIOCBQUEUED) { goto out_free; } else if (ret == req-&gt;result || ret &lt;= 0 || !force_nonblock || (req-&gt;flags &amp; REQ_F_NOWAIT) || !need_read_all(req)) { goto done; } iov_iter_restore(&amp;s-&gt;iter, &amp;s-&gt;iter_state); ret2 = io_setup_async_rw(req, iovec, s, true); if (ret2) return ret2; iovec = NULL; rw = req-&gt;async_data; s = &amp;rw-&gt;s; do { iov_iter_advance(&amp;s-&gt;iter, ret); if (!iov_iter_count(&amp;s-&gt;iter)) break; rw-&gt;bytes_done += ret; iov_iter_save_state(&amp;s-&gt;iter, &amp;s-&gt;iter_state); if (!io_rw_should_retry(req)) { kiocb-&gt;ki_flags &amp;= ~IOCB_WAITQ; return -EAGAIN; } ret = io_iter_do_read(req, &amp;s-&gt;iter); if (ret == -EIOCBQUEUED) return 0; kiocb-&gt;ki_flags &amp;= ~IOCB_WAITQ; iov_iter_restore(&amp;s-&gt;iter, &amp;s-&gt;iter_state); } while (ret &gt; 0); done: kiocb_done(req, ret, issue_flags); out_free: if (iovec) kfree(iovec); return 0; } ////////////////////////////////////////////////////////////////////// //XENO: Part of the path where uninitialized access occurs eventually ////////////////////////////////////////////////////////////////////// static int io_do_iopoll(struct io_ring_ctx *ctx, bool force_nonspin) { struct io_wq_work_node *pos, *start, *prev; unsigned int poll_flags = BLK_POLL_NOSLEEP; DEFINE_IO_COMP_BATCH(iob); int nr_events = 0; if (ctx-&gt;poll_multi_queue || force_nonspin) poll_flags |= BLK_POLL_ONESHOT; wq_list_for_each(pos, start, &amp;ctx-&gt;iopoll_list) { struct io_kiocb *req = container_of(pos, struct io_kiocb, comp_list); struct kiocb *kiocb = &amp;req-&gt;rw.kiocb; int ret; if (READ_ONCE(req-&gt;iopoll_completed)) break; ret = kiocb-&gt;ki_filp-&gt;f_op-&gt;iopoll(kiocb, &amp;iob, poll_flags); //XENO: This calls iocb_bio_iopoll if (unlikely(ret &lt; 0)) return ret; else if (ret) poll_flags |= BLK_POLL_ONESHOT; if (!rq_list_empty(iob.req_list) || READ_ONCE(req-&gt;iopoll_completed)) break; } if (!rq_list_empty(iob.req_list)) iob.complete(&amp;iob); else if (!pos) return 0; prev = start; wq_list_for_each_resume(pos, prev) { struct io_kiocb *req = container_of(pos, struct io_kiocb, comp_list); if (!smp_load_acquire(&amp;req-&gt;iopoll_completed)) break; nr_events++; if (unlikely(req-&gt;flags &amp; REQ_F_CQE_SKIP)) continue; __io_fill_cqe_req(req, req-&gt;result, io_put_kbuf(req, 0)); } if (unlikely(!nr_events)) return 0; io_commit_cqring(ctx); io_cqring_ev_posted_iopoll(ctx); pos = start ? start-&gt;next : ctx-&gt;iopoll_list.first; wq_list_cut(&amp;ctx-&gt;iopoll_list, prev, start); io_free_batch_list(ctx, pos); return nr_events; } int iocb_bio_iopoll(struct kiocb *kiocb, struct io_comp_batch *iob, unsigned int flags) { struct bio *bio; int ret = 0; rcu_read_lock(); bio = READ_ONCE(kiocb-&gt;private); if (bio &amp;&amp; bio-&gt;bi_bdev) ret = bio_poll(bio, iob, flags); rcu_read_unlock(); return ret; } int bio_poll(struct bio *bio, struct io_comp_batch *iob, unsigned int flags) { struct request_queue *q = bdev_get_queue(bio-&gt;bi_bdev); blk_qc_t cookie = READ_ONCE(bio-&gt;bi_cookie); int ret = 0; if (cookie == BLK_QC_T_NONE || !test_bit(QUEUE_FLAG_POLL, &amp;q-&gt;queue_flags)) return 0; blk_flush_plug(current-&gt;plug, false); if (blk_queue_enter(q, BLK_MQ_REQ_NOWAIT)) return 0; if (queue_is_mq(q)) { ret = blk_mq_poll(q, cookie, iob, flags); } else { struct gendisk *disk = q-&gt;disk; if (disk &amp;&amp; disk-&gt;fops-&gt;poll_bio) ret = disk-&gt;fops-&gt;poll_bio(bio, iob, flags); } blk_queue_exit(q); return ret; } Check that the code that attempts to initialize struct kiocb *kiocb struct by the function io_rw_init_file(), and later in iocb_bio_iopoll() attempts to use kiocb-&gt;private field which is uninitialize, thus bio now has uninitilize data and barely all the operations performed with bio in *bio_poll() *are dangerous and potentially vulnerable since the code is making decisions with undefined data.]]></summary></entry><entry><title type="html">Control Flow.</title><link href="http://localhost:4000/posts/2025/12/12/ControlFlow/" rel="alternate" type="text/html" title="Control Flow." /><published>2025-12-12T10:00:00+01:00</published><updated>2025-12-12T10:00:00+01:00</updated><id>http://localhost:4000/posts/2025/12/12/ControlFlow</id><content type="html" xml:base="http://localhost:4000/posts/2025/12/12/ControlFlow/"><![CDATA[<h3 id="1-control-flow-definition-and-types">1. Control Flow. Definition and types.</h3>

<p>In terms of program execution; <strong>Control Flow</strong> is a term that refers in the order in which the instructions gets executed by the CPU.</p>

<p>In normal conditions, there is a special non-general-purpouse register, the Instruction Pointer, (RIP/EIP/IP) which holds the address that points to the next instruction to be executed by the CPU. The instruction pointer register advance sequentially through memory if nothing interrupts it.</p>

<p>How ever, x86 implements a set of instructions that allows a program to take over the control flow manipulating Instruction Pointer under certain circunstances in two ways:</p>

<ul>
  <li><strong>Unconditional</strong>; execution always transfers somewhere else regardless of state, examples of this control flow take-away are instructions like CALL or RET.</li>
  <li><strong>Conditional</strong>, which divides the code into branchs based on test cases triggered by some instructions.</li>
</ul>

<p><br /></p>

<h3 id="2-unconditional-control-flow">2. Unconditional Control Flow.</h3>

<h4 id="21-goto-jmp-instruction">2.1. Goto, JMP Instruction.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="k">goto</span> <span class="n">mylabel</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"skipped</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="nl">mylabel:</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"goto ftw!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mh">0xb01dface</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code make use of the <em>goto</em> directive which reference some label in the code (mylabel), which skips all the code between that line and the label and starts executing from that point.</p>

<p>The MCVS 2019 disassembly shows the following:</p>

<pre><code class="language-assem">0000000140001000 48 83 EC 28          sub         rsp,28h  ;shadow space as MCVS 2019 it follows Microsoft ABI x64 standard
0000000140001004 EB 0C                jmp         $mylabel (0140001012h)  ; JMP go directly to address of the value between brackets (0000000140001012)
0000000140001006 48 8D 0D F3 4F 00 00 lea         rcx,[__NULL_IMPORT_DESCRIPTOR+1580h (0140006000h)]  
000000014000100D E8 7E 00 00 00       call        printf (0140001090h)  
0000000140001012 48 8D 0D F7 4F 00 00 lea         rcx,[__NULL_IMPORT_DESCRIPTOR+1590h (0140006010h)]  ; Includes the parameter value into RCX register to pass it to printf()
0000000140001019 E8 72 00 00 00       call        printf (0140001090h) ; CALL printf()  
000000014000101E B8 CE FA 1D B0       mov         eax,0B01DFACEh  ; moves the return value into EAX
0000000140001023 48 83 C4 28          add         rsp,28h  ;
0000000140001027 C3                   ret  
</code></pre>

<p>Note that in this dissasembly, since MCVS 2019 is extremely inneficient, there is code that is never executed which is the code involving the first printf() call which is skipped.</p>

<p>And the GCC dissasembly:</p>

<pre><code class="language-assem">            ; DATA XREF from entry0 @ 0x1078
┌ 31: int main (int argc, char **argv, char **envp);
│           0x00001149      f30f1efa       endbr64
│           0x0000114d      55             push rbp ; Stackframe prologue.
│           0x0000114e      4889e5         mov rbp, rsp
│           0x00001151      90             nop
│           0x00001152      488d05ab0e00.  lea rax, str.goto_ftw_      ; 0x2004 ; "goto ftw!" ; Include the string into the RDI to pass this value as a parameter to puts()
│           0x00001159      4889c7         mov rdi, rax                ; const char *s
│           0x0000115c      e8effeffff     call sym.imp.puts           ; int puts(const char *s) ; CALL puts()
│           0x00001161      b8cefa1db0     mov eax, 0xb01dface         ; return value
│           0x00001166      5d             pop rbp                     ; Stackframe epilogue
└           0x00001167      c3             ret
</code></pre>

<p>Lets observe several things between the two dissasemblies:</p>

<ul>
  <li>
    <p>First, unexecuted code has been removed, in the MCSV 2019 code, there was two printf() calls and a JMP statement which deflects the control flow over an address making part of the code unused. In this case, this part is removed and the goto directive is converted to a NOP instruction (No-operation).</p>
  </li>
  <li>
    <p>The second is that instead of call to printf(), is calling puts() since printf() has being called with no format options and puts is simplier.</p>
  </li>
</ul>

<p><br /></p>

<p>Lets talk a bit about JMP. The JMP instruction is one of the most fundamental control flow instructions in assembly language. It performs an unconditional jump to a specified location in code, transferring program execution to a different address.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JMP destination
</code></pre></div></div>

<p>Where destination can be:</p>

<ul>
  <li>A label (most common).</li>
  <li>A register containing an address.</li>
  <li>A memory location containing an address</li>
  <li>An immediate address (direct address)</li>
</ul>

<p>JMP modifies the instruction pointer (IP/EIP/RIP) to point to the destination address, in this terms JMP would be equal as:</p>

<pre><code class="language-assem">MOV RIP, destination
</code></pre>

<p>We can encounter some variants of JMP related on the encoding size and addresing range. For small jumps is more efficient to use shorter versions of JMP:</p>

<ul>
  <li>
    <p><strong>JMP SHORT</strong>, encoded in two bytes, the operand is a signed 8-bit offset from the next instruction. Range: -128 to +127 bytes. Very compact, commonly used for small local jumps like skipping a few instructions.</p>
  </li>
  <li>
    <p><strong>JMP NEAR</strong>; encoded in 5 bytes, the operand is a signed 32-bit offset within the same code segment.</p>
  </li>
  <li>
    <p><strong>JMP FAR</strong>; encoded in more than 7 bytes, the operand is in a different code segment.</p>
  </li>
</ul>

<p><br /></p>

<p>A quick reminder of all the covered unconditional control flow instructions:</p>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Type</th>
      <th>Stack Impact</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JMP</td>
      <td>Unconditional Control Flow</td>
      <td>None</td>
      <td>Direct control transfer</td>
    </tr>
    <tr>
      <td>CALL</td>
      <td>Unconditional Control Flow</td>
      <td>Pushes return address</td>
      <td>Function calls</td>
    </tr>
    <tr>
      <td>RET</td>
      <td>Unconditional Control Flow</td>
      <td>Pops return address</td>
      <td>Function returns</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="3-conditional-control-flow">3. Conditional Control Flow.</h3>

<p>Conditional control flow allows programs to make decisions and execute different code paths based on runtime conditions.</p>

<p><br /></p>

<h4 id="31-flags-register-rflags-in-x64-bits">3.1. FLAGS register (RFLAGS in x64 bits).</h4>

<p>The FLAGS register, originally 16-bits, EFLAGS in 32-bit and RFLAGS in 64-bit, is a special-purpose register that holds status information about the result of the most recent arithmetic or logical operation, plus control bits that affect CPU behavior.</p>

<p><strong>EFLAGS Register Layout (32-bit)</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bit:  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    | 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|ID|VP|VF|AC|VM|RF|  |NT| IOPL |OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF|
    |  |  |  |  |  |  |  |  |  |  |  |IP|IF|  |  |  | 0|  |      |  |  |  |  |  |  | 0|  | 0|  | 1|  |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</code></pre></div></div>

<p>The 32 uppers bits of RFLAGS are set to 0 and not used.</p>

<p><br /></p>

<p><strong>Flag Definitions</strong></p>

<table>
  <thead>
    <tr>
      <th>Bit</th>
      <th>Flag</th>
      <th>Full Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>CF</td>
      <td>Carry Flag</td>
      <td>Status</td>
    </tr>
    <tr>
      <td>2</td>
      <td>PF</td>
      <td>Parity Flag</td>
      <td>Status</td>
    </tr>
    <tr>
      <td>4</td>
      <td>AF</td>
      <td>Auxiliary Carry Flag</td>
      <td>Status</td>
    </tr>
    <tr>
      <td>6</td>
      <td>ZF</td>
      <td>Zero Flag</td>
      <td>Status</td>
    </tr>
    <tr>
      <td>7</td>
      <td>SF</td>
      <td>Sign Flag</td>
      <td>Status</td>
    </tr>
    <tr>
      <td>8</td>
      <td>TF</td>
      <td>Trap Flag</td>
      <td>System</td>
    </tr>
    <tr>
      <td>9</td>
      <td>IF</td>
      <td>Interrupt Enable Flag</td>
      <td>System</td>
    </tr>
    <tr>
      <td>10</td>
      <td>DF</td>
      <td>Direction Flag</td>
      <td>Control</td>
    </tr>
    <tr>
      <td>11</td>
      <td>OF</td>
      <td>Overflow Flag</td>
      <td>Status</td>
    </tr>
    <tr>
      <td>12-13</td>
      <td>IOPL</td>
      <td>I/O Privilege Level</td>
      <td>System</td>
    </tr>
    <tr>
      <td>14</td>
      <td>NT</td>
      <td>Nested Task</td>
      <td>System</td>
    </tr>
    <tr>
      <td>16</td>
      <td>RF</td>
      <td>Resume Flag</td>
      <td>System</td>
    </tr>
    <tr>
      <td>17</td>
      <td>VM</td>
      <td>Virtual-8086 Mode</td>
      <td>System</td>
    </tr>
    <tr>
      <td>18</td>
      <td>AC</td>
      <td>Alignment Check</td>
      <td>System</td>
    </tr>
    <tr>
      <td>19</td>
      <td>VIF</td>
      <td>Virtual Interrupt Flag</td>
      <td>System</td>
    </tr>
    <tr>
      <td>20</td>
      <td>VIP</td>
      <td>Virtual Interrupt Pending</td>
      <td>System</td>
    </tr>
    <tr>
      <td>21</td>
      <td>ID</td>
      <td>ID Flag</td>
      <td>System</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>Flag Types</strong></p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>S (Status)</td>
      <td>Modified by arithmetic/logical instructions (CF, PF, AF, ZF, SF, OF)</td>
    </tr>
    <tr>
      <td>C (Control)</td>
      <td>Controls CPU behavior for string operations (DF)</td>
    </tr>
    <tr>
      <td>X (System)</td>
      <td>Used by OS/hardware, privileged operations</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>Reserved Bits</strong></p>

<table>
  <thead>
    <tr>
      <th>Bit</th>
      <th>Fixed Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Always 1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Always 0</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Always 0</td>
    </tr>
    <tr>
      <td>15</td>
      <td>Always 0</td>
    </tr>
    <tr>
      <td>22-31</td>
      <td>Always 0</td>
    </tr>
  </tbody>
</table>

<p><strong>Note:</strong> Reserved bit positions should not be modified. Always preserve their values when writing to EFLAGS.</p>

<p>Each bit in FLAGS represents a specific condition which manifest as a specific flag with his own iterpretation:</p>

<ul>
  <li>
    <p><strong>ZF (Zero Flag)</strong>: set to 1 if the result was zero.</p>
  </li>
  <li>
    <p><strong>SF (Sign Flag)</strong>: reflects the most significant bit of the result, indicating whether it's negative in signed interpretation.</p>
  </li>
  <li>
    <p><strong>CF (Carry Flag)</strong>: set when an unsigned operation overflows or underflows, (if you add two 32-bit values and the result needs a 33rd bit, CF gets set).</p>
  </li>
  <li>
    <p><strong>OF (Overflow Flag)</strong>: set when a <em>signed operation</em> produces a result that doesn't fit in the destination. This happens when adding two positive numbers gives a negative result (or vice versa).</p>
  </li>
  <li>
    <p><strong>PF (Parity Flag)</strong>: set if the low byte of the result has an even number of 1-bits. Mostly a legacy thing, occasionally used in floating-point comparisons.</p>
  </li>
  <li>
    <p><strong>AF (Auxiliary Carry Flag)</strong>: carry out of bit 3, used for BCD arithmetic. You'll rarely see this in modern code.</p>
  </li>
</ul>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>Flag</th>
      <th>Bit</th>
      <th>Set when…</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ZF</strong> (Zero)</td>
      <td>6</td>
      <td>Result is zero</td>
    </tr>
    <tr>
      <td><strong>SF</strong> (Sign)</td>
      <td>7</td>
      <td>Result is negative (MSB = 1)</td>
    </tr>
    <tr>
      <td><strong>CF</strong> (Carry)</td>
      <td>0</td>
      <td>Unsigned overflow/underflow</td>
    </tr>
    <tr>
      <td><strong>OF</strong> (Overflow)</td>
      <td>11</td>
      <td>Signed overflow</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>FLAGS is fundamentally different from general-purpose registers. It's not a register you manipulate directly with x64 instructions (like MOV), instead, it's automatically updated as a side effect of arithmetic and logical operations (barely allmost of the instructions that performs an arithmetic/logical operation do internally modify bits from the FLAGS register), and then read implicitly by teh so called "conditional instructions".</p>

<p>User almost never read directly FLAGS register, instead, use instructions which implicitly check specific bits of the register and act on them, this is what are known as the <em>Conditional Instructions</em>.</p>

<p><br /></p>

<h4 id="32-conditional-instructions">3.2. Conditional Instructions.</h4>

<h5 id="321-cmp-compare">3.2.1. CMP, Compare.</h5>

<p>CMP (compare) is used to compare two operands by performing a subtraction without storing the result. It only modifies the FLAGS register, with which subsequent conditional instruction will make decisions.</p>

<p>The sintax is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CMP destination, source
</code></pre></div></div>

<p>Where destination and source can be memory address in form of r/mX, register, or immediate value (You cannot compare memory-to-memory directly; one operand must be a register or immediate).</p>

<p>Internally, CMP computes <em>destination - source</em> and discards the result, but sets flags based on what that result would have been. This is identical to SUB except the destination remains unchanged.</p>

<p>Thus, for example, and in order to provide full ilustration about the FLAGS register behaviour, when the CPU executes CMP, it review the result and modify some bit on FLAGS register , for example:</p>

<ul>
  <li>If destination == source, subtraction yields 0, and ZF (6th bit) is set to one.</li>
  <li>If destination != source, and the most significant byte of the result is 1, then the result is negative as a signed value and SF (7th bit) is set up.</li>
</ul>

<p>Note that depending that if it is signed or unsigned comparison different bit-flags would be affeced.</p>

<p>And so on.</p>

<p><br /></p>

<h5 id="322-test-logical-comparison">3.2.2. TEST, logical comparison.</h5>

<p>TEST instruction is the logical equivalent of what CMP is to SUB—a non-destructive way to check conditions.</p>

<p>TEST performs a bitwise AND between two operands, discards the result, and updates FLAGS based on what that result would have been.</p>

<pre><code class="language-assem">TEST destination, source
</code></pre>

<p>Where <em>destination</em> and <em>source</em> can be either a register, a memory address in <em>r/mX</em> form and an immediate value (rememeber that operation between memory address are not allowed).</p>

<p>Internally computes "destination AND source", throws away the result, sets flags. The operands remain unchanged (the difference between AND and TEST is that AND stores the result while TEST not).</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>Flag</th>
      <th>Behavior</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ZF</td>
      <td>Set if result is zero (no overlapping bits)</td>
    </tr>
    <tr>
      <td>SF</td>
      <td>Copies MSB of result (sign in two's complement interpretation)</td>
    </tr>
    <tr>
      <td>PF</td>
      <td>Set if low byte has even number of 1-bits</td>
    </tr>
    <tr>
      <td>CF</td>
      <td>Always cleared to 0</td>
    </tr>
    <tr>
      <td>OF</td>
      <td>Always cleared to 0</td>
    </tr>
    <tr>
      <td>AF</td>
      <td>Undefined</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h5 id="323-arithmetic-instructions">3.2.3. Arithmetic Instructions.</h5>

<p>Most arithmetic operations (ADD, SUB, AND, OR, XOR, etc.) also set flags.</p>

<p><br /></p>

<h5 id="324-conditional-jump-instructions-jcc">3.2.4. Conditional Jump Instructions. Jcc.</h5>

<p>As we saw before, JMP is an instruction that control unconditionally the flow of execution of the program by modifying RIP instruction with a destination address.</p>

<p>In conditional control flow, there are conditional variants of JMP instruction. This is, instructions that behaviours as JMP under certains circunstances; if a condition is true, the jump is taken:</p>

<table>
  <thead>
    <tr>
      <th>jmp variant</th>
      <th>Condition</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>je/jz</td>
      <td>ZF = 1</td>
      <td>Jump if equal/zero</td>
    </tr>
    <tr>
      <td>jne/jnz</td>
      <td>ZF = 0</td>
      <td>Jump if not equal/not zero</td>
    </tr>
    <tr>
      <td>js</td>
      <td>SF = 1</td>
      <td>Jump if negative</td>
    </tr>
    <tr>
      <td>jns</td>
      <td>SF = 0</td>
      <td>Jump if non-negative</td>
    </tr>
    <tr>
      <td>jg/jnle</td>
      <td>ZF=0 &amp; SF=OF</td>
      <td>Jump if greater (signed)</td>
    </tr>
    <tr>
      <td>jge/jnl</td>
      <td>SF = OF</td>
      <td>Jump if greater or equal (signed)</td>
    </tr>
    <tr>
      <td>jl/jnge</td>
      <td>SF ≠ OF</td>
      <td>Jump if less (signed)</td>
    </tr>
    <tr>
      <td>jle/jng</td>
      <td>ZF=1 or SF≠OF</td>
      <td>Jump if less or equal (signed)</td>
    </tr>
    <tr>
      <td>ja/jnbe</td>
      <td>CF=0 &amp; ZF=0</td>
      <td>Jump if above (unsigned)</td>
    </tr>
    <tr>
      <td>jae/jnb</td>
      <td>CF = 0</td>
      <td>Jump if above or equal (unsigned)</td>
    </tr>
    <tr>
      <td>jb/jnae</td>
      <td>CF = 1</td>
      <td>Jump if below (unsigned)</td>
    </tr>
    <tr>
      <td>jbe/jna</td>
      <td>CF=1 or ZF=1</td>
      <td>Jump if below or equal (unsigned)</td>
    </tr>
    <tr>
      <td>jo</td>
      <td>OF = 1</td>
      <td>Jump if overflow</td>
    </tr>
    <tr>
      <td>jno</td>
      <td>OF = 0</td>
      <td>Jump if not overflow</td>
    </tr>
  </tbody>
</table>

<p>Note that, besides there are different instructions names (like for example je and jz), al behaves the same way if a condition is met and in order to check that condition both consults the same bit-flag from the RFLAGS register. Thus, to conditional jumps are equals o the same if checks the same bit-flag (lie je and jz).</p>

<p><br /></p>

<h5 id="325-conditional-moves-and-set">3.2.5. Conditional Moves and Set.</h5>

<p>As well as conditional jumps, there are also conditional moves:</p>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Condition</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cmove/cmovz</td>
      <td>ZF = 1</td>
      <td>Move if equal/zero</td>
    </tr>
    <tr>
      <td>cmovne/cmovnz</td>
      <td>ZF = 0</td>
      <td>Move if not equal/not zero</td>
    </tr>
    <tr>
      <td>cmovs</td>
      <td>SF = 1</td>
      <td>Move if negative</td>
    </tr>
    <tr>
      <td>cmovns</td>
      <td>SF = 0</td>
      <td>Move if non-negative</td>
    </tr>
    <tr>
      <td>cmovg/cmovnle</td>
      <td>ZF=0 &amp; SF=OF</td>
      <td>Move if greater (signed)</td>
    </tr>
    <tr>
      <td>cmovge/cmovnl</td>
      <td>SF = OF</td>
      <td>Move if greater or equal (signed)</td>
    </tr>
    <tr>
      <td>cmovl/cmovnge</td>
      <td>SF ≠ OF</td>
      <td>Move if less (signed)</td>
    </tr>
    <tr>
      <td>cmovle/cmovng</td>
      <td>ZF=1 or SF≠OF</td>
      <td>Move if less or equal (signed)</td>
    </tr>
    <tr>
      <td>cmova/cmovnbe</td>
      <td>CF=0 &amp; ZF=0</td>
      <td>Move if above (unsigned)</td>
    </tr>
    <tr>
      <td>cmovae/cmovnb</td>
      <td>CF = 0</td>
      <td>Move if above or equal (unsigned)</td>
    </tr>
    <tr>
      <td>cmovb/cmovnae</td>
      <td>CF = 1</td>
      <td>Move if below (unsigned)</td>
    </tr>
    <tr>
      <td>cmovbe/cmovna</td>
      <td>CF=1 or ZF=1</td>
      <td>Move if below or equal (unsigned)</td>
    </tr>
    <tr>
      <td>cmovo</td>
      <td>OF = 1</td>
      <td>Move if overflow</td>
    </tr>
    <tr>
      <td>cmovno</td>
      <td>OF = 0</td>
      <td>Move if not overflow</td>
    </tr>
  </tbody>
</table>

<p>And conditional set bits:</p>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Condition</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>sete/setz</td>
      <td>ZF = 1</td>
      <td>Set byte if equal/zero</td>
    </tr>
    <tr>
      <td>setne/setnz</td>
      <td>ZF = 0</td>
      <td>Set byte if not equal/not zero</td>
    </tr>
    <tr>
      <td>sets</td>
      <td>SF = 1</td>
      <td>Set byte if negative</td>
    </tr>
    <tr>
      <td>setns</td>
      <td>SF = 0</td>
      <td>Set byte if non-negative</td>
    </tr>
    <tr>
      <td>setg/setnle</td>
      <td>ZF=0 &amp; SF=OF</td>
      <td>Set byte if greater (signed)</td>
    </tr>
    <tr>
      <td>setge/setnl</td>
      <td>SF = OF</td>
      <td>Set byte if greater or equal (signed)</td>
    </tr>
    <tr>
      <td>setl/setnge</td>
      <td>SF ≠ OF</td>
      <td>Set byte if less (signed)</td>
    </tr>
    <tr>
      <td>setle/setng</td>
      <td>ZF=1 or SF≠OF</td>
      <td>Set byte if less or equal (signed)</td>
    </tr>
    <tr>
      <td>seta/setnbe</td>
      <td>CF=0 &amp; ZF=0</td>
      <td>Set byte if above (unsigned)</td>
    </tr>
    <tr>
      <td>setae/setnb</td>
      <td>CF = 0</td>
      <td>Set byte if above or equal (unsigned)</td>
    </tr>
    <tr>
      <td>setb/setnae</td>
      <td>CF = 1</td>
      <td>Set byte if below (unsigned)</td>
    </tr>
    <tr>
      <td>setbe/setna</td>
      <td>CF=1 or ZF=1</td>
      <td>Set byte if below or equal (unsigned)</td>
    </tr>
    <tr>
      <td>seto</td>
      <td>OF = 1</td>
      <td>Set byte if overflow</td>
    </tr>
    <tr>
      <td>setno</td>
      <td>OF = 0</td>
      <td>Set byte if not overflow</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="4-examples">4. Examples.</h3>

<h4 id="41-if-example1">4.1. If Example1.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mh">0xdefea7</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The code initialize two integers and the return value varies on several comparisons.</p>

<p>Thus, lets retrieve the assembly of this code, first from MCVS 2019:</p>

<pre><code class="language-assen">0000000140001000 48 83 EC 18          sub         rsp,18h  
0000000140001004 C7 44 24 04 FF FF FF FF mov         dword ptr [a],0FFFFFFFFh 
000000014000100C C7 04 24 02 00 00 00 mov         dword ptr [rsp],2  
0000000140001013 8B 04 24             mov         eax,dword ptr [rsp] 		
0000000140001016 39 44 24 04          cmp         dword ptr [a],eax  
000000014000101A 75 07                jne         main+23h (0140001023h)  
000000014000101C B8 01 00 00 00       mov         eax,1  
0000000140001021 EB 25                jmp         main+48h (0140001048h)  
0000000140001023 8B 04 24             mov         eax,dword ptr [rsp]  
0000000140001026 39 44 24 04          cmp         dword ptr [a],eax  
000000014000102A 7E 07                jle         main+33h (0140001033h)  
000000014000102C B8 02 00 00 00       mov         eax,2  
0000000140001031 EB 15                jmp         main+48h (0140001048h)  
0000000140001033 8B 04 24             mov         eax,dword ptr [rsp]  
0000000140001036 39 44 24 04          cmp         dword ptr [a],eax  
000000014000103A 7D 07                jge         main+43h (0140001043h)  
000000014000103C B8 03 00 00 00       mov         eax,3  
0000000140001041 EB 05                jmp         main+48h (0140001048h)  
0000000140001043 B8 A7 FE DE 00       mov         eax,0DEFEA7h  
0000000140001048 48 83 C4 18          add         rsp,18h  
000000014000104C C3                   ret  
</code></pre>

<ul>
  <li>
    <p>First, it extends the stackframe to make space for the local variables.</p>

    <pre><code class="language-assem">  sub         rsp,18h 
</code></pre>
  </li>
  <li>
    <p>Then, assign the initialized local variables:</p>

    <pre><code class="language-assem">  mov         dword ptr [a],0FFFFFFFFh  ; a = -1
  mov         dword ptr [rsp],2  ; 			b = 2
</code></pre>
  </li>
  <li>
    <p>Now the compiler moves the 'b' local variable value to a register in order to operate with it and 'a', since is not allowed to compare (CMP) data accesing to memrory address at once in x86.</p>

    <pre><code class="language-assem">  mov         eax,dword ptr [rsp]
</code></pre>
  </li>
  <li>
    <p>Then comes the if statement. This is constituted with two instructions:</p>

    <ol>
      <li>
        <p>First, the CMP instruction performs the substraction between the two values and modify the RFLAGS register bits.</p>
      </li>
      <li>
        <p>Then, depending of the specific comparison, a variant of JMP follows the CMP instruction, in this case, in C the if statement is evaluating if "a==b" so the JMP variant is JNE which checks if the ZF bit of the RFLAGS register is up. If it is jumps the target address which is the next CMP statement kit:</p>

        <pre><code class="language-assem"> cmp         dword ptr [a],eax  
 jne         main+23h (0140001023h)
</code></pre>

        <p>If not, it means that the comparison is true and simply enters the if block, this is, move into EAX the return value and jump to the RET instruction which would be the end of the code:</p>

        <pre><code class="language-assem"> mov         eax,1  
 jmp         main+48h (0140001048h)
</code></pre>
      </li>
    </ol>
  </li>
  <li>
    <p>Then, it comes the following if-statement, note that the compiler moves again the rsp value to eax in a unoptimized compiler move:</p>

    <pre><code class="language-assem">  mov         eax,dword ptr [rsp]  
  cmp         dword ptr [a],eax  
  jle         main+33h (0140001033h)  
  mov         eax,2  
  jmp         main+48h (0140001048h)
</code></pre>

    <p>Note that the operation is barely the same buit this time, instead of use JNE, is using JLE which checks (ZF=1 || SF!=OF), this means; evaluates if the two values are equal or if, first, if the sign bit is up without an overflow being happened (SF=1, OF=0), second, if the result is positive with an overflow (SF=0, OF=1). Note that both cases means that b is greater than a; one because the substraction "a-b" is negative or two, because "a-b" is positive but overflowing, which means in fact is negative but it gets wrapped over positive due to hardware limitations.</p>

    <p>Note that always the if-statement is checking the opposite event: a &gt; b; a greater than b. By default the flow execution prones to enter the if-block, only if this is false, jumps to another part.</p>
  </li>
  <li>
    <p>Lastly, the last if statement which is pretty the same of the two cases above:</p>

    <pre><code class="language-assem">  mov         eax,dword ptr [rsp]  
  cmp         dword ptr [a],eax  
  jge         main+43h (0140001043h)  
  mov         eax,3  
  jmp         main+48h (0140001048h)
</code></pre>
  </li>
</ul>

<p>Thus, the logic of an if-statement in assembly is to implement first a comparison with CMP instruction and set the bits of RFLAGS register, then implements a variant of JMP instruction that evaluates if the if condition is false and it is skip the if block code (is not, it just enters).</p>

<p><br /></p>

<p>Let's check the same C code compiled with GCC and extracted with radare2:</p>

<pre><code class="language-assem">$ r2 -e asm.sub.var=false -A -qc "aaa; s main;pdf" test
Warning: run r2 with -e bin.cache=true to fix relocations in disassembly
            ; DATA XREF from entry0 @ 0x1058
┌ 74: int main (int argc, char **argv, char **envp);
│           ; var int64_t var_8h @ rbp-0x8
│           ; var signed int var_4h @ rbp-0x4
│           0x00001129      f30f1efa       endbr64
│           0x0000112d      55             push rbp
│           0x0000112e      4889e5         mov rbp, rsp
│           0x00001131      c745f8ffffff.  mov dword [rbp - 8], 0xffffffff ; -1
│           0x00001138      c745fc020000.  mov dword [rbp - 4], 2
│           0x0000113f      8b45f8         mov eax, dword [rbp - 8]
│           0x00001142      3b45fc         cmp eax, dword [rbp - 4]
│       ┌─&lt; 0x00001145      7507           jne 0x114e
│       │   0x00001147      b801000000     mov eax, 1
│      ┌──&lt; 0x0000114c      eb23           jmp 0x1171
│      ││   ; CODE XREF from main @ 0x1145
│      │└─&gt; 0x0000114e      8b45f8         mov eax, dword [rbp - 8]
│      │    0x00001151      3b45fc         cmp eax, dword [rbp - 4]
│      │┌─&lt; 0x00001154      7e07           jle 0x115d
│      ││   0x00001156      b802000000     mov eax, 2
│     ┌───&lt; 0x0000115b      eb14           jmp 0x1171
│     │││   ; CODE XREF from main @ 0x1154
│     ││└─&gt; 0x0000115d      8b45f8         mov eax, dword [rbp - 8]
│     ││    0x00001160      3b45fc         cmp eax, dword [rbp - 4]
│     ││┌─&lt; 0x00001163      7d07           jge 0x116c
│     │││   0x00001165      b803000000     mov eax, 3
│    ┌────&lt; 0x0000116a      eb05           jmp 0x1171
│    ││││   ; CODE XREF from main @ 0x1163
│    │││└─&gt; 0x0000116c      b8a7fede00     mov eax, 0xdefea7
│    │││    ; CODE XREFS from main @ 0x114c, 0x115b, 0x116a
│    └└└──&gt; 0x00001171      5d             pop rbp
└           0x00001172      c3             ret
</code></pre>

<p>We can see that this time the code is barely the same, introduce the data in the local variables and start comparing the code with the same structure than the code generated by MCSV 2019, the if-statement are the composition of two instructions CMP (which evaluates the substraction of the two operands) and a variant of JMP instruction, which depends of the operation performed by the if condition and evalutes the opposite condition. If is true skip the if block if not, continues and enters the if-block code.</p>

<p><br /></p>

<h4 id="42-if-example2">4.2. If example2.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mh">0xdefea7</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The only difference between this code and the code above is the intergers variables are now unsigned, the dissasembly of MCSV 2019</p>

<pre><code class="language-assem">0000000140001000 48 83 EC 18          sub         rsp,18h  
0000000140001004 C7 44 24 04 FF FF FF FF mov         dword ptr [a],0FFFFFFFFh  
000000014000100C C7 04 24 02 00 00 00 mov         dword ptr [rsp],2  
0000000140001013 8B 04 24             mov         eax,dword ptr [rsp]  
0000000140001016 39 44 24 04          cmp         dword ptr [a],eax  
000000014000101A 75 07                jne         main+23h (0140001023h)  
000000014000101C B8 01 00 00 00       mov         eax,1  
0000000140001021 EB 25                jmp         main+48h (0140001048h)  
0000000140001023 8B 04 24             mov         eax,dword ptr [rsp]  
0000000140001026 39 44 24 04          cmp         dword ptr [a],eax  
000000014000102A 76 07                jbe         main+33h (0140001033h)  
000000014000102C B8 02 00 00 00       mov         eax,2  
0000000140001031 EB 15                jmp         main+48h (0140001048h)  
0000000140001033 8B 04 24             mov         eax,dword ptr [rsp]  
0000000140001036 39 44 24 04          cmp         dword ptr [a],eax  
000000014000103A 73 07                jae         main+43h (0140001043h)  
000000014000103C B8 03 00 00 00       mov         eax,3  
0000000140001041 EB 05                jmp         main+48h (0140001048h)  
0000000140001043 B8 ED A7 FE DE       mov         eax,0DEFEA7EDh  
0000000140001048 48 83 C4 18          add         rsp,18h  
000000014000104C C3                   ret 
</code></pre>

<p>Let's observe that, despite the if-statements are the same than in the other code, the JMP variants are differents. This means that the compilers generates code based on the datatype written by the user. The choice of conditional jump instruction (JA/JB/JAE/JBE for unsigned vs. JG/JL/JGE/JLE for signed) reveals the original variable's signedness—useful for reconstructing type information when analyzing binaries.</p>

<p>In the other hand; It turns out that for instructions that set status flags (e.g. arithmetic operations), the hardware just does the operation and sets flags as if the operands were both unsigned and signed. Basically the hardware doesn't know or care about whether the humans are currently interpreting the bits as signed or unsigned. That's the compiler's problem to sort out.</p>

<p><br /></p>

<h4 id="43-switch-example">4.3. Switch Example.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mh">0xfee1fed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this case, we have a SWITCH directive that evaluates the input that the user-provides through the cli-parameter and provides three cases.</p>

<p>The dissasembly shows that the compiler treats the switch directive as if were a bunch of if-statements:</p>

<pre><code class="language-assem">0000000140001000 48 89 54 24 10       mov         qword ptr [rsp+10h],rdx  
0000000140001005 89 4C 24 08          mov         dword ptr [rsp+8],ecx  
0000000140001009 48 83 EC 38          sub         rsp,38h  
000000014000100D B8 08 00 00 00       mov         eax,8  
0000000140001012 48 6B C0 01          imul        rax,rax,1  
0000000140001016 48 8B 4C 24 48       mov         rcx,qword ptr [argv]  
000000014000101B 48 8B 0C 01          mov         rcx,qword ptr [rcx+rax]  
000000014000101F FF 15 53 31 00 00    call        qword ptr [__imp_atoi (0140004178h)]  
0000000140001025 89 44 24 24          mov         dword ptr [a],eax  
0000000140001029 8B 44 24 24          mov         eax,dword ptr [a]  
000000014000102D 89 44 24 20          mov         dword ptr [rsp+20h],eax  
0000000140001031 83 7C 24 20 00       cmp         dword ptr [rsp+20h],0  
0000000140001036 74 09                je          main+41h (0140001041h)  
0000000140001038 83 7C 24 20 01       cmp         dword ptr [rsp+20h],1  
000000014000103D 74 09                je          main+48h (0140001048h)  
000000014000103F EB 0E                jmp         main+4Fh (014000104Fh)  
0000000140001041 B8 01 00 00 00       mov         eax,1  
0000000140001046 EB 13                jmp         main+5Bh (014000105Bh)  
0000000140001048 B8 02 00 00 00       mov         eax,2  
000000014000104D EB 0C                jmp         main+5Bh (014000105Bh)  
000000014000104F B8 03 00 00 00       mov         eax,3  
0000000140001054 EB 05                jmp         main+5Bh (014000105Bh)  
0000000140001056 B8 ED 1F EE 0F       mov         eax,0FEE1FEDh  
000000014000105B 48 83 C4 38          add         rsp,38h  
000000014000105F C3                   ret 
</code></pre>

<p>It is worth to note that this code is compiled and extracted in MCVS 2019 and follows Microsoft x64 ABI standards, thus, is worth to break down the first instructions:</p>

<ul>
  <li>
    <p>First, is setting the argc and argv arguments which come from RCX and RDX (standard in ABI convention). This is possible due to the shadow space alloced by the caller of main.</p>

    <pre><code class="language-assem">  mov         qword ptr [rsp+10h],rdx  
  mov         dword ptr [rsp+8],ecx 
</code></pre>
  </li>
  <li>
    <p>Then, it allocates the shadow space for the atoi() function:</p>

    <pre><code class="language-assem">  sub         rsp,38h 
</code></pre>
  </li>
  <li>
    <p>Lastly, it introduces in RCX the argument of atoi() which is argv[1]:</p>

    <pre><code class="language-assem">  000000014000100D B8 08 00 00 00       mov         eax,8  
  0000000140001012 48 6B C0 01          imul        rax,rax,1  
  0000000140001016 48 8B 4C 24 48       mov         rcx,qword ptr [argv]  
  000000014000101B 48 8B 0C 01          mov         rcx,qword ptr [rcx+rax]  
</code></pre>

    <p>Note that, is a convoluted way to introduce the word size (in x64, which is the size of a pointer) into RAX and then add it to the argv pointer, the result is in terms of pointer arithmetics, argv + 1 or argv[1] being stored in RCX.</p>
  </li>
</ul>

<p><br /></p>]]></content><author><name>German Sanmi</name></author><category term="Past Blogs" /><category term="Assembly" /><category term="x86" /><category term="reverse-engineering" /><summary type="html"><![CDATA[1. Control Flow. Definition and types. In terms of program execution; Control Flow is a term that refers in the order in which the instructions gets executed by the CPU. In normal conditions, there is a special non-general-purpouse register, the Instruction Pointer, (RIP/EIP/IP) which holds the address that points to the next instruction to be executed by the CPU. The instruction pointer register advance sequentially through memory if nothing interrupts it. How ever, x86 implements a set of instructions that allows a program to take over the control flow manipulating Instruction Pointer under certain circunstances in two ways: Unconditional; execution always transfers somewhere else regardless of state, examples of this control flow take-away are instructions like CALL or RET. Conditional, which divides the code into branchs based on test cases triggered by some instructions. 2. Unconditional Control Flow. 2.1. Goto, JMP Instruction. Consider the following C code: int main(){ goto mylabel; printf("skipped\n"); mylabel: printf("goto ftw!\n"); return 0xb01dface; } This code make use of the goto directive which reference some label in the code (mylabel), which skips all the code between that line and the label and starts executing from that point. The MCVS 2019 disassembly shows the following: 0000000140001000 48 83 EC 28 sub rsp,28h ;shadow space as MCVS 2019 it follows Microsoft ABI x64 standard 0000000140001004 EB 0C jmp $mylabel (0140001012h) ; JMP go directly to address of the value between brackets (0000000140001012) 0000000140001006 48 8D 0D F3 4F 00 00 lea rcx,[__NULL_IMPORT_DESCRIPTOR+1580h (0140006000h)] 000000014000100D E8 7E 00 00 00 call printf (0140001090h) 0000000140001012 48 8D 0D F7 4F 00 00 lea rcx,[__NULL_IMPORT_DESCRIPTOR+1590h (0140006010h)] ; Includes the parameter value into RCX register to pass it to printf() 0000000140001019 E8 72 00 00 00 call printf (0140001090h) ; CALL printf() 000000014000101E B8 CE FA 1D B0 mov eax,0B01DFACEh ; moves the return value into EAX 0000000140001023 48 83 C4 28 add rsp,28h ; 0000000140001027 C3 ret Note that in this dissasembly, since MCVS 2019 is extremely inneficient, there is code that is never executed which is the code involving the first printf() call which is skipped. And the GCC dissasembly: ; DATA XREF from entry0 @ 0x1078 ┌ 31: int main (int argc, char **argv, char **envp); │ 0x00001149 f30f1efa endbr64 │ 0x0000114d 55 push rbp ; Stackframe prologue. │ 0x0000114e 4889e5 mov rbp, rsp │ 0x00001151 90 nop │ 0x00001152 488d05ab0e00. lea rax, str.goto_ftw_ ; 0x2004 ; "goto ftw!" ; Include the string into the RDI to pass this value as a parameter to puts() │ 0x00001159 4889c7 mov rdi, rax ; const char *s │ 0x0000115c e8effeffff call sym.imp.puts ; int puts(const char *s) ; CALL puts() │ 0x00001161 b8cefa1db0 mov eax, 0xb01dface ; return value │ 0x00001166 5d pop rbp ; Stackframe epilogue └ 0x00001167 c3 ret Lets observe several things between the two dissasemblies: First, unexecuted code has been removed, in the MCSV 2019 code, there was two printf() calls and a JMP statement which deflects the control flow over an address making part of the code unused. In this case, this part is removed and the goto directive is converted to a NOP instruction (No-operation). The second is that instead of call to printf(), is calling puts() since printf() has being called with no format options and puts is simplier. Lets talk a bit about JMP. The JMP instruction is one of the most fundamental control flow instructions in assembly language. It performs an unconditional jump to a specified location in code, transferring program execution to a different address. JMP destination Where destination can be: A label (most common). A register containing an address. A memory location containing an address An immediate address (direct address) JMP modifies the instruction pointer (IP/EIP/RIP) to point to the destination address, in this terms JMP would be equal as: MOV RIP, destination We can encounter some variants of JMP related on the encoding size and addresing range. For small jumps is more efficient to use shorter versions of JMP: JMP SHORT, encoded in two bytes, the operand is a signed 8-bit offset from the next instruction. Range: -128 to +127 bytes. Very compact, commonly used for small local jumps like skipping a few instructions. JMP NEAR; encoded in 5 bytes, the operand is a signed 32-bit offset within the same code segment. JMP FAR; encoded in more than 7 bytes, the operand is in a different code segment. A quick reminder of all the covered unconditional control flow instructions: Instruction Type Stack Impact Use Case JMP Unconditional Control Flow None Direct control transfer CALL Unconditional Control Flow Pushes return address Function calls RET Unconditional Control Flow Pops return address Function returns 3. Conditional Control Flow. Conditional control flow allows programs to make decisions and execute different code paths based on runtime conditions. 3.1. FLAGS register (RFLAGS in x64 bits). The FLAGS register, originally 16-bits, EFLAGS in 32-bit and RFLAGS in 64-bit, is a special-purpose register that holds status information about the result of the most recent arithmetic or logical operation, plus control bits that affect CPU behavior. EFLAGS Register Layout (32-bit) Bit: 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|ID|VP|VF|AC|VM|RF| |NT| IOPL |OF|DF|IF|TF|SF|ZF| |AF| |PF| |CF| | | | | | | | | | | | |IP|IF| | | | 0| | | | | | | | | 0| | 0| | 1| | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ The 32 uppers bits of RFLAGS are set to 0 and not used. Flag Definitions Bit Flag Full Name Type 0 CF Carry Flag Status 2 PF Parity Flag Status 4 AF Auxiliary Carry Flag Status 6 ZF Zero Flag Status 7 SF Sign Flag Status 8 TF Trap Flag System 9 IF Interrupt Enable Flag System 10 DF Direction Flag Control 11 OF Overflow Flag Status 12-13 IOPL I/O Privilege Level System 14 NT Nested Task System 16 RF Resume Flag System 17 VM Virtual-8086 Mode System 18 AC Alignment Check System 19 VIF Virtual Interrupt Flag System 20 VIP Virtual Interrupt Pending System 21 ID ID Flag System Flag Types Type Description S (Status) Modified by arithmetic/logical instructions (CF, PF, AF, ZF, SF, OF) C (Control) Controls CPU behavior for string operations (DF) X (System) Used by OS/hardware, privileged operations Reserved Bits Bit Fixed Value 1 Always 1 3 Always 0 5 Always 0 15 Always 0 22-31 Always 0 Note: Reserved bit positions should not be modified. Always preserve their values when writing to EFLAGS. Each bit in FLAGS represents a specific condition which manifest as a specific flag with his own iterpretation: ZF (Zero Flag): set to 1 if the result was zero. SF (Sign Flag): reflects the most significant bit of the result, indicating whether it's negative in signed interpretation. CF (Carry Flag): set when an unsigned operation overflows or underflows, (if you add two 32-bit values and the result needs a 33rd bit, CF gets set). OF (Overflow Flag): set when a signed operation produces a result that doesn't fit in the destination. This happens when adding two positive numbers gives a negative result (or vice versa). PF (Parity Flag): set if the low byte of the result has an even number of 1-bits. Mostly a legacy thing, occasionally used in floating-point comparisons. AF (Auxiliary Carry Flag): carry out of bit 3, used for BCD arithmetic. You'll rarely see this in modern code. Flag Bit Set when… ZF (Zero) 6 Result is zero SF (Sign) 7 Result is negative (MSB = 1) CF (Carry) 0 Unsigned overflow/underflow OF (Overflow) 11 Signed overflow FLAGS is fundamentally different from general-purpose registers. It's not a register you manipulate directly with x64 instructions (like MOV), instead, it's automatically updated as a side effect of arithmetic and logical operations (barely allmost of the instructions that performs an arithmetic/logical operation do internally modify bits from the FLAGS register), and then read implicitly by teh so called "conditional instructions". User almost never read directly FLAGS register, instead, use instructions which implicitly check specific bits of the register and act on them, this is what are known as the Conditional Instructions. 3.2. Conditional Instructions. 3.2.1. CMP, Compare. CMP (compare) is used to compare two operands by performing a subtraction without storing the result. It only modifies the FLAGS register, with which subsequent conditional instruction will make decisions. The sintax is: CMP destination, source Where destination and source can be memory address in form of r/mX, register, or immediate value (You cannot compare memory-to-memory directly; one operand must be a register or immediate). Internally, CMP computes destination - source and discards the result, but sets flags based on what that result would have been. This is identical to SUB except the destination remains unchanged. Thus, for example, and in order to provide full ilustration about the FLAGS register behaviour, when the CPU executes CMP, it review the result and modify some bit on FLAGS register , for example: If destination == source, subtraction yields 0, and ZF (6th bit) is set to one. If destination != source, and the most significant byte of the result is 1, then the result is negative as a signed value and SF (7th bit) is set up. Note that depending that if it is signed or unsigned comparison different bit-flags would be affeced. And so on. 3.2.2. TEST, logical comparison. TEST instruction is the logical equivalent of what CMP is to SUB—a non-destructive way to check conditions. TEST performs a bitwise AND between two operands, discards the result, and updates FLAGS based on what that result would have been. TEST destination, source Where destination and source can be either a register, a memory address in r/mX form and an immediate value (rememeber that operation between memory address are not allowed). Internally computes "destination AND source", throws away the result, sets flags. The operands remain unchanged (the difference between AND and TEST is that AND stores the result while TEST not). Flag Behavior ZF Set if result is zero (no overlapping bits) SF Copies MSB of result (sign in two's complement interpretation) PF Set if low byte has even number of 1-bits CF Always cleared to 0 OF Always cleared to 0 AF Undefined 3.2.3. Arithmetic Instructions. Most arithmetic operations (ADD, SUB, AND, OR, XOR, etc.) also set flags. 3.2.4. Conditional Jump Instructions. Jcc. As we saw before, JMP is an instruction that control unconditionally the flow of execution of the program by modifying RIP instruction with a destination address. In conditional control flow, there are conditional variants of JMP instruction. This is, instructions that behaviours as JMP under certains circunstances; if a condition is true, the jump is taken: jmp variant Condition Description je/jz ZF = 1 Jump if equal/zero jne/jnz ZF = 0 Jump if not equal/not zero js SF = 1 Jump if negative jns SF = 0 Jump if non-negative jg/jnle ZF=0 &amp; SF=OF Jump if greater (signed) jge/jnl SF = OF Jump if greater or equal (signed) jl/jnge SF ≠ OF Jump if less (signed) jle/jng ZF=1 or SF≠OF Jump if less or equal (signed) ja/jnbe CF=0 &amp; ZF=0 Jump if above (unsigned) jae/jnb CF = 0 Jump if above or equal (unsigned) jb/jnae CF = 1 Jump if below (unsigned) jbe/jna CF=1 or ZF=1 Jump if below or equal (unsigned) jo OF = 1 Jump if overflow jno OF = 0 Jump if not overflow Note that, besides there are different instructions names (like for example je and jz), al behaves the same way if a condition is met and in order to check that condition both consults the same bit-flag from the RFLAGS register. Thus, to conditional jumps are equals o the same if checks the same bit-flag (lie je and jz). 3.2.5. Conditional Moves and Set. As well as conditional jumps, there are also conditional moves: Instruction Condition Description cmove/cmovz ZF = 1 Move if equal/zero cmovne/cmovnz ZF = 0 Move if not equal/not zero cmovs SF = 1 Move if negative cmovns SF = 0 Move if non-negative cmovg/cmovnle ZF=0 &amp; SF=OF Move if greater (signed) cmovge/cmovnl SF = OF Move if greater or equal (signed) cmovl/cmovnge SF ≠ OF Move if less (signed) cmovle/cmovng ZF=1 or SF≠OF Move if less or equal (signed) cmova/cmovnbe CF=0 &amp; ZF=0 Move if above (unsigned) cmovae/cmovnb CF = 0 Move if above or equal (unsigned) cmovb/cmovnae CF = 1 Move if below (unsigned) cmovbe/cmovna CF=1 or ZF=1 Move if below or equal (unsigned) cmovo OF = 1 Move if overflow cmovno OF = 0 Move if not overflow And conditional set bits: Instruction Condition Description sete/setz ZF = 1 Set byte if equal/zero setne/setnz ZF = 0 Set byte if not equal/not zero sets SF = 1 Set byte if negative setns SF = 0 Set byte if non-negative setg/setnle ZF=0 &amp; SF=OF Set byte if greater (signed) setge/setnl SF = OF Set byte if greater or equal (signed) setl/setnge SF ≠ OF Set byte if less (signed) setle/setng ZF=1 or SF≠OF Set byte if less or equal (signed) seta/setnbe CF=0 &amp; ZF=0 Set byte if above (unsigned) setae/setnb CF = 0 Set byte if above or equal (unsigned) setb/setnae CF = 1 Set byte if below (unsigned) setbe/setna CF=1 or ZF=1 Set byte if below or equal (unsigned) seto OF = 1 Set byte if overflow setno OF = 0 Set byte if not overflow 4. Examples. 4.1. If Example1. Consider the following C code: int main(){ int a = -1, b = 2; if(a == b){ return 1; } if(a &gt; b){ return 2; } if(a &lt; b){ return 3; } return 0xdefea7; } The code initialize two integers and the return value varies on several comparisons. Thus, lets retrieve the assembly of this code, first from MCVS 2019: 0000000140001000 48 83 EC 18 sub rsp,18h 0000000140001004 C7 44 24 04 FF FF FF FF mov dword ptr [a],0FFFFFFFFh 000000014000100C C7 04 24 02 00 00 00 mov dword ptr [rsp],2 0000000140001013 8B 04 24 mov eax,dword ptr [rsp] 0000000140001016 39 44 24 04 cmp dword ptr [a],eax 000000014000101A 75 07 jne main+23h (0140001023h) 000000014000101C B8 01 00 00 00 mov eax,1 0000000140001021 EB 25 jmp main+48h (0140001048h) 0000000140001023 8B 04 24 mov eax,dword ptr [rsp] 0000000140001026 39 44 24 04 cmp dword ptr [a],eax 000000014000102A 7E 07 jle main+33h (0140001033h) 000000014000102C B8 02 00 00 00 mov eax,2 0000000140001031 EB 15 jmp main+48h (0140001048h) 0000000140001033 8B 04 24 mov eax,dword ptr [rsp] 0000000140001036 39 44 24 04 cmp dword ptr [a],eax 000000014000103A 7D 07 jge main+43h (0140001043h) 000000014000103C B8 03 00 00 00 mov eax,3 0000000140001041 EB 05 jmp main+48h (0140001048h) 0000000140001043 B8 A7 FE DE 00 mov eax,0DEFEA7h 0000000140001048 48 83 C4 18 add rsp,18h 000000014000104C C3 ret First, it extends the stackframe to make space for the local variables. sub rsp,18h Then, assign the initialized local variables: mov dword ptr [a],0FFFFFFFFh ; a = -1 mov dword ptr [rsp],2 ; b = 2 Now the compiler moves the 'b' local variable value to a register in order to operate with it and 'a', since is not allowed to compare (CMP) data accesing to memrory address at once in x86. mov eax,dword ptr [rsp] Then comes the if statement. This is constituted with two instructions: First, the CMP instruction performs the substraction between the two values and modify the RFLAGS register bits. Then, depending of the specific comparison, a variant of JMP follows the CMP instruction, in this case, in C the if statement is evaluating if "a==b" so the JMP variant is JNE which checks if the ZF bit of the RFLAGS register is up. If it is jumps the target address which is the next CMP statement kit: cmp dword ptr [a],eax jne main+23h (0140001023h) If not, it means that the comparison is true and simply enters the if block, this is, move into EAX the return value and jump to the RET instruction which would be the end of the code: mov eax,1 jmp main+48h (0140001048h) Then, it comes the following if-statement, note that the compiler moves again the rsp value to eax in a unoptimized compiler move: mov eax,dword ptr [rsp] cmp dword ptr [a],eax jle main+33h (0140001033h) mov eax,2 jmp main+48h (0140001048h) Note that the operation is barely the same buit this time, instead of use JNE, is using JLE which checks (ZF=1 || SF!=OF), this means; evaluates if the two values are equal or if, first, if the sign bit is up without an overflow being happened (SF=1, OF=0), second, if the result is positive with an overflow (SF=0, OF=1). Note that both cases means that b is greater than a; one because the substraction "a-b" is negative or two, because "a-b" is positive but overflowing, which means in fact is negative but it gets wrapped over positive due to hardware limitations. Note that always the if-statement is checking the opposite event: a &gt; b; a greater than b. By default the flow execution prones to enter the if-block, only if this is false, jumps to another part. Lastly, the last if statement which is pretty the same of the two cases above: mov eax,dword ptr [rsp] cmp dword ptr [a],eax jge main+43h (0140001043h) mov eax,3 jmp main+48h (0140001048h) Thus, the logic of an if-statement in assembly is to implement first a comparison with CMP instruction and set the bits of RFLAGS register, then implements a variant of JMP instruction that evaluates if the if condition is false and it is skip the if block code (is not, it just enters). Let's check the same C code compiled with GCC and extracted with radare2: $ r2 -e asm.sub.var=false -A -qc "aaa; s main;pdf" test Warning: run r2 with -e bin.cache=true to fix relocations in disassembly ; DATA XREF from entry0 @ 0x1058 ┌ 74: int main (int argc, char **argv, char **envp); │ ; var int64_t var_8h @ rbp-0x8 │ ; var signed int var_4h @ rbp-0x4 │ 0x00001129 f30f1efa endbr64 │ 0x0000112d 55 push rbp │ 0x0000112e 4889e5 mov rbp, rsp │ 0x00001131 c745f8ffffff. mov dword [rbp - 8], 0xffffffff ; -1 │ 0x00001138 c745fc020000. mov dword [rbp - 4], 2 │ 0x0000113f 8b45f8 mov eax, dword [rbp - 8] │ 0x00001142 3b45fc cmp eax, dword [rbp - 4] │ ┌─&lt; 0x00001145 7507 jne 0x114e │ │ 0x00001147 b801000000 mov eax, 1 │ ┌──&lt; 0x0000114c eb23 jmp 0x1171 │ ││ ; CODE XREF from main @ 0x1145 │ │└─&gt; 0x0000114e 8b45f8 mov eax, dword [rbp - 8] │ │ 0x00001151 3b45fc cmp eax, dword [rbp - 4] │ │┌─&lt; 0x00001154 7e07 jle 0x115d │ ││ 0x00001156 b802000000 mov eax, 2 │ ┌───&lt; 0x0000115b eb14 jmp 0x1171 │ │││ ; CODE XREF from main @ 0x1154 │ ││└─&gt; 0x0000115d 8b45f8 mov eax, dword [rbp - 8] │ ││ 0x00001160 3b45fc cmp eax, dword [rbp - 4] │ ││┌─&lt; 0x00001163 7d07 jge 0x116c │ │││ 0x00001165 b803000000 mov eax, 3 │ ┌────&lt; 0x0000116a eb05 jmp 0x1171 │ ││││ ; CODE XREF from main @ 0x1163 │ │││└─&gt; 0x0000116c b8a7fede00 mov eax, 0xdefea7 │ │││ ; CODE XREFS from main @ 0x114c, 0x115b, 0x116a │ └└└──&gt; 0x00001171 5d pop rbp └ 0x00001172 c3 ret We can see that this time the code is barely the same, introduce the data in the local variables and start comparing the code with the same structure than the code generated by MCSV 2019, the if-statement are the composition of two instructions CMP (which evaluates the substraction of the two operands) and a variant of JMP instruction, which depends of the operation performed by the if condition and evalutes the opposite condition. If is true skip the if block if not, continues and enters the if-block code. 4.2. If example2. Consider the following C code: int main(){ unsigned int a = -1, b = 2; if(a == b){ return 1; } if(a &gt; b){ return 2; } if(a &lt; b){ return 3; } return 0xdefea7; } The only difference between this code and the code above is the intergers variables are now unsigned, the dissasembly of MCSV 2019 0000000140001000 48 83 EC 18 sub rsp,18h 0000000140001004 C7 44 24 04 FF FF FF FF mov dword ptr [a],0FFFFFFFFh 000000014000100C C7 04 24 02 00 00 00 mov dword ptr [rsp],2 0000000140001013 8B 04 24 mov eax,dword ptr [rsp] 0000000140001016 39 44 24 04 cmp dword ptr [a],eax 000000014000101A 75 07 jne main+23h (0140001023h) 000000014000101C B8 01 00 00 00 mov eax,1 0000000140001021 EB 25 jmp main+48h (0140001048h) 0000000140001023 8B 04 24 mov eax,dword ptr [rsp] 0000000140001026 39 44 24 04 cmp dword ptr [a],eax 000000014000102A 76 07 jbe main+33h (0140001033h) 000000014000102C B8 02 00 00 00 mov eax,2 0000000140001031 EB 15 jmp main+48h (0140001048h) 0000000140001033 8B 04 24 mov eax,dword ptr [rsp] 0000000140001036 39 44 24 04 cmp dword ptr [a],eax 000000014000103A 73 07 jae main+43h (0140001043h) 000000014000103C B8 03 00 00 00 mov eax,3 0000000140001041 EB 05 jmp main+48h (0140001048h) 0000000140001043 B8 ED A7 FE DE mov eax,0DEFEA7EDh 0000000140001048 48 83 C4 18 add rsp,18h 000000014000104C C3 ret Let's observe that, despite the if-statements are the same than in the other code, the JMP variants are differents. This means that the compilers generates code based on the datatype written by the user. The choice of conditional jump instruction (JA/JB/JAE/JBE for unsigned vs. JG/JL/JGE/JLE for signed) reveals the original variable's signedness—useful for reconstructing type information when analyzing binaries. In the other hand; It turns out that for instructions that set status flags (e.g. arithmetic operations), the hardware just does the operation and sets flags as if the operands were both unsigned and signed. Basically the hardware doesn't know or care about whether the humans are currently interpreting the bits as signed or unsigned. That's the compiler's problem to sort out. 4.3. Switch Example. Consider the following C code: #include &lt;stdlib.h&gt; int main(int argc, char* argv[]) { int a = atoi(argv[1]); switch (a) { case 0: return 1; case 1: return 2; default: return 3; } return 0xfee1fed; } In this case, we have a SWITCH directive that evaluates the input that the user-provides through the cli-parameter and provides three cases. The dissasembly shows that the compiler treats the switch directive as if were a bunch of if-statements: 0000000140001000 48 89 54 24 10 mov qword ptr [rsp+10h],rdx 0000000140001005 89 4C 24 08 mov dword ptr [rsp+8],ecx 0000000140001009 48 83 EC 38 sub rsp,38h 000000014000100D B8 08 00 00 00 mov eax,8 0000000140001012 48 6B C0 01 imul rax,rax,1 0000000140001016 48 8B 4C 24 48 mov rcx,qword ptr [argv] 000000014000101B 48 8B 0C 01 mov rcx,qword ptr [rcx+rax] 000000014000101F FF 15 53 31 00 00 call qword ptr [__imp_atoi (0140004178h)] 0000000140001025 89 44 24 24 mov dword ptr [a],eax 0000000140001029 8B 44 24 24 mov eax,dword ptr [a] 000000014000102D 89 44 24 20 mov dword ptr [rsp+20h],eax 0000000140001031 83 7C 24 20 00 cmp dword ptr [rsp+20h],0 0000000140001036 74 09 je main+41h (0140001041h) 0000000140001038 83 7C 24 20 01 cmp dword ptr [rsp+20h],1 000000014000103D 74 09 je main+48h (0140001048h) 000000014000103F EB 0E jmp main+4Fh (014000104Fh) 0000000140001041 B8 01 00 00 00 mov eax,1 0000000140001046 EB 13 jmp main+5Bh (014000105Bh) 0000000140001048 B8 02 00 00 00 mov eax,2 000000014000104D EB 0C jmp main+5Bh (014000105Bh) 000000014000104F B8 03 00 00 00 mov eax,3 0000000140001054 EB 05 jmp main+5Bh (014000105Bh) 0000000140001056 B8 ED 1F EE 0F mov eax,0FEE1FEDh 000000014000105B 48 83 C4 38 add rsp,38h 000000014000105F C3 ret It is worth to note that this code is compiled and extracted in MCVS 2019 and follows Microsoft x64 ABI standards, thus, is worth to break down the first instructions: First, is setting the argc and argv arguments which come from RCX and RDX (standard in ABI convention). This is possible due to the shadow space alloced by the caller of main. mov qword ptr [rsp+10h],rdx mov dword ptr [rsp+8],ecx Then, it allocates the shadow space for the atoi() function: sub rsp,38h Lastly, it introduces in RCX the argument of atoi() which is argv[1]: 000000014000100D B8 08 00 00 00 mov eax,8 0000000140001012 48 6B C0 01 imul rax,rax,1 0000000140001016 48 8B 4C 24 48 mov rcx,qword ptr [argv] 000000014000101B 48 8B 0C 01 mov rcx,qword ptr [rcx+rax] Note that, is a convoluted way to introduce the word size (in x64, which is the size of a pointer) into RAX and then add it to the argv pointer, the result is in terms of pointer arithmetics, argv + 1 or argv[1] being stored in RCX.]]></summary></entry><entry><title type="html">Integer Overflow/Underflow.</title><link href="http://localhost:4000/posts/2025/12/05/IntegerOverflow-Underflow/" rel="alternate" type="text/html" title="Integer Overflow/Underflow." /><published>2025-12-05T10:00:00+01:00</published><updated>2025-12-05T10:00:00+01:00</updated><id>http://localhost:4000/posts/2025/12/05/IntegerOverflow-Underflow</id><content type="html" xml:base="http://localhost:4000/posts/2025/12/05/IntegerOverflow-Underflow/"><![CDATA[<h3 id="1-integer-overflowunderflow-vulnerabilities-introduction">1. Integer Overflow/Underflow vulnerabilities introduction.</h3>

<p>Integer Overflow/Undwerflow vulnerabilities referer a vulnerability form in which an attacker leverage cases in which is possible that signed and unsigned integers exceeds their positive and negative value ranges due to egdy math cases.</p>

<p>Before enter in a further explanation, let's take a reminder on how signed and unsigned data types works in C.</p>

<p><br /></p>

<h4 id="11-values-and-datatypes">1.1. Values and Datatypes.</h4>

<p><strong>Value and Datatypes definition</strong></p>

<p>Let's start in the beginning, building the idea of <em>value</em> and <em>datatype</em>.</p>

<ul>
  <li>
    <p>A <em>value</em> is nothing but an abstraction of a piece of information stored in memory in form of binary bits waiting to be processed by the CPU.</p>
  </li>
  <li>
    <p>A <em>datatype</em> tells the compiler how to interpret and store that value in memory. It defines two critical things:</p>

    <ol>
      <li>
        <p>The size of the value; this is <em>how many bytes to allocate</em>; (char, short, integer, …, array, struct,…).</p>
      </li>
      <li>
        <p>The sign of the value; or <em>how to interpret the bit pattern stored there</em> (signed/unsigned). The same bit pattern 0xFF could mean 255 or -1 depending on how the compiler interprets it.</p>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<p><strong>Signed vs Unsigned</strong></p>

<p>The sign of a value is also related with the datatype it self, because there are datatypes in which make a signed/unsigned distinction does not make sense. <em>The signed/unsigned distinction only applies to integer types</em> (char, short, int, long, etc.) because it's about how to interpret a fixed sequence of bits as a number. Floating-point types, structs, pointers does not have an unsigned version.</p>

<ul>
  <li>
    <p><em>Unsigned integers</em> use all bits to represent magnitude. An 8-bit unsigned value ranges from 0 to 255 (2⁸ - 1). Every bit pattern maps directly to a non-negative number.</p>
  </li>
  <li>
    <p><em>Signed integers</em> uses the most significant bit to encode sign information, is called the sign bit. Using two's complement representation (which is universal on modern systems), an 8-bit signed value ranges from -128 to 127. The bit pattern 0xFF becomes -1 rather than 255.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="12-twos-complement-signed-numbers">1.2. Two's Complement Signed Numbers.</h4>

<p>Two's complement is the standard way that C (and most modern computers) represents signed integers (positive and negative whole numbers).</p>

<p>In this representation, the leftmost (or more significant bit) serves also as an indicator to notice the sign of the value:</p>

<ul>
  <li>'0' to positive numbers; 01111111b = 127</li>
  <li>'1' to negative numbers. 10000000b = -128</li>
</ul>

<p>Thus, let's suppose we have a binary number, lets say <em>x</em>, the complement's convention says that in order to represent <em>-x</em> we have to flip all the bits (0→1, 1→0) this is called the one's complement and then add 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Positive number: 5

- 00000101b 

Negative number: -5

- Step 1: Start with 5:     00000101
- Step 2: Flip all bits:     11111010  (one's complement)
- Step 3: Add 1:             11111011  = -5 (two's complement)
</code></pre></div></div>

<p>The formula to obtain the decimal value from a signed integer binary number is applying a negative sign to sign bit in the standard base system operation, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11111011 = -1*2^7 + 1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 = -128 + 123 = -5
</code></pre></div></div>

<p><br /></p>

<h4 id="13-range-of-a-datatype">1.3. Range of a datatype.</h4>

<p>A word about the range. A <em>range</em> is simply the set of all possible values a datatype can represent and is not an arbitrary decision but a direct consequence of having finite storage capacity. Memory is organized into units of 8-bits each (also called byte), and CPUs have registers of fixed widths: 8, 16, 32, or 64 bits on modern systems. This means that, often, you only have at most 64 bits (possibles 0 or 1) to store a binary value which represents data, this also means that every datatype has a finite range.</p>

<p>For signed integers, the absolute value decrements in a half compared with the unsigned type and, for example, to a 8 bits value, the maximum unsigned value is 11111111b, which in decimal is 255. But, for the signed type, by convention, since the leftmost bit is consider the sign bit, then the further value from zero is 1111111b = 127.</p>

<p>It happens that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n-bit signed integer --&gt; the range is: -2^(n-1) to 2^(n-1) - 1
</code></pre></div></div>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>binary</th>
      <th>hex</th>
      <th>unsigned decimal</th>
      <th>signed decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00000000</td>
      <td>00</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>00000001</td>
      <td>01</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>00000010</td>
      <td>02</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>00000011</td>
      <td>03</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>01111110</td>
      <td>7E</td>
      <td>126</td>
      <td>126</td>
    </tr>
    <tr>
      <td>01111111</td>
      <td>7F</td>
      <td>127</td>
      <td>127</td>
    </tr>
    <tr>
      <td>10000000</td>
      <td>80</td>
      <td>128</td>
      <td>-128</td>
    </tr>
    <tr>
      <td>10000001</td>
      <td>81</td>
      <td>129</td>
      <td>-127</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>11111110</td>
      <td>FE</td>
      <td>254</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>11111111</td>
      <td>FF</td>
      <td>255</td>
      <td>-1</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>This exact principle showed with 8-bits can be extended also to 16,32 and 64 bits numbers:</p>

<ul>
  <li>8-bit signed (char): -128 to 127</li>
  <li>16-bit signed (short): -32,768 to 32,767</li>
  <li>32-bit signed (int): -2,147,483,648 to 2,147,483,647</li>
</ul>

<p><br /></p>

<h3 id="2-integer-overflow-definition">2. Integer Overflow Definition.</h3>

<p>At this moment, with the having introduced the previous terms, we are now in conditions to provide a definition.</p>

<p><br /></p>

<h4 id="21-unsigned-overflowunderflow">2.1. Unsigned Overflow/Underflow.</h4>

<p>Let's consider the following trivial code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div>

<p>In the code above, an unsigned char gets defined with value 0 and then a while loop starts increasing the value of <em>i</em> once at a time.</p>

<p>As de loops iterates, i value increases but since char size is one byte, it only can store 8-bits, so eventually:</p>

<table>
  <thead>
    <tr>
      <th>iteration</th>
      <th>uchar (binary)</th>
      <th>uchar (hex)</th>
      <th>uchar (decimal)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>254</td>
      <td>11111110</td>
      <td>FE</td>
      <td>254</td>
    </tr>
    <tr>
      <td>255</td>
      <td>11111111</td>
      <td>FF</td>
      <td>255 (Upper-top range)</td>
    </tr>
    <tr>
      <td>256</td>
      <td>1(00000000)</td>
      <td>1(00)</td>
      <td>0</td>
    </tr>
    <tr>
      <td>257</td>
      <td>000000001</td>
      <td>01</td>
      <td>1</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<p>What is happenning is that the CPU is perfoming the correct calculation which is 11111111 + 1 = 100000000 (a 9-bit value) and is storing it in a 8-bit size chunk, so as the result, the most significant bit is left out and what is stored at the chunk is the value 00000000, restarting the value of <em>i</em>. This is what we call <em>Unsigned Overflow</em>.</p>

<p>This can be resumed as the following rule: <strong>All the operations performed over an unsigned datatype are modular operations with module 2^N where N is the bit-width of the type</strong>.</p>

<p><em>Unsigned overflow</em> is well-defined in C. The standard explicitly says unsigned arithmetic wraps modulo 2^n. If you add 1 to UINT_MAX, you get 0. This is guaranteed, portable behavior. The opposite case, going behind 0 to obtain instantetly the biggest value posible is what we call <em>Signed Underflow</em>.</p>

<p><br /></p>

<h4 id="22-signed-overflowunderflow">2.2. Signed Overflow/Underflow.</h4>

<p>Signed Integers, as discussed before, have a different design than unsigned datatypes. Since both entities are confined within a finite storage capacity both share range boundaries and the overflow type related to the range boundaries discussed above.</p>

<p>But signed integers also leads to another type of overflow dealing with the change of sign. Let's start saying negativity is a decimal-level abstraction. At the binary level, you just have rings of integers mod 2^n, and two's complement is the isomorphism that maps the upper half of that ring onto negative numbers in a way that preserves additive structure.</p>

<p>Lets dive on how this isomorphism works. By definition, if we have a value 'x' in a set o numbers, his negative is that number in the set which add to 0 with 'x':</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x + (-x) = 0
</code></pre></div></div>

<p>Let's consider a binary value of 8-bit wide, 00000011 (3) if we calculate the negative through the two's complement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = 1 --&gt; -x = 11111110 + 1 = 11111111 = 255
x = 2 --&gt; -x = 11111101 + 1 = 11111110 = 254
x = 3 --&gt; -x = 11111100 + 1 = 11111101 = 253
x = 4 --&gt; -x = 11111011 + 1 = 11111100 = 252
...
</code></pre></div></div>

<p>We can see a clear pattern, as we go on the values from the lower limit of the range (0), his negative correspondient value is the homologous value startint from te upper limit (256) and the flow of both values advance to opposite directions so they are meant to encounter each other at the half of the track.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = 126 --&gt; -x = 10000001 + 1 = 10000010 = 130
x = 127 --&gt; -x = 10000000 + 1 = 10000001 = 129
x = 128 --&gt; -x = 01111111 + 1 = 10000000 = 128 &lt;-- Inflection point
x = 129 --&gt; -x = 01111110 + 1 = 01111111 = 127
x = 130 --&gt; -x = 01111101 + 1 = 01111110 = 126
</code></pre></div></div>

<p>Thus, we can assume the convention that from 127 all the numbers above are the negative counter part of the half below 127.</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>binary</th>
      <th>unsigned decimal</th>
      <th>signed decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00000000</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>00000001</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>00000010</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>00000011</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>01111110</td>
      <td>126</td>
      <td>126</td>
    </tr>
    <tr>
      <td>01111111</td>
      <td>127</td>
      <td>127</td>
    </tr>
    <tr>
      <td>10000000</td>
      <td>128</td>
      <td>-128</td>
    </tr>
    <tr>
      <td>10000001</td>
      <td>129</td>
      <td>-127</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>11111110</td>
      <td>254</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>11111111</td>
      <td>255</td>
      <td>-1</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>Thus, in any modular 2^N ring the values increases until some threshold is reached (the half of the ring) and then the value goes from being the highest value to the smallest one, this is what we call <em>Signed Overflow</em>. The opposite case, when the values decreases until goes from the smallest value to the highest one is called <em>Signed Underflow</em>. Signed overflow is undefined behavior in C. The standard says the compiler can assume it never happens, which means if your code allows it to happen, the compiler is free to do anything: wrap around, saturate, crash, optimize away your bounds check, or summon demons. In practice, most compilers on most platforms will wrap using two's complement (so INT_MAX + 1 becomes INT_MIN).</p>

<p>Let's note again that negativity is just a convention, we explain how positive and negative values are relate between them using the 'negative' and two's complement definitions only in behalf of clarity. Negative and substraction are concepts tightly related and is easier to think about them because we are made to an infinite set of numbers. In fact, in modular rings as 8-bit width binary values negativness is a direct consecuence of the modular nature of the ring:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127 + (-127) = 01111111 + 10000001 = 1(00000000)
</code></pre></div></div>

<p>Also the risk of this effect and the reason why this leads into a vulnerability is also a consecuence of the modular nature of the set of numbers.</p>

<p><br /></p>

<h4 id="23-conclusion-and-explaning-the-risk">2.3. Conclusion and explaning the risk.</h4>

<p>Integer overflows shows them selfs as vulnerabilties due to "under-allocation" and "over-copy", for examples:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Assume var is user-controlled</span>
<span class="n">malloc</span><span class="p">(</span><span class="n">var1</span> <span class="o">+</span> <span class="k">const</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="n">var1</span> <span class="o">+</span> <span class="n">var2</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="n">var1</span> <span class="o">*</span> <span class="k">const</span><span class="p">)</span>
</code></pre></div></div>

<p>All of this allocations present issues of having underallocation.</p>

<p>If again this number is used to copy data with checking the memory chunk allocated:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">var1</span><span class="p">)</span>
</code></pre></div></div>

<p>This can be an over-copy.</p>

<p><br /></p>

<h3 id="3-examples">3. Examples.</h3>

<h4 id="31-trivial-example">3.1. Trivial Example:</h4>

<p>Let's check the following code.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">my_header</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_header_t</span><span class="p">;</span>

<span class="c1">// Under-allocate, over-copy – uaoc.c</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="n">my_header_t</span> <span class="n">header</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_size</span><span class="p">;</span>

    <span class="n">header</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x6f6e6558</span><span class="p">;</span>
    <span class="n">header</span><span class="p">.</span><span class="n">size</span>  <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">alloc_size</span>   <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"String self-reported size = 0x%08lX</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Allocation size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"buf points to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"memcpy()ing 0x%08lX bytes into buf of size 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"We copied input string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we check the code, we can see that some user-controlled data <em>argv[1}</em> is being stored on <em>size</em> field of <em>header</em> struct and inmediately without sanitization, this same value is used to allocate memory space:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">header</span><span class="p">.</span><span class="n">size</span>  <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="n">alloc_size</span>   <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
</code></pre></div></div>

<p>Thus, let's observe that, since <em>header.size</em> is arbitrary and <em>my_header_t</em> struct have two fields (two longs), <em>then sizeof(my_header_t)</em> in x64 is 16 bytes and the unsigned int in x64 has 4 bytes in size, so is a value within a range between 0 and 2^(4<em>8) = 2^32 (4 bytes, 8 bits each byte) = 4294967296, thus if the user enters 4294967280 (4294967296 - 16) *alloc_size</em> would be overflow an turn 0, this means that this code can easily turns into an underallocation.</p>

<p>Later, the pointer is used as a destination in a <em>memcpy()</em> operation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<p>The reuslt is overcopying:</p>

<pre><code class="language-less">OUTPUT:
$ ./test 4294967280 hello
String self-reported size = 0xFFFFFFF0
Allocation size = 0x00000000
buf points to 0x58449e0336b0
memcpy()ing 0xFFFFFFF0 bytes into buf of size 0x00000000
Segmentation fault (core dumped)
</code></pre>

<p><br /></p>

<h4 id="32-freertos">3.2. FreeRTOS.</h4>

<p>Lets consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pvPortMalloc</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">xWantedSize</span> <span class="p">)</span> <span class="p">{</span><span class="n">v</span><span class="c1">//user-controlled - xWantedSize </span>
    <span class="n">BlockLink_t</span> <span class="o">*</span><span class="n">pxBlock</span><span class="p">,</span> <span class="o">*</span><span class="n">pxPreviousBlock</span><span class="p">,</span> <span class="o">*</span><span class="n">pxNewBlockLink</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">BaseType_t</span> <span class="n">xHeapHasBeenInitialised</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">pvReturn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">vTaskSuspendAll</span><span class="p">();</span>
    <span class="p">{</span>
        <span class="cm">/* If this is the first call to malloc then the heap
         * initialisation to setup the list of free blocks. */</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">xHeapHasBeenInitialised</span> <span class="o">==</span> <span class="n">pdFALSE</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">prvHeapInit</span><span class="p">();</span>
            <span class="n">xHeapHasBeenInitialised</span> <span class="o">=</span> <span class="n">pdTRUE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* The wanted size is increased so it can contain a BlockLink_t
         * structure in addition to the requested amount of bytes. */</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">xWantedSize</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">xWantedSize</span> <span class="o">+=</span> <span class="n">heapSTRUCT_SIZE</span><span class="p">;</span>

            <span class="cm">/* Ensure that blocks are always aligned to the required number of bytes. */</span>
            <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">xWantedSize</span> <span class="o">&amp;</span> <span class="n">portBYTE_ALIGNMENT_MASK</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="cm">/* Byte alignment required. */</span>
                <span class="n">xWantedSize</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">portBYTE_ALIGNMENT</span> <span class="o">-</span> <span class="p">(</span> <span class="n">xWantedSize</span> <span class="o">&amp;</span> <span class="n">portBYTE_ALIGNMENT_MASK</span> <span class="p">)</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can see that <em>xWantedSize</em>, which is a <em>size_t</em> datatype (unsigned integer) is user-controlled and used within an if statement performing a math operation with <em>heapSTRUCT_SIZE</em> without validation, thus as we proceed in the case before, we could perform an unsigned overflow.</p>

<p><br /></p>

<h3 id="4-exercises">4. Exercises.</h3>

<h4 id="41-cve-2020-0796-smbghost">4.1. CVE-2020-0796 "SMBGhost".</h4>

<p>CVE-2020-0796, commonly known as SMBGhost, is a critical remote code execution vulnerability discovered in March 2020 that affects Microsoft's SMBv3 (Server Message Block version 3) protocol implementation in Windows 10 and Windows Server versions 1903 and later.</p>

<p>SMB3 supports message compression to reduce network traffic load, message decompression takes place in the srv2.sys kernel driver.</p>

<p><br /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////ACID: The data pointed to by request-&gt;pNetRawBuffer</span>
<span class="kt">signed</span> <span class="n">__int64</span> <span class="kr">__fastcall</span> <span class="nf">Srv2DecompressData</span><span class="p">(</span><span class="n">SRV2_WORKITEM</span> <span class="o">*</span><span class="n">workitem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// declarations omitted</span>
    <span class="p">...</span>
    <span class="n">request</span> <span class="o">=</span> <span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">dwMsgSize</span> <span class="o">&lt;</span> <span class="mh">0x10</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mh">0xC000090B</span><span class="p">;</span>
    <span class="n">compressHeader</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">CompressionTransformHeader</span> <span class="o">*</span><span class="p">)</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">;</span>
    <span class="p">...</span>
   
    <span class="n">newHeader</span> <span class="o">=</span> <span class="n">SrvNetAllocateBuffer</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">compressHeader</span><span class="p">.</span><span class="n">originalCompressedSegSize</span> <span class="o">+</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">newHeader</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mh">0xC000009A</span><span class="p">;</span>
   
    <span class="k">if</span> <span class="p">(</span> <span class="n">SmbCompressionDecompress</span><span class="p">(</span>
                <span class="n">compressHeader</span><span class="p">.</span><span class="n">compressionType</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">[</span><span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span>
                <span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="o">-&gt;</span><span class="n">dwMsgSize</span> <span class="o">-</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="o">-</span> <span class="mi">16</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">newHeader</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">[</span><span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">],</span>
                <span class="n">compressHeader</span><span class="p">.</span><span class="n">OriginalCompressedSegSize</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">finalDecompressedSize</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="o">||</span> <span class="n">finalDecompressedSize</span> <span class="o">!=</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">originalCompressedSegSize</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">SrvNetFreeBuffer</span><span class="p">(</span><span class="n">newHeader</span><span class="p">);</span>
        <span class="k">return</span> <span class="mh">0xC000090B</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memmove</span><span class="p">(</span><span class="n">newHeader</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">,</span> <span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">newHeader</span><span class="o">-&gt;</span><span class="n">dwMsgSize</span> <span class="o">=</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">OffsetOrLength</span> <span class="o">+</span> <span class="n">fianlDecompressedSize</span><span class="p">;</span>
    <span class="n">Srv2ReplaceReceiveBuffer</span><span class="p">(</span><span class="n">workitem</span><span class="p">,</span> <span class="n">newHeader</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, let's go carefully, checking the code, the user controlled data is pointed by <em>request-&gt;pNetRawBuffer</em>, thus:</p>

<ul>
  <li>
    <p>First, <em>compressHeader</em> gets the dereferenced contents of <em>request-&gt;pNetRawBuffer</em>, then some fields of this structure gets used to allocate a buffer presumibly inside the heap:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">compressHeader</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">CompressionTransformHeader</span> <span class="o">*</span><span class="p">)</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">;</span>
   
  <span class="n">newHeader</span> <span class="o">=</span> <span class="n">SrvNetAllocateBuffer</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">compressHeader</span><span class="p">.</span><span class="n">originalCompressedSegSize</span> <span class="o">+</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>This essentially could lead to an underallocation since no check is done after or before the allocation.</p>
  </li>
  <li>
    <p>Later, <em>offsetOrLength</em> field is used to copy memory to the previos allocated buffer which could lead to an overcopy:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="p">){</span>
      <span class="n">memmove</span><span class="p">(</span><span class="n">newHeader</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span><span class="p">,</span> <span class="n">workitem</span><span class="o">-&gt;</span><span class="n">psbhRequest</span><span class="o">-&gt;</span><span class="n">pNetRawBuffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>As a summary, an addition of two user-controlled terms could be used to perform an underallocation due to an unsigned integer overflow, for example if <em>compressHeader.originalCompressedSegSize</em> is small and <em>compressHeader.offsetOrLength</em> was huge always being:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">compressHeader</span><span class="p">.</span><span class="n">originalCompressedSegSize</span> <span class="o">+</span> <span class="n">compressHeader</span><span class="p">.</span><span class="n">offsetOrLength</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">32</span>
</code></pre></div>    </div>

    <p>Then, on the second line, a huge amountn of bytes would be used to write over an small buffer provoking an overcopy resulting in a bufffer overflow.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="42-cve-2019-5105">4.2. CVE-2019-5105.</h4>

<p>CVE-2019-5105 is a critical memory corruption vulnerability affecting 3S-Smart Software Solutions' CODESYS industrial automation platform, specifically in the GatewayService component. While primarily classified as an out-of-bounds write vulnerability, it's related to integer overflow issues in buffer size calculations.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">////ACID: param_1</span>
<span class="kt">void</span> <span class="nf">FUN_00677d70</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">param_1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_5</span> <span class="p">,</span><span class="n">uint</span> <span class="o">*</span><span class="n">param_6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">header_length</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">_Size</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iVar1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iVar2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">receiver_length</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">sender_length</span><span class="p">;</span>
  <span class="cm">/* Omitted code  */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">blkDrvPDUdata</span><span class="p">;</span>
  <span class="cm">/* Omitted code */</span>
  <span class="n">iVar2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_2</span> <span class="o">+</span> <span class="mh">0x128</span><span class="p">)</span> <span class="o">+</span>  <span class="n">DAT_007a3534</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">iVar2</span> <span class="o">&lt;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>
     <span class="cm">/* Omitted code */</span>
    <span class="n">blkDrvPDUdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_1</span><span class="p">;</span>
    <span class="n">header_length</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">sender_length</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
    <span class="n">receiver_length</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">pvVar3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">sender_length</span> <span class="o">+</span> <span class="n">receiver_length</span> <span class="o">+</span> <span class="n">header_length</span><span class="p">);</span>
    <span class="n">local_20c</span> <span class="o">=</span> <span class="n">header_length</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pvVar3</span> <span class="o">&lt;</span> <span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="n">pvVar3</span> <span class="o">==</span> <span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">pvVar3</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="n">header_length</span> <span class="o">+</span> <span class="p">(</span><span class="n">sender_length</span> <span class="o">+</span> <span class="n">receiver_length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">param_6</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_6</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_Size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="o">*</span><span class="n">param_6</span><span class="p">;</span>

        <span class="cm">/* Omitted  code*/</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">local_220</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">local_244</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">))</span> <span class="p">{</span>      
          <span class="cm">/* Omitted  Code*/</span>              
          <span class="k">if</span> <span class="p">(</span><span class="n">local_20c</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">_Size</span> <span class="o">&lt;</span> <span class="mh">0x201</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">local_208</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">local_20c</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">param_1</span> <span class="o">+</span> <span class="o">*</span><span class="n">param_6</span><span class="p">),</span> <span class="n">_Size</span> <span class="p">);</span>
            <span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">local_20c</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">_Size</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">param_1</span><span class="p">,</span><span class="n">local_208</span><span class="p">,(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_5</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">param_1</span> <span class="o">+</span> <span class="n">local_20c</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_4</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_5</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_5</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
            <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="n">local_20c</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">iVar1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">param_6</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_6</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">FUN_006ce8f9</span><span class="p">();</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let's review the code carefully, user-controlled data lies on <em>param_1</em>.</p>

<ul>
  <li>
    <p>First, some declaration are perfomed:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">header_length</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">_Size</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iVar1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iVar2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">receiver_length</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">sender_length</span><span class="p">;</span>
  <span class="cm">/* Omitted code  */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">blkDrvPDUdata</span><span class="p">;</span>
  <span class="cm">/* Omitted code */</span>
  <span class="n">iVar2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">param_2</span> <span class="o">+</span> <span class="mh">0x128</span><span class="p">)</span> <span class="o">+</span>  <span class="n">DAT_007a3534</span><span class="p">;</span>
  <span class="c1">//...</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Then, comes the assignation, in which some variables in the function receives user-controlled data:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">blkDrvPDUdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_1</span><span class="p">;</span>
  <span class="n">header_length</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">sender_length</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
  <span class="n">receiver_length</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">blkDrvPDUdata</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">pvVar3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">sender_length</span> <span class="o">+</span> <span class="n">receiver_length</span> <span class="o">+</span> <span class="n">header_length</span><span class="p">);</span>
  <span class="n">local_20c</span> <span class="o">=</span> <span class="n">header_length</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Essentially, is not hard to see that all of this variables are user-controlled</p>
  </li>
  <li>
    <p>Now, this variables are used to define the copy size, the source and the destination of a memcpy() operation:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">*</span><span class="n">param_6</span> <span class="o">=</span> <span class="n">header_length</span> <span class="o">+</span> <span class="p">(</span><span class="n">sender_length</span> <span class="o">+</span> <span class="n">receiver_length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//User-controlled</span>
  <span class="c1">//...</span>
  <span class="n">_Size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="o">*</span><span class="n">param_6</span><span class="p">;</span> <span class="c1">//Underflow</span>
  <span class="c1">//...</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">local_208</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">local_20c</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">param_1</span> <span class="o">+</span> <span class="o">*</span><span class="n">param_6</span><span class="p">),</span> <span class="n">_Size</span> <span class="p">);</span> <span class="c1">//Overcopy</span>
  <span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">local_20c</span> <span class="o">+</span> <span class="n">_Size_00</span> <span class="o">+</span> <span class="n">iVar1</span> <span class="o">+</span> <span class="n">local_214</span> <span class="o">+</span> <span class="n">_Size</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">param_1</span><span class="p">,</span><span class="n">local_208</span><span class="p">,(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">param_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></div>    </div>

    <p>Let's observe carefully that when _Size filled, if  <em>*param_6</em> &gt; than <em>(int)param_1[1]</em> then, it could result in a negative value that, when cast to unsigned it will transform in a huge positive value leading to an overcopy</p>
  </li>
</ul>

<p><br /></p>

<h4 id="43-cve-2019-14192">4.3. CVE-2019-14192.</h4>

<p>CVE-2019-14192 is an integer overflow vulnerability discovered in U-Boot (Universal Boot Loader), which is one of the most widely used boot loaders for embedded systems.</p>

<p>Firmware fetch the bootloader which in this case is u-boot and this devices loads the OS and this one the rest of the applications.</p>

<p>Let's check the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////ACID: in_packet</span>
<span class="kt">void</span> <span class="nf">net_process_received_packet</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">in_packet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethernet_hdr</span> <span class="o">*</span><span class="n">et</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_udp_hdr</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">dst_ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">src_ip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eth_proto</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ip_udp_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_packet</span> <span class="o">+</span> <span class="n">E802_HDR_SIZE</span><span class="p">);</span>
	<span class="c1">// ...</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">eth_proto</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// ...</span>
	<span class="k">case</span> <span class="n">PROT_IP</span><span class="p">:</span>
		<span class="n">debug_cond</span><span class="p">(</span><span class="n">DEBUG_NET_PKT</span><span class="p">,</span> <span class="s">"Got IP</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="cm">/* Before we start poking the header, make sure it is there */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debug</span><span class="p">(</span><span class="s">"len bad %d &lt; %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">IP_UDP_HDR_SIZE</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Check the packet length */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">debug</span><span class="p">(</span><span class="s">"len bad %d &lt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_len</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_len</span><span class="p">);</span>
		<span class="c1">// ...</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">net_defragment</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ip</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="c1">// ...</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_p</span> <span class="o">==</span> <span class="n">IPPROTO_ICMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">receive_icmp</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">et</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ip_p</span> <span class="o">!=</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Only UDP packets */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// ...</span>
<span class="cp">#if defined(CONFIG_NETCONSOLE) &amp;&amp; !defined(CONFIG_SPL_BUILD)
</span>		<span class="n">nc_input_packet</span><span class="p">((</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_dst</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_src</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UDP_HDR_SIZE</span><span class="p">);</span>
<span class="cp">#endif
</span>		<span class="cm">/*
		 * IP header OK.  Pass the packet to the current handler.
		 */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">udp_packet_handler</span><span class="p">)((</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_dst</span><span class="p">),</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_src</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UDP_HDR_SIZE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="c1">// ...</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let's note the following line:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//...</span>
<span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ip_udp_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_packet</span> <span class="o">+</span> <span class="n">E802_HDR_SIZE</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="cp">#if defined(CONFIG_NETCONSOLE) &amp;&amp; !defined(CONFIG_SPL_BUILD)
</span>		<span class="n">nc_input_packet</span><span class="p">((</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_dst</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_src</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UDP_HDR_SIZE</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>We can see that, the last parameter of the calling of <em>nc_input_packet()</em> function is math operation without validation of any type. We don't need to understand what the function does with that value in order to be able to see that is dangerous and is in fact a vulnerbility.</p>

<p>The same is done just below in the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    * IP header OK.  Pass the packet to the current handler.
    */</span>
<span class="p">(</span><span class="o">*</span><span class="n">udp_packet_handler</span><span class="p">)((</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="n">IP_UDP_HDR_SIZE</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_dst</span><span class="p">),</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_src</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">udp_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UDP_HDR_SIZE</span><span class="p">);</span>
<span class="k">break</span><span class="p">;</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<p>A function is being called thorugh a function pointer and the last parameter is also a math operation without any validation.</p>

<p>(This is not in fact so dangerous as it seems, perhaps the function holds some validation for edgy values?)</p>

<p><br /></p>

<h4 id="44-cve-2020-11901-part-of-ripple20-grab-bag">4.4. CVE-2020-11901. Part of "Ripple20" grab-bag.</h4>

<p>CVE-2020-11901 is really 4 vulnerabilities that got lumped into the same CVE (/ didn’t get assigned their own CVEs), this was discussed before on Linear Stack Buffer Overflow.</p>

<p>This pertains to the parsing of compressed DNS packets. DNS packets have a formatting for hostname strings that breaks them into “labels”, that are prefixed by a label length byte. Multiple labels are separated by a period, the total hostname string is considered complete when a 0 is found for a label length. The DNS spec states that the max label length should be 63 bytes and the hostname length should be 255 bytes.</p>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ACID: RDLENGTH, resourceRecordAfterNamePtr, dnsHeaderPtr</span>
<span class="k">if</span> <span class="p">(</span><span class="n">RDLENGTH</span> <span class="o">&lt;=</span> <span class="n">remaining_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* compute the next resource record pointer based on the RDLENGTH */</span>
	<span class="n">labelEndPtr</span> <span class="o">=</span> <span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">RDLENGTH</span><span class="p">;</span>
	<span class="cm">/* type: MX */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cacheEntryQueryType</span> <span class="o">==</span> <span class="n">DNS_TYPE_MX</span> <span class="o">&amp;&amp;</span> <span class="n">rrtype</span> <span class="o">==</span> <span class="n">DNS_TYPE_MX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr_info</span> <span class="o">=</span> <span class="n">tfDnsAllocAddrInfo</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr_info</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">RDLENGTH</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* copy preference value of MX record */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr_info</span><span class="o">-&gt;</span><span class="n">ai_mxpref</span><span class="p">,</span><span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="cm">/* compute the length of the MX hostname */</span>
			<span class="n">labelLength</span> <span class="o">=</span> <span class="n">tfDnsExpLabelLength</span><span class="p">(</span><span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">,</span> <span class="n">dnsHeaderPtr</span><span class="p">,</span> <span class="n">labelEndPtr</span><span class="p">);</span>
			<span class="n">addr_info</span><span class="o">-&gt;</span><span class="n">ai_mxhostname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">labelLength</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* allocate buffer for the expanded name */</span>
				<span class="n">asciiPtr</span> <span class="o">=</span> <span class="n">tfGetRawBuffer</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">labelLength</span><span class="p">);</span>
				<span class="n">addr_info</span><span class="o">-&gt;</span><span class="n">ai_mxhostname</span> <span class="o">=</span> <span class="n">asciiPtr</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">asciiPtr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* copy MX hostname to `asciiPtr` as ASCII */</span>
					<span class="n">tfDnsLabelToAscii</span><span class="p">(</span><span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mh">0xc</span><span class="p">,</span> <span class="n">asciiPtr</span><span class="p">,</span> <span class="n">dnsHeaderPtr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="cm">/* ... */</span>
				<span class="p">}</span>
				<span class="cm">/* ... */</span>
			<span class="p">}</span>
			<span class="cm">/* ... */</span>
		<span class="p">}</span>
	<span class="cm">/* ... */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">tt16Bit</span> <span class="nf">tfDnsExpLabelLength</span><span class="p">(</span><span class="n">tt8BitPtr</span> <span class="n">labelPtr</span><span class="p">,</span> <span class="n">tt8BitPtr</span> <span class="n">pktDataPtr</span><span class="p">,</span> <span class="n">tt8BitPtr</span> <span class="n">labelEndPtr</span><span class="p">){</span>
	<span class="n">tt8Bit</span> <span class="n">currLabelLength</span><span class="p">;</span>
	<span class="n">tt16Bit</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">totalLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tt8BitPtr</span> <span class="n">newLabelPtr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">labelEndPtr</span> <span class="o">&amp;&amp;</span> <span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">currLabelLength</span> <span class="o">=</span> <span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">currLabelLength</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">totalLength</span> <span class="o">+=</span> <span class="n">currLabelLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">currLabelLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">labelEndPtr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">newLabelPtr</span> <span class="o">=</span> <span class="n">pktDataPtr</span> <span class="o">+</span> <span class="p">(((</span><span class="n">currLabelLength</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">labelPtr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">newLabelPtr</span> <span class="o">&lt;</span> <span class="n">labelPtr</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">labelPtr</span> <span class="o">=</span> <span class="n">newLabelPtr</span><span class="p">;</span>
					<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">totalLength</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>First of all, we understand by the name that <em>resourceRecordAfterNamePtr</em> and <em>dnsHeaderPtr</em> are both pointers and that <em>RDLENGTH</em> since is a length is most likely an unsigned integer.</p>

<p>Then, <em>labelEndPtr</em> pointer gets formed by adding to <em>resourceRecordAfterNamePtr</em> the term <em>10 + RDLENGTH</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">labelEndPtr</span> <span class="o">=</span> <span class="n">resourceRecordAfterNamePtr</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">RDLENGTH</span><span class="p">;</span>
</code></pre></div></div>

<p>Then, below, <em>tfDnsExpLabelLength()</em> is called with <em>resourceRecordAfterNamePtr + 0xc, dnsHeaderPtr, labelEndPtr</em> parameters, all user-controlled.</p>

<p>If we look closer at this code we can see that first memory access from <em>labelPtr</em> (which is user-controlled) is being performed and stored in <em>currLabelLength</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>currLabelLength = labelPtr[i];
</code></pre></div></div>

<p>And then several additions are done to create the value <em>totalLength</em>. Since this operations have no validations and there can as many labels as user wants (or said in other words, labelEndPtr is user-controlled and there can be as many iterations as user wants), an integer overflow can be done, returning small <em>totalLength</em> value.</p>

<p>This value is returned in <em>labelLength</em> which is used to allocate memory for a buffer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* allocate buffer for the expanded name */</span>
<span class="n">asciiPtr</span> <span class="o">=</span> <span class="n">tfGetRawBuffer</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">labelLength</span><span class="p">);</span>
</code></pre></div></div>

<p>Thus, the integer overflow can result in a underallocation which later in <em>tfDnsLabelToAscii</em> results in an overcopying vulnerability o buffer overflows.</p>

<p><br /></p>

<h4 id="45-cve-2020-16225">4.5. CVE-2020-16225.</h4>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">////ACID: The data read from staFileHandler</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="n">staFileHandler</span><span class="p">;</span> <span class="c1">//File handler is valid and already points to 0x200 location </span>
                      <span class="c1">//in .sta file being loaded.</span>
<span class="kt">size_t</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">y</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">allocSize</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">memoryAllocation</span><span class="p">;</span>

<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">staFileHandler</span><span class="p">);</span>
<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">staFileHandler</span><span class="p">);</span>
<span class="n">allocSize</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
<span class="n">memoryAllocation</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">allocSize</span><span class="p">,</span> <span class="mh">0x3000</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">fread</span><span class="p">(</span><span class="n">memoryAllocation</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">allocSize</span><span class="p">,</span> <span class="n">staFileHandler</span><span class="p">);</span>
</code></pre></div></div>

<p>Without validation of any type, allocsize is the substraction between two unsigned integer. This can lead to an integer underflow; A huge allocSize value which leads into a huge allocation which later can resultn in an overreading due to the fact that fread() is dumping allocSize bytes from staFileHandler into <em>memoryAllocation + x</em> which is also partially user-controlled.</p>

<p><br /></p>

<h4 id="46-cve-2020-17443">4.6. CVE-2020-17443.</h4>

<p>picoTCP is a lightweight TCP/IP stack designed for embedded systems and IoT devices. The vulnerability exists in the DNS response parsing code, specifically in how the stack handles DNS name compression pointers.</p>

<p>When parsing DNS responses, picoTCP decompresses domain names that use DNS compression (the 0xC0 pointer mechanism). The flaw occurs during length calculation for the decompressed name.</p>

<p>Let's check the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////ACID: echo</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pico_icmp6_send_echoreply</span><span class="p">(</span><span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="n">echo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pico_icmp6_hdr</span> <span class="o">*</span><span class="n">ehdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rhdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pico_ip6</span> <span class="n">src</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pico_ip6</span> <span class="n">dst</span><span class="p">;</span>

    <span class="n">reply</span> <span class="o">=</span> <span class="n">pico_proto_ipv6</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pico_proto_ipv6</span><span class="p">,</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pico_err</span> <span class="o">=</span> <span class="n">PICO_ERR_ENOMEM</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">echo</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">=</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">+</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">;</span>
    <span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">+</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">;</span>
    <span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span><span class="p">;</span>

    <span class="n">ehdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pico_icmp6_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_hdr</span><span class="p">;</span>
    <span class="n">rhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pico_icmp6_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">transport_hdr</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PICO_ICMP6_ECHO_REPLY</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">echo_reply</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">echo_reply</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">echo_reply</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">echo_request</span><span class="p">.</span><span class="n">seq</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span> <span class="o">-</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">));</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">short_be</span><span class="p">(</span><span class="n">pico_icmp6_checksum</span><span class="p">(</span><span class="n">reply</span><span class="p">));</span>
    <span class="cm">/* Get destination and source swapped */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">pico_ipv6_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">net_hdr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">PICO_SIZE_IP6</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">pico_ipv6_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">net_hdr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">PICO_SIZE_IP6</span><span class="p">);</span>
    <span class="n">pico_ipv6_frame_push</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="n">PICO_PROTO_ICMP6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* allocates an IPv6 packet without extension headers. If extension headers are needed,
 * include the len of the extension headers in the size parameter. Once a frame acquired
 * increment net_len and transport_hdr with the len of the extension headers, decrement
 * transport_len with this value.
 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="nf">pico_ipv6_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pico_protocol</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pico_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">IGNORE_PARAMETER</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#ifdef PICO_SUPPORT_6LOWPAN
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PICO_DEV_IS_6LOWPAN</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">pico_proto_6lowpan_ll</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pico_proto_6lowpan_ll</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">));</span>
    <span class="p">}</span>
<span class="cp">#endif
</span>    <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef PICO_SUPPORT_ETH
</span>        <span class="n">f</span> <span class="o">=</span> <span class="n">pico_proto_ethernet</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pico_proto_ethernet</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">));</span>
<span class="cp">#else
</span>        <span class="n">f</span> <span class="o">=</span> <span class="n">pico_frame_alloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span> <span class="o">+</span> <span class="n">PICO_SIZE_ETHHDR</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">f</span><span class="o">-&gt;</span><span class="n">net_len</span> <span class="o">=</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">;</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">net_hdr</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">;</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">transport_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">size</span><span class="p">;</span>

    <span class="cm">/* Datalink size is accounted for in pico_datalink_send (link layer) */</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PICO_SIZE_IP6HDR</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, lets go part by part:</p>

<ul>
  <li>
    <p>After a few definitions and declarations:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="n">pico_frame</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pico_icmp6_hdr</span> <span class="o">*</span><span class="n">ehdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rhdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pico_ip6</span> <span class="n">src</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pico_ip6</span> <span class="n">dst</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Part of the echo contents are dumped on reply structure:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">echo</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">=</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">+</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">;</span>
  <span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">transport_hdr</span> <span class="o">+</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">;</span>
  <span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>Thus, this data-piece are user-controlled,</p>
  </li>
  <li>
    <p>Later on the code, and without any previous validation, a memcpy() operation is performed:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">memcpy</span><span class="p">(</span><span class="n">reply</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="n">echo</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">echo</span><span class="o">-&gt;</span><span class="n">transport_len</span> <span class="o">-</span> <span class="n">PICO_ICMP6HDR_ECHO_REQUEST_SIZE</span><span class="p">));</span>
</code></pre></div>    </div>

    <p>Observe that, destination, source and the size are essentially user controlled. Since the size is a mathematical operation (a substraction) between a user-controlled data and a constant, potentially leading to an underflow, since the value is casted as an unsigned integer, the underflow would result in basically in a huge value as the size to be copied.</p>

    <p>Thus, this is a what-where-write vulnerability.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="47-cve-2021-30860-forcedentry">4.7. CVE-2021-30860 "FORCEDENTRY".</h4>

<p>JBIG2 (Joint Bi-level Image Experts Group) is an image compression format. JBIG2 data streams can be embedded into PDF files. PDF files will be automatically processed when delivered to a Mac/iPhone via iMessages</p>

<p>Therefore this is suitable for "zero-click" exploits, where the victim doesn't need to do anything (like clicking on a file or link) in order to be exploited</p>

<p>Apple had recently introduced a new sandboxing measure ("BlastDoor") to process ACID in a more restricted environment… but it turns out PDF files were not sandboxed…</p>

<p><br /></p>

<p>Lets check the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">JBIG2SegmentType</span> <span class="p">{</span>
    <span class="n">jbig2SegBitmap</span><span class="p">,</span>
    <span class="n">jbig2SegSymbolDict</span><span class="p">,</span>
    <span class="n">jbig2SegPatternDict</span><span class="p">,</span>
    <span class="n">jbig2SegCodeTable</span>
<span class="p">};</span>

<span class="c1">////ACID: refSegs, nRefSegs</span>
<span class="kt">void</span> <span class="n">JBIG2Stream</span><span class="o">::</span><span class="n">readTextRegionSeg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segNum</span><span class="p">,</span> <span class="n">bool</span> <span class="n">imm</span><span class="p">,</span> <span class="n">bool</span> <span class="n">lossless</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">refSegs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nRefSegs</span><span class="p">){</span>
    <span class="n">JBIG2Segment</span> <span class="o">*</span><span class="n">seg</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">codeTables</span><span class="p">;</span>
    <span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="n">symbolDict</span><span class="p">;</span>
    <span class="n">JBIG2Bitmap</span> <span class="o">**</span><span class="n">syms</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">huff</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numSyms</span><span class="p">,</span> <span class="n">symCodeLen</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">kk</span><span class="p">;</span>

    <span class="c1">// ...</span>

    <span class="c1">// get symbol dictionaries and tables</span>
    <span class="n">numSyms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRefSegs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">findSegment</span><span class="p">(</span><span class="n">refSegs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegSymbolDict</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">numSyms</span> <span class="o">+=</span> <span class="p">((</span><span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegCodeTable</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">codeTables</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">seg</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">error</span><span class="p">(</span><span class="n">errSyntaxError</span><span class="p">,</span> <span class="n">curStr</span><span class="o">-&gt;</span><span class="n">getPos</span><span class="p">(),</span> <span class="s">"Invalid segment reference in JBIG2 text region"</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>

    <span class="c1">// get the symbol bitmaps</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="p">(</span><span class="n">JBIG2Bitmap</span> <span class="o">**</span><span class="p">)</span><span class="n">gmallocn</span><span class="p">(</span><span class="n">numSyms</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">JBIG2Bitmap</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numSyms</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">syms</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRefSegs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">findSegment</span><span class="p">(</span><span class="n">refSegs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegSymbolDict</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">symbolDict</span> <span class="o">=</span> <span class="p">(</span><span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">symbolDict</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">syms</span><span class="p">[</span><span class="n">kk</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbolDict</span><span class="o">-&gt;</span><span class="n">getBitmap</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can inmediately see that, first an integer's value (numSyms) is calculated within a for and an if user-controlled statement:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numSyms</span><span class="p">,</span> <span class="n">symCodeLen</span><span class="p">;</span>
<span class="c1">//...</span>
<span class="n">numSyms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRefSegs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">findSegment</span><span class="p">(</span><span class="n">refSegs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegSymbolDict</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">numSyms</span> <span class="o">+=</span> <span class="p">((</span><span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
</code></pre></div></div>

<p>Since there is no validation, this calculation could lead to a integer overflow. Later, this value is used to allocated memory which in combination with the integer overflow risk can lead to an under-allocation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syms</span> <span class="o">=</span> <span class="p">(</span><span class="n">JBIG2Bitmap</span> <span class="o">**</span><span class="p">)</span><span class="n">gmallocn</span><span class="p">(</span><span class="n">numSyms</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">JBIG2Bitmap</span> <span class="o">*</span><span class="p">));</span>
</code></pre></div></div>

<p>Later, syms pointer gets used in a user-controlled for-loop in which receives data assignation, if an under-allocation gets performed, then this for loop can trigger an overcopying:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nRefSegs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="n">findSegment</span><span class="p">(</span><span class="n">refSegs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">jbig2SegSymbolDict</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">symbolDict</span> <span class="o">=</span> <span class="p">(</span><span class="n">JBIG2SymbolDict</span> <span class="o">*</span><span class="p">)</span><span class="n">seg</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">symbolDict</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">syms</span><span class="p">[</span><span class="n">kk</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbolDict</span><span class="o">-&gt;</span><span class="n">getBitmap</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="48-cve-2021-22636-texas-instruments--freertos-open-source">4.8. CVE-2021-22636. Texas Instruments + FreeRTOS (Open Source).</h4>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int16_t</span> <span class="nf">_BundleCmdSignatureFile_Parse</span><span class="p">(</span>
    <span class="n">OtaArchive_BundleCmdTable_t</span> <span class="o">*</span><span class="n">pBundleCmdTable</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pRecvBuf</span><span class="p">,</span>    <span class="c1">//XENO: ACID: TAR file received over network</span>
    <span class="kt">int16_t</span> <span class="n">RecvBufLen</span><span class="p">,</span>   <span class="c1">//XENO: SACI: Size of TAR file received over network</span>
    <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ProcessedSize</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">SigFileSize</span><span class="p">,</span> <span class="c1">//XENO: ACID: Size from TAR file headers</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pDigest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int16_t</span> <span class="n">retVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span>  <span class="n">pSig</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Get the entire signature file */</span>
    <span class="n">retVal</span> <span class="o">=</span> <span class="n">GetEntireFile</span><span class="p">(</span><span class="n">pRecvBuf</span><span class="p">,</span> <span class="n">RecvBufLen</span><span class="p">,</span> <span class="n">ProcessedSize</span><span class="p">,</span> <span class="n">SigFileSize</span><span class="p">,</span>
                           <span class="o">&amp;</span><span class="n">pSig</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">retVal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">(</span><span class="n">retVal</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">retVal</span> <span class="o">==</span> <span class="n">GET_ENTIRE_FILE_CONTINUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">(</span><span class="n">ARCHIVE_STATUS_BUNDLE_CMD_SIGNATURE_CONTINUE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Verify the signature using ECDSA */</span>
    <span class="n">retVal</span> <span class="o">=</span> <span class="n">verifySignature</span><span class="p">(</span><span class="n">pSig</span><span class="p">,</span> <span class="n">SigFileSize</span><span class="p">,</span> <span class="n">pDigest</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">retVal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_SlOtaLibTrace</span><span class="p">((</span>
                           <span class="s">"[_BundleCmdSignatureFile_Parse] "</span>
                           <span class="s">"signature verification failed!</span><span class="se">\r\n</span><span class="s">"</span><span class="p">));</span>
        <span class="k">return</span><span class="p">(</span><span class="n">retVal</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pBundleCmdTable</span><span class="o">-&gt;</span><span class="n">VerifiedSignature</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">ARCHIVE_STATUS_BUNDLE_CMD_SIGNATURE_DOWNLOAD_DONE</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int16_t</span> <span class="nf">GetEntireFile</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pRecvBuf</span><span class="p">,</span>
                      <span class="kt">int16_t</span> <span class="n">RecvBufLen</span><span class="p">,</span>
                      <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ProcessedSize</span><span class="p">,</span>
                      <span class="kt">uint32_t</span> <span class="n">FileSize</span><span class="p">,</span>
                      <span class="kt">char</span> <span class="o">**</span><span class="n">pFile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int16_t</span> <span class="n">copyLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">bool</span> <span class="n">firstRun</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int16_t</span> <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">firstRun</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="n">RecvBufLen</span><span class="p">;</span>
        <span class="n">firstRun</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">TotalRecvBufLen</span> <span class="o">&lt;</span> <span class="n">FileSize</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Didn't receive the entire file in the first run. */</span>
            <span class="cm">/* Allocate a buffer in the size of the entire file and fill
                it in each round. */</span>
            <span class="n">pTempBuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">pTempBuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="cm">/* Allocation failed, return error. */</span>
                <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">pTempBuf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pRecvBuf</span><span class="p">,</span> <span class="n">RecvBufLen</span><span class="p">);</span>
            <span class="o">*</span><span class="n">ProcessedSize</span> <span class="o">=</span> <span class="n">RecvBufLen</span><span class="p">;</span>

            <span class="cm">/* didn't receive the entire file, try in the next packet */</span>
            <span class="k">return</span><span class="p">(</span><span class="n">GET_ENTIRE_FILE_CONTINUE</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="cm">/* Received the entire file in the first run. */</span>
            <span class="cm">/* No additional memory allocation is needed. */</span>
            <span class="o">*</span><span class="n">ProcessedSize</span> <span class="o">=</span> <span class="n">FileSize</span><span class="p">;</span>
            <span class="o">*</span><span class="n">pFile</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pRecvBuf</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/* Avoid exceeding buffer size (FileSize + 1) */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">RecvBufLen</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">TotalRecvBufLen</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">copyLen</span> <span class="o">=</span> <span class="p">((</span><span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">TotalRecvBufLen</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">copyLen</span> <span class="o">=</span> <span class="n">RecvBufLen</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Copy the received buffer from where we stopped the previous copy */</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pTempBuf</span><span class="p">[</span><span class="n">TotalRecvBufLen</span><span class="p">]),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pRecvBuf</span><span class="p">,</span> <span class="n">copyLen</span><span class="p">);</span>

        <span class="o">*</span><span class="n">ProcessedSize</span> <span class="o">=</span> <span class="n">copyLen</span><span class="p">;</span>
        <span class="n">TotalRecvBufLen</span> <span class="o">+=</span> <span class="n">copyLen</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="n">TotalRecvBufLen</span> <span class="o">&lt;</span> <span class="n">FileSize</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* didn't receive the entire file, try in the next packet */</span>
            <span class="k">return</span><span class="p">(</span><span class="n">GET_ENTIRE_FILE_CONTINUE</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* At this point we have the whole file */</span>
        <span class="o">*</span><span class="n">pFile</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pTempBuf</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Set static variables to initial values to allow retry in 
    case of a warning during the OTA process */</span>
    <span class="n">firstRun</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">GET_ENTIRE_FILE_DONE</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ATTRIBUTE</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Header</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">packet</span> <span class="o">=</span> <span class="p">(</span><span class="n">Header</span> <span class="o">*</span><span class="p">)</span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Header</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">actualBuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">packet</span><span class="p">;</span>
    <span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Header</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">packet</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can see that first, pRecvBuf, RecvBufLen and SigFileSize are user-controlled. This values are passed to <em>GetEntireFile()</em> and then they get included in the following code chunk:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int16_t</span> <span class="n">copyLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">firstRun</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int16_t</span> <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">firstRun</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TotalRecvBufLen</span> <span class="o">=</span> <span class="n">RecvBufLen</span><span class="p">;</span>
    <span class="n">firstRun</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">TotalRecvBufLen</span> <span class="o">&lt;</span> <span class="n">FileSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Didn't receive the entire file in the first run. */</span>
        <span class="cm">/* Allocate a buffer in the size of the entire file and fill
            it in each round. */</span>
        <span class="n">pTempBuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pTempBuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Allocation failed, return error. */</span>
            <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>On it, we can see that firstRun at first gets assgined as TRUE, so the code flow jumps to the second if statement in which it compares TotalRecvBufLen &lt; FileSize, since both values are user-controlled, this statement also is true and then comes malloc with maths over a user-controlled parameter.</p>

<p>Since <em>FileSize</em> is an unsigned integer, this addtion can go to an integer overflow passing from the most bigger value to a small one. Initially, if this was the normal malloc() function, FileSize biggest value should turn the operand 0 and malloc would return to us a NULL pointer, but the current malloc() function is wrapper around pvPortMalloc() function. If we check that implementation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">ATTRIBUTE</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Header</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">packet</span> <span class="o">=</span> <span class="p">(</span><span class="n">Header</span> <span class="o">*</span><span class="p">)</span><span class="n">pvPortMalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Header</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>we can see that in fact is a wrapper around <em>pvPortMalloc()</em> and that if FileSize was a value satisfying:</p>

<pre><code class="language-less">FileSize + 1 + sizeof(Header) = 1
</code></pre>

<p>Assuming that this addition is within the ring of module 32 integers, malloc function should return us a one byte-size pointer. This is, this malloc function is not protected against an underflow provoked by an integer overflow result by the way this function is called.</p>

<p>Automatically below, a memcpy() operation is performed with this underallocated pointer as a destination, using user-controlled values as source and length of the memcpy():</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">pTempBuf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pRecvBuf</span><span class="p">,</span> <span class="n">RecvBufLen</span><span class="p">);</span>
</code></pre></div></div>

<p>Leading to a what-where-write vulnerability.</p>

<p><br /></p>]]></content><author><name>German Sanmi</name></author><category term="Past Blogs" /><category term="Binary Exploitation" /><category term="memory-corruption" /><category term="exploits" /><summary type="html"><![CDATA[1. Integer Overflow/Underflow vulnerabilities introduction. Integer Overflow/Undwerflow vulnerabilities referer a vulnerability form in which an attacker leverage cases in which is possible that signed and unsigned integers exceeds their positive and negative value ranges due to egdy math cases. Before enter in a further explanation, let's take a reminder on how signed and unsigned data types works in C. 1.1. Values and Datatypes. Value and Datatypes definition Let's start in the beginning, building the idea of value and datatype. A value is nothing but an abstraction of a piece of information stored in memory in form of binary bits waiting to be processed by the CPU. A datatype tells the compiler how to interpret and store that value in memory. It defines two critical things: The size of the value; this is how many bytes to allocate; (char, short, integer, …, array, struct,…). The sign of the value; or how to interpret the bit pattern stored there (signed/unsigned). The same bit pattern 0xFF could mean 255 or -1 depending on how the compiler interprets it. Signed vs Unsigned The sign of a value is also related with the datatype it self, because there are datatypes in which make a signed/unsigned distinction does not make sense. The signed/unsigned distinction only applies to integer types (char, short, int, long, etc.) because it's about how to interpret a fixed sequence of bits as a number. Floating-point types, structs, pointers does not have an unsigned version. Unsigned integers use all bits to represent magnitude. An 8-bit unsigned value ranges from 0 to 255 (2⁸ - 1). Every bit pattern maps directly to a non-negative number. Signed integers uses the most significant bit to encode sign information, is called the sign bit. Using two's complement representation (which is universal on modern systems), an 8-bit signed value ranges from -128 to 127. The bit pattern 0xFF becomes -1 rather than 255. 1.2. Two's Complement Signed Numbers. Two's complement is the standard way that C (and most modern computers) represents signed integers (positive and negative whole numbers). In this representation, the leftmost (or more significant bit) serves also as an indicator to notice the sign of the value: '0' to positive numbers; 01111111b = 127 '1' to negative numbers. 10000000b = -128 Thus, let's suppose we have a binary number, lets say x, the complement's convention says that in order to represent -x we have to flip all the bits (0→1, 1→0) this is called the one's complement and then add 1: Positive number: 5 - 00000101b Negative number: -5 - Step 1: Start with 5: 00000101 - Step 2: Flip all bits: 11111010 (one's complement) - Step 3: Add 1: 11111011 = -5 (two's complement) The formula to obtain the decimal value from a signed integer binary number is applying a negative sign to sign bit in the standard base system operation, for example: 11111011 = -1*2^7 + 1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 = -128 + 123 = -5 1.3. Range of a datatype. A word about the range. A range is simply the set of all possible values a datatype can represent and is not an arbitrary decision but a direct consequence of having finite storage capacity. Memory is organized into units of 8-bits each (also called byte), and CPUs have registers of fixed widths: 8, 16, 32, or 64 bits on modern systems. This means that, often, you only have at most 64 bits (possibles 0 or 1) to store a binary value which represents data, this also means that every datatype has a finite range. For signed integers, the absolute value decrements in a half compared with the unsigned type and, for example, to a 8 bits value, the maximum unsigned value is 11111111b, which in decimal is 255. But, for the signed type, by convention, since the leftmost bit is consider the sign bit, then the further value from zero is 1111111b = 127. It happens that: n-bit signed integer --&gt; the range is: -2^(n-1) to 2^(n-1) - 1 binary hex unsigned decimal signed decimal 00000000 00 0 0 00000001 01 1 1 00000010 02 2 2 00000011 03 3 3 … … … … 01111110 7E 126 126 01111111 7F 127 127 10000000 80 128 -128 10000001 81 129 -127 … … … … 11111110 FE 254 -2 11111111 FF 255 -1 This exact principle showed with 8-bits can be extended also to 16,32 and 64 bits numbers: 8-bit signed (char): -128 to 127 16-bit signed (short): -32,768 to 32,767 32-bit signed (int): -2,147,483,648 to 2,147,483,647 2. Integer Overflow Definition. At this moment, with the having introduced the previous terms, we are now in conditions to provide a definition. 2.1. Unsigned Overflow/Underflow. Let's consider the following trivial code: unsigned char i = 0; while(1) i++; In the code above, an unsigned char gets defined with value 0 and then a while loop starts increasing the value of i once at a time. As de loops iterates, i value increases but since char size is one byte, it only can store 8-bits, so eventually: iteration uchar (binary) uchar (hex) uchar (decimal) … … … … 254 11111110 FE 254 255 11111111 FF 255 (Upper-top range) 256 1(00000000) 1(00) 0 257 000000001 01 1 … … … … What is happenning is that the CPU is perfoming the correct calculation which is 11111111 + 1 = 100000000 (a 9-bit value) and is storing it in a 8-bit size chunk, so as the result, the most significant bit is left out and what is stored at the chunk is the value 00000000, restarting the value of i. This is what we call Unsigned Overflow. This can be resumed as the following rule: All the operations performed over an unsigned datatype are modular operations with module 2^N where N is the bit-width of the type. Unsigned overflow is well-defined in C. The standard explicitly says unsigned arithmetic wraps modulo 2^n. If you add 1 to UINT_MAX, you get 0. This is guaranteed, portable behavior. The opposite case, going behind 0 to obtain instantetly the biggest value posible is what we call Signed Underflow. 2.2. Signed Overflow/Underflow. Signed Integers, as discussed before, have a different design than unsigned datatypes. Since both entities are confined within a finite storage capacity both share range boundaries and the overflow type related to the range boundaries discussed above. But signed integers also leads to another type of overflow dealing with the change of sign. Let's start saying negativity is a decimal-level abstraction. At the binary level, you just have rings of integers mod 2^n, and two's complement is the isomorphism that maps the upper half of that ring onto negative numbers in a way that preserves additive structure. Lets dive on how this isomorphism works. By definition, if we have a value 'x' in a set o numbers, his negative is that number in the set which add to 0 with 'x': x + (-x) = 0 Let's consider a binary value of 8-bit wide, 00000011 (3) if we calculate the negative through the two's complement: x = 1 --&gt; -x = 11111110 + 1 = 11111111 = 255 x = 2 --&gt; -x = 11111101 + 1 = 11111110 = 254 x = 3 --&gt; -x = 11111100 + 1 = 11111101 = 253 x = 4 --&gt; -x = 11111011 + 1 = 11111100 = 252 ... We can see a clear pattern, as we go on the values from the lower limit of the range (0), his negative correspondient value is the homologous value startint from te upper limit (256) and the flow of both values advance to opposite directions so they are meant to encounter each other at the half of the track. x = 126 --&gt; -x = 10000001 + 1 = 10000010 = 130 x = 127 --&gt; -x = 10000000 + 1 = 10000001 = 129 x = 128 --&gt; -x = 01111111 + 1 = 10000000 = 128 &lt;-- Inflection point x = 129 --&gt; -x = 01111110 + 1 = 01111111 = 127 x = 130 --&gt; -x = 01111101 + 1 = 01111110 = 126 Thus, we can assume the convention that from 127 all the numbers above are the negative counter part of the half below 127. binary unsigned decimal signed decimal 00000000 0 0 00000001 1 1 00000010 2 2 00000011 3 3 … … … 01111110 126 126 01111111 127 127 10000000 128 -128 10000001 129 -127 … … … 11111110 254 -2 11111111 255 -1 Thus, in any modular 2^N ring the values increases until some threshold is reached (the half of the ring) and then the value goes from being the highest value to the smallest one, this is what we call Signed Overflow. The opposite case, when the values decreases until goes from the smallest value to the highest one is called Signed Underflow. Signed overflow is undefined behavior in C. The standard says the compiler can assume it never happens, which means if your code allows it to happen, the compiler is free to do anything: wrap around, saturate, crash, optimize away your bounds check, or summon demons. In practice, most compilers on most platforms will wrap using two's complement (so INT_MAX + 1 becomes INT_MIN). Let's note again that negativity is just a convention, we explain how positive and negative values are relate between them using the 'negative' and two's complement definitions only in behalf of clarity. Negative and substraction are concepts tightly related and is easier to think about them because we are made to an infinite set of numbers. In fact, in modular rings as 8-bit width binary values negativness is a direct consecuence of the modular nature of the ring: 127 + (-127) = 01111111 + 10000001 = 1(00000000) Also the risk of this effect and the reason why this leads into a vulnerability is also a consecuence of the modular nature of the set of numbers. 2.3. Conclusion and explaning the risk. Integer overflows shows them selfs as vulnerabilties due to "under-allocation" and "over-copy", for examples: //Assume var is user-controlled malloc(var1 + const) malloc(var1 + var2) malloc(var1 * const) All of this allocations present issues of having underallocation. If again this number is used to copy data with checking the memory chunk allocated: memcpy(dst, src, var1) This can be an over-copy. 3. Examples. 3.1. Trivial Example: Let's check the following code. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; typedef struct my_header{ unsigned long int magic; unsigned long int size; } my_header_t; // Under-allocate, over-copy – uaoc.c void main(int argc, char *argv[]){ my_header_t header; unsigned int alloc_size; header.magic = 0x6f6e6558; header.size = strtoul(argv[1], NULL, 10); alloc_size = header.size + sizeof(my_header_t); printf("String self-reported size = 0x%08lX\n", header.size); printf("Allocation size = 0x%08X\n", alloc_size); char *buf = malloc(alloc_size); if(buf == NULL) return; printf("buf points to %p\n", buf); memcpy(buf, &amp;header, sizeof(my_header_t)); buf += sizeof(my_header_t); printf("memcpy()ing 0x%08lX bytes into buf of size 0x%08X\n", header.size, alloc_size); memcpy(buf, argv[2], header.size); printf("We copied input string: %s\n", buf); } If we check the code, we can see that some user-controlled data argv[1} is being stored on size field of header struct and inmediately without sanitization, this same value is used to allocate memory space: header.size = strtoul(argv[1], NULL, 16); alloc_size = header.size + sizeof(my_header_t); //... char *buf = malloc(alloc_size); Thus, let's observe that, since header.size is arbitrary and my_header_t struct have two fields (two longs), then sizeof(my_header_t) in x64 is 16 bytes and the unsigned int in x64 has 4 bytes in size, so is a value within a range between 0 and 2^(48) = 2^32 (4 bytes, 8 bits each byte) = 4294967296, thus if the user enters 4294967280 (4294967296 - 16) *alloc_size would be overflow an turn 0, this means that this code can easily turns into an underallocation. Later, the pointer is used as a destination in a memcpy() operation: memcpy(buf, argv[2], header.size); The reuslt is overcopying: OUTPUT: $ ./test 4294967280 hello String self-reported size = 0xFFFFFFF0 Allocation size = 0x00000000 buf points to 0x58449e0336b0 memcpy()ing 0xFFFFFFF0 bytes into buf of size 0x00000000 Segmentation fault (core dumped) 3.2. FreeRTOS. Lets consider the following code: void pvPortMalloc( size_t xWantedSize ) {v//user-controlled - xWantedSize BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink; static BaseType_t xHeapHasBeenInitialised = pdFALSE; void *pvReturn = NULL; vTaskSuspendAll(); { /* If this is the first call to malloc then the heap * initialisation to setup the list of free blocks. */ if( xHeapHasBeenInitialised == pdFALSE ) { prvHeapInit(); xHeapHasBeenInitialised = pdTRUE; } /* The wanted size is increased so it can contain a BlockLink_t * structure in addition to the requested amount of bytes. */ if( xWantedSize &gt; 0 ) { xWantedSize += heapSTRUCT_SIZE; /* Ensure that blocks are always aligned to the required number of bytes. */ if( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != 0 ) { /* Byte alignment required. */ xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) ); } } } } We can see that xWantedSize, which is a size_t datatype (unsigned integer) is user-controlled and used within an if statement performing a math operation with heapSTRUCT_SIZE without validation, thus as we proceed in the case before, we could perform an unsigned overflow. 4. Exercises. 4.1. CVE-2020-0796 "SMBGhost". CVE-2020-0796, commonly known as SMBGhost, is a critical remote code execution vulnerability discovered in March 2020 that affects Microsoft's SMBv3 (Server Message Block version 3) protocol implementation in Windows 10 and Windows Server versions 1903 and later. SMB3 supports message compression to reduce network traffic load, message decompression takes place in the srv2.sys kernel driver. ////ACID: The data pointed to by request-&gt;pNetRawBuffer signed __int64 __fastcall Srv2DecompressData(SRV2_WORKITEM *workitem) { // declarations omitted ... request = workitem-&gt;psbhRequest; if ( request-&gt;dwMsgSize &lt; 0x10 ) return 0xC000090B; compressHeader = *(CompressionTransformHeader *)request-&gt;pNetRawBuffer; ... newHeader = SrvNetAllocateBuffer((unsigned int)(compressHeader.originalCompressedSegSize + compressHeader.offsetOrLength), 0); if ( !newHeader ) return 0xC000009A; if ( SmbCompressionDecompress( compressHeader.compressionType, &amp;workitem-&gt;psbhRequest-&gt;pNetRawBuffer[compressHeader.offsetOrLength + 16], workitem-&gt;psbhRequest-&gt;dwMsgSize - compressHeader.offsetOrLength - 16, &amp;newHeader-&gt;pNetRawBuffer[compressHeader.offsetOrLength], compressHeader.OriginalCompressedSegSize, &amp;finalDecompressedSize) &lt; 0 || finalDecompressedSize != compressHeader.originalCompressedSegSize) ) { SrvNetFreeBuffer(newHeader); return 0xC000090B; } if ( compressHeader.offsetOrLength ) { memmove(newHeader-&gt;pNetRawBuffer, workitem-&gt;psbhRequest-&gt;pNetRawBuffer + 16, compressHeader.offsetOrLength); } newHeader-&gt;dwMsgSize = compressHeader.OffsetOrLength + fianlDecompressedSize; Srv2ReplaceReceiveBuffer(workitem, newHeader); return 0; } Then, let's go carefully, checking the code, the user controlled data is pointed by request-&gt;pNetRawBuffer, thus: First, compressHeader gets the dereferenced contents of request-&gt;pNetRawBuffer, then some fields of this structure gets used to allocate a buffer presumibly inside the heap: compressHeader = *(CompressionTransformHeader *)request-&gt;pNetRawBuffer; newHeader = SrvNetAllocateBuffer((unsigned int)(compressHeader.originalCompressedSegSize + compressHeader.offsetOrLength), 0); This essentially could lead to an underallocation since no check is done after or before the allocation. Later, offsetOrLength field is used to copy memory to the previos allocated buffer which could lead to an overcopy: if ( compressHeader.offsetOrLength ){ memmove(newHeader-&gt;pNetRawBuffer, workitem-&gt;psbhRequest-&gt;pNetRawBuffer + 16, compressHeader.offsetOrLength); } As a summary, an addition of two user-controlled terms could be used to perform an underallocation due to an unsigned integer overflow, for example if compressHeader.originalCompressedSegSize is small and compressHeader.offsetOrLength was huge always being: compressHeader.originalCompressedSegSize + compressHeader.offsetOrLength = 2^32 Then, on the second line, a huge amountn of bytes would be used to write over an small buffer provoking an overcopy resulting in a bufffer overflow. 4.2. CVE-2019-5105. CVE-2019-5105 is a critical memory corruption vulnerability affecting 3S-Smart Software Solutions' CODESYS industrial automation platform, specifically in the GatewayService component. While primarily classified as an out-of-bounds write vulnerability, it's related to integer overflow issues in buffer size calculations. ////ACID: param_1 void FUN_00677d70(void **param_1, int param_2, int param_3, int param_4, int param_5 ,uint *param_6) { int header_length; size_t _Size; int iVar1; int iVar2; int receiver_length; uint sender_length; /* Omitted code */ void *blkDrvPDUdata; /* Omitted code */ iVar2 = *(int *)(param_2 + 0x128) + DAT_007a3534; if (iVar2 &lt; 0xf) { /* Omitted code */ blkDrvPDUdata = *param_1; header_length = (*(byte *)((int)blkDrvPDUdata + 1) &amp; 7) * 2; sender_length = *(byte *)((int)blkDrvPDUdata + 5) &amp; 0xf; receiver_length = (int)(uint)*(byte *)((int)blkDrvPDUdata + 5) &gt;&gt; 4; pvVar3 = (void *)(sender_length + receiver_length + header_length); local_20c = header_length; if (pvVar3 &lt; param_1[1] || pvVar3 == param_1[1]) { pvVar3 = *param_1; if ((*(byte *)((int)blkDrvPDUdata + 2) &amp; 0x10) == 0) { *param_6 = header_length + (sender_length + receiver_length) * 2; if ((*param_6 &amp; 3) != 0) { *param_6 = *param_6 + 2; } _Size = (int)param_1[1] - *param_6; /* Omitted code*/ if ((local_220 &lt; 0x10) &amp;&amp; (local_244 &lt; 0x10)) { /* Omitted Code*/ if (local_20c + _Size_00 + iVar1 + local_214 + _Size &lt; 0x201) { memcpy(local_208 + local_214 + iVar1 + _Size_00 + local_20c, (void *)((int)*param_1 + *param_6), _Size ); param_1[1] = (void *)(local_20c + _Size_00 + iVar1 + local_214 + _Size); memcpy(*param_1,local_208,(size_t)param_1[1]); *(int *)(param_5 + 0xc) = (int)*param_1 + local_20c; *(int *)(param_4 + 0xc) = *(int *)(param_5 + 0xc) + *(int *)(param_5 + 8) * 2; *param_6 = local_20c + _Size_00 + iVar1; if ((*param_6 &amp; 3) != 0) { *param_6 = *param_6 + 2; } } } } } } FUN_006ce8f9(); return; } Let's review the code carefully, user-controlled data lies on param_1. First, some declaration are perfomed: int header_length; size_t _Size; int iVar1; int iVar2; int receiver_length; uint sender_length; /* Omitted code */ void *blkDrvPDUdata; /* Omitted code */ iVar2 = *(int *)(param_2 + 0x128) + DAT_007a3534; //... Then, comes the assignation, in which some variables in the function receives user-controlled data: blkDrvPDUdata = *param_1; header_length = (*(byte *)((int)blkDrvPDUdata + 1) &amp; 7) * 2; sender_length = *(byte *)((int)blkDrvPDUdata + 5) &amp; 0xf; receiver_length = (int)(uint)*(byte *)((int)blkDrvPDUdata + 5) &gt;&gt; 4; pvVar3 = (void *)(sender_length + receiver_length + header_length); local_20c = header_length; Essentially, is not hard to see that all of this variables are user-controlled Now, this variables are used to define the copy size, the source and the destination of a memcpy() operation: *param_6 = header_length + (sender_length + receiver_length) * 2; //User-controlled //... _Size = (int)param_1[1] - *param_6; //Underflow //... memcpy(local_208 + local_214 + iVar1 + _Size_00 + local_20c, (void *)((int)*param_1 + *param_6), _Size ); //Overcopy param_1[1] = (void *)(local_20c + _Size_00 + iVar1 + local_214 + _Size); memcpy(*param_1,local_208,(size_t)param_1[1]); Let's observe carefully that when _Size filled, if *param_6 &gt; than (int)param_1[1] then, it could result in a negative value that, when cast to unsigned it will transform in a huge positive value leading to an overcopy 4.3. CVE-2019-14192. CVE-2019-14192 is an integer overflow vulnerability discovered in U-Boot (Universal Boot Loader), which is one of the most widely used boot loaders for embedded systems. Firmware fetch the bootloader which in this case is u-boot and this devices loads the OS and this one the rest of the applications. Let's check the code: ////ACID: in_packet void net_process_received_packet(uchar *in_packet, int len) { struct ethernet_hdr *et; struct ip_udp_hdr *ip; struct in_addr dst_ip; struct in_addr src_ip; int eth_proto; // ... ip = (struct ip_udp_hdr *)(in_packet + E802_HDR_SIZE); // ... switch (eth_proto) { // ... case PROT_IP: debug_cond(DEBUG_NET_PKT, "Got IP\n"); /* Before we start poking the header, make sure it is there */ if (len &lt; IP_UDP_HDR_SIZE) { debug("len bad %d &lt; %lu\n", len, (ulong)IP_UDP_HDR_SIZE); return; } /* Check the packet length */ if (len &lt; ntohs(ip-&gt;ip_len)) { debug("len bad %d &lt; %d\n", len, ntohs(ip-&gt;ip_len)); return; } len = ntohs(ip-&gt;ip_len); // ... ip = net_defragment(ip, &amp;len); if (!ip) return; // ... if (ip-&gt;ip_p == IPPROTO_ICMP) { receive_icmp(ip, len, src_ip, et); return; } else if (ip-&gt;ip_p != IPPROTO_UDP) { /* Only UDP packets */ return; } // ... #if defined(CONFIG_NETCONSOLE) &amp;&amp; !defined(CONFIG_SPL_BUILD) nc_input_packet((uchar *)ip + IP_UDP_HDR_SIZE, src_ip, ntohs(ip-&gt;udp_dst), ntohs(ip-&gt;udp_src), ntohs(ip-&gt;udp_len) - UDP_HDR_SIZE); #endif /* * IP header OK. Pass the packet to the current handler. */ (*udp_packet_handler)((uchar *)ip + IP_UDP_HDR_SIZE, ntohs(ip-&gt;udp_dst), src_ip, ntohs(ip-&gt;udp_src), ntohs(ip-&gt;udp_len) - UDP_HDR_SIZE); break; // ... } } Let's note the following line: //... ip = (struct ip_udp_hdr *)(in_packet + E802_HDR_SIZE); //... #if defined(CONFIG_NETCONSOLE) &amp;&amp; !defined(CONFIG_SPL_BUILD) nc_input_packet((uchar *)ip + IP_UDP_HDR_SIZE, src_ip, ntohs(ip-&gt;udp_dst), ntohs(ip-&gt;udp_src), ntohs(ip-&gt;udp_len) - UDP_HDR_SIZE); #endif We can see that, the last parameter of the calling of nc_input_packet() function is math operation without validation of any type. We don't need to understand what the function does with that value in order to be able to see that is dangerous and is in fact a vulnerbility. The same is done just below in the code: /* * IP header OK. Pass the packet to the current handler. */ (*udp_packet_handler)((uchar *)ip + IP_UDP_HDR_SIZE, ntohs(ip-&gt;udp_dst), src_ip, ntohs(ip-&gt;udp_src), ntohs(ip-&gt;udp_len) - UDP_HDR_SIZE); break; // ... A function is being called thorugh a function pointer and the last parameter is also a math operation without any validation. (This is not in fact so dangerous as it seems, perhaps the function holds some validation for edgy values?) 4.4. CVE-2020-11901. Part of "Ripple20" grab-bag. CVE-2020-11901 is really 4 vulnerabilities that got lumped into the same CVE (/ didn’t get assigned their own CVEs), this was discussed before on Linear Stack Buffer Overflow. This pertains to the parsing of compressed DNS packets. DNS packets have a formatting for hostname strings that breaks them into “labels”, that are prefixed by a label length byte. Multiple labels are separated by a period, the total hostname string is considered complete when a 0 is found for a label length. The DNS spec states that the max label length should be 63 bytes and the hostname length should be 255 bytes. Consider the following code: //ACID: RDLENGTH, resourceRecordAfterNamePtr, dnsHeaderPtr if (RDLENGTH &lt;= remaining_size) { /* compute the next resource record pointer based on the RDLENGTH */ labelEndPtr = resourceRecordAfterNamePtr + 10 + RDLENGTH; /* type: MX */ if (cacheEntryQueryType == DNS_TYPE_MX &amp;&amp; rrtype == DNS_TYPE_MX) { addr_info = tfDnsAllocAddrInfo(); if (addr_info != NULL &amp;&amp; RDLENGTH &gt;= 2) { /* copy preference value of MX record */ memcpy(&amp;addr_info-&gt;ai_mxpref,resourceRecordAfterNamePtr + 10, 2); /* compute the length of the MX hostname */ labelLength = tfDnsExpLabelLength(resourceRecordAfterNamePtr + 0xc, dnsHeaderPtr, labelEndPtr); addr_info-&gt;ai_mxhostname = NULL; if (labelLength != 0) { /* allocate buffer for the expanded name */ asciiPtr = tfGetRawBuffer((uint)labelLength); addr_info-&gt;ai_mxhostname = asciiPtr; if (asciiPtr != NULL) { /* copy MX hostname to `asciiPtr` as ASCII */ tfDnsLabelToAscii(resourceRecordAfterNamePtr + 0xc, asciiPtr, dnsHeaderPtr, 1, 0); /* ... */ } /* ... */ } /* ... */ } /* ... */ } } tt16Bit tfDnsExpLabelLength(tt8BitPtr labelPtr, tt8BitPtr pktDataPtr, tt8BitPtr labelEndPtr){ tt8Bit currLabelLength; tt16Bit i = 0, totalLength = 0; tt8BitPtr newLabelPtr; while (&amp;labelPtr[i] &lt; labelEndPtr &amp;&amp; labelPtr[i] != 0) { currLabelLength = labelPtr[i]; if ((currLabelLength &amp; 0xc0) == 0) { totalLength += currLabelLength + 1; i += currLabelLength + 1; } else { if (&amp;labelPtr[i+1] &lt; labelEndPtr) { newLabelPtr = pktDataPtr + (((currLabelLength &amp; 0x3f) &lt;&lt; 8) | labelPtr[i+1]); if (newLabelPtr &lt; labelPtr) { labelPtr = newLabelPtr; i = 0; continue; } } return 0; } } return totalLength; } First of all, we understand by the name that resourceRecordAfterNamePtr and dnsHeaderPtr are both pointers and that RDLENGTH since is a length is most likely an unsigned integer. Then, labelEndPtr pointer gets formed by adding to resourceRecordAfterNamePtr the term 10 + RDLENGTH: labelEndPtr = resourceRecordAfterNamePtr + 10 + RDLENGTH; Then, below, tfDnsExpLabelLength() is called with resourceRecordAfterNamePtr + 0xc, dnsHeaderPtr, labelEndPtr parameters, all user-controlled. If we look closer at this code we can see that first memory access from labelPtr (which is user-controlled) is being performed and stored in currLabelLength: currLabelLength = labelPtr[i]; And then several additions are done to create the value totalLength. Since this operations have no validations and there can as many labels as user wants (or said in other words, labelEndPtr is user-controlled and there can be as many iterations as user wants), an integer overflow can be done, returning small totalLength value. This value is returned in labelLength which is used to allocate memory for a buffer: /* allocate buffer for the expanded name */ asciiPtr = tfGetRawBuffer((uint)labelLength); Thus, the integer overflow can result in a underallocation which later in tfDnsLabelToAscii results in an overcopying vulnerability o buffer overflows. 4.5. CVE-2020-16225. Consider the following code: ////ACID: The data read from staFileHandler FILE *staFileHandler; //File handler is valid and already points to 0x200 location //in .sta file being loaded. size_t x; size_t y; size_t allocSize; void *memoryAllocation; fread(&amp;x, 4, 1, staFileHandler); fread(&amp;y, 4, 1, staFileHandler); allocSize = y - x; memoryAllocation = VirtualAlloc(0, allocSize, 0x3000, 4); fread(memoryAllocation + x, 1, allocSize, staFileHandler); Without validation of any type, allocsize is the substraction between two unsigned integer. This can lead to an integer underflow; A huge allocSize value which leads into a huge allocation which later can resultn in an overreading due to the fact that fread() is dumping allocSize bytes from staFileHandler into memoryAllocation + x which is also partially user-controlled. 4.6. CVE-2020-17443. picoTCP is a lightweight TCP/IP stack designed for embedded systems and IoT devices. The vulnerability exists in the DNS response parsing code, specifically in how the stack handles DNS name compression pointers. When parsing DNS responses, picoTCP decompresses domain names that use DNS compression (the 0xC0 pointer mechanism). The flaw occurs during length calculation for the decompressed name. Let's check the code: ////ACID: echo static int pico_icmp6_send_echoreply(struct pico_frame *echo) { struct pico_frame *reply = NULL; struct pico_icmp6_hdr *ehdr = NULL, *rhdr = NULL; struct pico_ip6 src; struct pico_ip6 dst; reply = pico_proto_ipv6.alloc(&amp;pico_proto_ipv6, echo-&gt;dev, (uint16_t)(echo-&gt;transport_len)); if (!reply) { pico_err = PICO_ERR_ENOMEM; return -1; } echo-&gt;payload = echo-&gt;transport_hdr + PICO_ICMP6HDR_ECHO_REQUEST_SIZE; reply-&gt;payload = reply-&gt;transport_hdr + PICO_ICMP6HDR_ECHO_REQUEST_SIZE; reply-&gt;payload_len = echo-&gt;transport_len; ehdr = (struct pico_icmp6_hdr *)echo-&gt;transport_hdr; rhdr = (struct pico_icmp6_hdr *)reply-&gt;transport_hdr; rhdr-&gt;type = PICO_ICMP6_ECHO_REPLY; rhdr-&gt;code = 0; rhdr-&gt;msg.info.echo_reply.id = ehdr-&gt;msg.info.echo_reply.id; rhdr-&gt;msg.info.echo_reply.seq = ehdr-&gt;msg.info.echo_request.seq; memcpy(reply-&gt;payload, echo-&gt;payload, (uint32_t)(echo-&gt;transport_len - PICO_ICMP6HDR_ECHO_REQUEST_SIZE)); rhdr-&gt;crc = 0; rhdr-&gt;crc = short_be(pico_icmp6_checksum(reply)); /* Get destination and source swapped */ memcpy(dst.addr, ((struct pico_ipv6_hdr *)echo-&gt;net_hdr)-&gt;src.addr, PICO_SIZE_IP6); memcpy(src.addr, ((struct pico_ipv6_hdr *)echo-&gt;net_hdr)-&gt;dst.addr, PICO_SIZE_IP6); pico_ipv6_frame_push(reply, &amp;src, &amp;dst, PICO_PROTO_ICMP6, 0); return 0; } /* allocates an IPv6 packet without extension headers. If extension headers are needed, * include the len of the extension headers in the size parameter. Once a frame acquired * increment net_len and transport_hdr with the len of the extension headers, decrement * transport_len with this value. */ static struct pico_frame *pico_ipv6_alloc(struct pico_protocol *self, struct pico_device *dev, uint16_t size) { struct pico_frame *f = NULL; IGNORE_PARAMETER(self); if (0) {} #ifdef PICO_SUPPORT_6LOWPAN else if (PICO_DEV_IS_6LOWPAN(dev)) { f = pico_proto_6lowpan_ll.alloc(&amp;pico_proto_6lowpan_ll, dev, (uint16_t)(size + PICO_SIZE_IP6HDR)); } #endif else { #ifdef PICO_SUPPORT_ETH f = pico_proto_ethernet.alloc(&amp;pico_proto_ethernet, dev, (uint16_t)(size + PICO_SIZE_IP6HDR)); #else f = pico_frame_alloc(size + PICO_SIZE_IP6HDR + PICO_SIZE_ETHHDR); #endif } if (!f) return NULL; f-&gt;net_len = PICO_SIZE_IP6HDR; f-&gt;transport_hdr = f-&gt;net_hdr + PICO_SIZE_IP6HDR; f-&gt;transport_len = (uint16_t)size; /* Datalink size is accounted for in pico_datalink_send (link layer) */ f-&gt;len = (uint32_t)(size + PICO_SIZE_IP6HDR); return f; } Then, lets go part by part: After a few definitions and declarations: struct pico_frame *reply = NULL; struct pico_icmp6_hdr *ehdr = NULL, *rhdr = NULL; struct pico_ip6 src; struct pico_ip6 dst; Part of the echo contents are dumped on reply structure: echo-&gt;payload = echo-&gt;transport_hdr + PICO_ICMP6HDR_ECHO_REQUEST_SIZE; reply-&gt;payload = reply-&gt;transport_hdr + PICO_ICMP6HDR_ECHO_REQUEST_SIZE; reply-&gt;payload_len = echo-&gt;transport_len; Thus, this data-piece are user-controlled, Later on the code, and without any previous validation, a memcpy() operation is performed: memcpy(reply-&gt;payload, echo-&gt;payload, (uint32_t)(echo-&gt;transport_len - PICO_ICMP6HDR_ECHO_REQUEST_SIZE)); Observe that, destination, source and the size are essentially user controlled. Since the size is a mathematical operation (a substraction) between a user-controlled data and a constant, potentially leading to an underflow, since the value is casted as an unsigned integer, the underflow would result in basically in a huge value as the size to be copied. Thus, this is a what-where-write vulnerability. 4.7. CVE-2021-30860 "FORCEDENTRY". JBIG2 (Joint Bi-level Image Experts Group) is an image compression format. JBIG2 data streams can be embedded into PDF files. PDF files will be automatically processed when delivered to a Mac/iPhone via iMessages Therefore this is suitable for "zero-click" exploits, where the victim doesn't need to do anything (like clicking on a file or link) in order to be exploited Apple had recently introduced a new sandboxing measure ("BlastDoor") to process ACID in a more restricted environment… but it turns out PDF files were not sandboxed… Lets check the code: enum JBIG2SegmentType { jbig2SegBitmap, jbig2SegSymbolDict, jbig2SegPatternDict, jbig2SegCodeTable }; ////ACID: refSegs, nRefSegs void JBIG2Stream::readTextRegionSeg(unsigned int segNum, bool imm, bool lossless, unsigned int length, unsigned int *refSegs, unsigned int nRefSegs){ JBIG2Segment *seg; std::vector codeTables; JBIG2SymbolDict *symbolDict; JBIG2Bitmap **syms; unsigned int huff; unsigned int numSyms, symCodeLen; unsigned int i, k, kk; // ... // get symbol dictionaries and tables numSyms = 0; for (i = 0; i &lt; nRefSegs; ++i) { if ((seg = findSegment(refSegs[i]))) { if (seg-&gt;getType() == jbig2SegSymbolDict) { numSyms += ((JBIG2SymbolDict *)seg)-&gt;getSize(); } else if (seg-&gt;getType() == jbig2SegCodeTable) { codeTables.push_back(seg); } } else { error(errSyntaxError, curStr-&gt;getPos(), "Invalid segment reference in JBIG2 text region"); return; } } // ... // get the symbol bitmaps syms = (JBIG2Bitmap **)gmallocn(numSyms, sizeof(JBIG2Bitmap *)); if (numSyms &gt; 0 &amp;&amp; !syms) { return; } kk = 0; for (i = 0; i &lt; nRefSegs; ++i) { if ((seg = findSegment(refSegs[i]))) { if (seg-&gt;getType() == jbig2SegSymbolDict) { symbolDict = (JBIG2SymbolDict *)seg; for (k = 0; k &lt; symbolDict-&gt;getSize(); ++k) { syms[kk++] = symbolDict-&gt;getBitmap(k); } } } } //... } We can inmediately see that, first an integer's value (numSyms) is calculated within a for and an if user-controlled statement: unsigned int numSyms, symCodeLen; //... numSyms = 0; for (i = 0; i &lt; nRefSegs; ++i) { if ((seg = findSegment(refSegs[i]))) { if (seg-&gt;getType() == jbig2SegSymbolDict) { numSyms += ((JBIG2SymbolDict *)seg)-&gt;getSize(); Since there is no validation, this calculation could lead to a integer overflow. Later, this value is used to allocated memory which in combination with the integer overflow risk can lead to an under-allocation: syms = (JBIG2Bitmap **)gmallocn(numSyms, sizeof(JBIG2Bitmap *)); Later, syms pointer gets used in a user-controlled for-loop in which receives data assignation, if an under-allocation gets performed, then this for loop can trigger an overcopying: for (i = 0; i &lt; nRefSegs; ++i) { if ((seg = findSegment(refSegs[i]))) { if (seg-&gt;getType() == jbig2SegSymbolDict) { symbolDict = (JBIG2SymbolDict *)seg; for (k = 0; k &lt; symbolDict-&gt;getSize(); ++k) { syms[kk++] = symbolDict-&gt;getBitmap(k); 4.8. CVE-2021-22636. Texas Instruments + FreeRTOS (Open Source). Consider the following code: int16_t _BundleCmdSignatureFile_Parse( OtaArchive_BundleCmdTable_t *pBundleCmdTable, uint8_t *pRecvBuf, //XENO: ACID: TAR file received over network int16_t RecvBufLen, //XENO: SACI: Size of TAR file received over network int16_t *ProcessedSize, uint32_t SigFileSize, //XENO: ACID: Size from TAR file headers uint8_t *pDigest) { int16_t retVal = 0; char * pSig = NULL; /* Get the entire signature file */ retVal = GetEntireFile(pRecvBuf, RecvBufLen, ProcessedSize, SigFileSize, &amp;pSig); if(retVal &lt; 0) { return(retVal); } if(retVal == GET_ENTIRE_FILE_CONTINUE) { return(ARCHIVE_STATUS_BUNDLE_CMD_SIGNATURE_CONTINUE); } /* Verify the signature using ECDSA */ retVal = verifySignature(pSig, SigFileSize, pDigest); if(retVal &lt; 0) { _SlOtaLibTrace(( "[_BundleCmdSignatureFile_Parse] " "signature verification failed!\r\n")); return(retVal); } pBundleCmdTable-&gt;VerifiedSignature = 1; return(ARCHIVE_STATUS_BUNDLE_CMD_SIGNATURE_DOWNLOAD_DONE); } int16_t GetEntireFile(uint8_t *pRecvBuf, int16_t RecvBufLen, int16_t *ProcessedSize, uint32_t FileSize, char **pFile) { int16_t copyLen = 0; static bool firstRun = TRUE; static int16_t TotalRecvBufLen = 0; if(firstRun) { TotalRecvBufLen = RecvBufLen; firstRun = FALSE; if(TotalRecvBufLen &lt; FileSize) { /* Didn't receive the entire file in the first run. */ /* Allocate a buffer in the size of the entire file and fill it in each round. */ pTempBuf = (char*)malloc(FileSize + 1); if(pTempBuf == NULL) { /* Allocation failed, return error. */ return(-1); } memcpy(pTempBuf, (char *)pRecvBuf, RecvBufLen); *ProcessedSize = RecvBufLen; /* didn't receive the entire file, try in the next packet */ return(GET_ENTIRE_FILE_CONTINUE); } else { /* Received the entire file in the first run. */ /* No additional memory allocation is needed. */ *ProcessedSize = FileSize; *pFile = (char *)pRecvBuf; } } else { /* Avoid exceeding buffer size (FileSize + 1) */ if(RecvBufLen &gt; ((FileSize + 1) - TotalRecvBufLen)) { copyLen = ((FileSize + 1) - TotalRecvBufLen); } else { copyLen = RecvBufLen; } /* Copy the received buffer from where we stopped the previous copy */ memcpy(&amp;(pTempBuf[TotalRecvBufLen]), (char *)pRecvBuf, copyLen); *ProcessedSize = copyLen; TotalRecvBufLen += copyLen; if(TotalRecvBufLen &lt; FileSize) { /* didn't receive the entire file, try in the next packet */ return(GET_ENTIRE_FILE_CONTINUE); } /* At this point we have the whole file */ *pFile = (char *)pTempBuf; } /* Set static variables to initial values to allow retry in case of a warning during the OTA process */ firstRun = TRUE; TotalRecvBufLen = 0; return(GET_ENTIRE_FILE_DONE); } void ATTRIBUTE *malloc(size_t size) { Header *packet; if (size == 0) { errno = EINVAL; return (NULL); } packet = (Header *)pvPortMalloc(size + sizeof(Header)); if (packet == NULL) { errno = ENOMEM; return (NULL); } packet-&gt;header.actualBuf = (void *)packet; packet-&gt;header.size = size + sizeof(Header); return (packet + 1); } We can see that first, pRecvBuf, RecvBufLen and SigFileSize are user-controlled. This values are passed to GetEntireFile() and then they get included in the following code chunk: int16_t copyLen = 0; static bool firstRun = TRUE; static int16_t TotalRecvBufLen = 0; if(firstRun) { TotalRecvBufLen = RecvBufLen; firstRun = FALSE; if(TotalRecvBufLen &lt; FileSize) { /* Didn't receive the entire file in the first run. */ /* Allocate a buffer in the size of the entire file and fill it in each round. */ pTempBuf = (char*)malloc(FileSize + 1); if(pTempBuf == NULL) { /* Allocation failed, return error. */ return(-1); } On it, we can see that firstRun at first gets assgined as TRUE, so the code flow jumps to the second if statement in which it compares TotalRecvBufLen &lt; FileSize, since both values are user-controlled, this statement also is true and then comes malloc with maths over a user-controlled parameter. Since FileSize is an unsigned integer, this addtion can go to an integer overflow passing from the most bigger value to a small one. Initially, if this was the normal malloc() function, FileSize biggest value should turn the operand 0 and malloc would return to us a NULL pointer, but the current malloc() function is wrapper around pvPortMalloc() function. If we check that implementation: void ATTRIBUTE *malloc(size_t size) { Header *packet; if (size == 0) { errno = EINVAL; return (NULL); } packet = (Header *)pvPortMalloc(size + sizeof(Header)); if (packet == NULL) { errno = ENOMEM; return (NULL); } we can see that in fact is a wrapper around pvPortMalloc() and that if FileSize was a value satisfying: FileSize + 1 + sizeof(Header) = 1 Assuming that this addition is within the ring of module 32 integers, malloc function should return us a one byte-size pointer. This is, this malloc function is not protected against an underflow provoked by an integer overflow result by the way this function is called. Automatically below, a memcpy() operation is performed with this underallocated pointer as a destination, using user-controlled values as source and length of the memcpy(): memcpy(pTempBuf, (char *)pRecvBuf, RecvBufLen); Leading to a what-where-write vulnerability.]]></summary></entry><entry><title type="html">Other Integer Issues.</title><link href="http://localhost:4000/posts/2025/12/05/OtherIntegerIssues/" rel="alternate" type="text/html" title="Other Integer Issues." /><published>2025-12-05T10:00:00+01:00</published><updated>2025-12-05T10:00:00+01:00</updated><id>http://localhost:4000/posts/2025/12/05/OtherIntegerIssues</id><content type="html" xml:base="http://localhost:4000/posts/2025/12/05/OtherIntegerIssues/"><![CDATA[<h3 id="1-definition">1. Definition.</h3>

<p>This section is an extension about Integers Overflow issues. We are going to cover three topics:</p>

<ul>
  <li>Incorrect Signed Sanity Checks.</li>
  <li>Signed or unsigned integer truncation.</li>
  <li>Signed Integer extension issues.</li>
</ul>

<p><br /></p>

<h3 id="2-incorrect-signed-sanity-checks">2. Incorrect Signed Sanity Checks.</h3>

<h4 id="21-definition">2.1. Definition.</h4>

<p>Incorrect Signed Sanity Checks refers to the idea of bad sanity checks implementation due to the unprevention of negative values being allowed and later cast into the execution flow as unsigned values effectively bypassing the sanitization measure.</p>

<p>To be a bit more precise the issue arises when a signed integer is checked against an upper bound (len &lt; MAX_SIZE) but the check fails to account for negative values. When that signed integer is later used in a context that interprets it as unsigned (like memcpy(dst, src, len) where the len parameter is size_t),</p>

<p><br /></p>

<h4 id="22-examples">2.2. Examples.</h4>

<h5 id="221-trivial-example">2.2.1 Trivial Example.</h5>

<p>Let's consider the following C code.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Nice try *ATTACKER*! But I'm too clever for you!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"We got an input string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>First, we declare an array of maximum 100 bytes width and then we capture the cli first argument from the user interpreted as a hexadecimal value to <em>size</em> /(a signed integer).</p>

<p>Then, in order to prevent a Linear Stack Buffer Overflow a comparative check is performed over <em>size</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Nice try *ATTACKER*! But I'm too clever for you!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If size was an unsigned integer, this check would work just fine since every value bigger than 100 would be succesfully blocked and then pass as the third argument (length) to memcpy() function.</p>

<p>However, there is a subtle problem. On the signature of a function, there are defined parameter to pass to that function as datatypes. This means that, whenever you pass a value to a function, this values gets cast to the funtion's demanded datatype, for example, if we look over the memcpy() function definition:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span> <span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">destination</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div></div>

<p>We can see that the third argument gets cast to a <em>size_t</em> datatype, which means that if a signed value lands as the length argument of memcpy() it will be interpreted as an unsigned integer.</p>

<p>This link with the fact that <em>size</em> is a signed integer, so, lets consider that the user pass a negative value, for example, "0xFFFFFFFFFFFFFF9B" (-101), then the comparation -101 &gt; 100 is
false, so the flow of execution goes towards memcpy, but when passed to memcpy "0xFFFFFFFFFFFFFF9B" is interpreted as an unsigned integer: "4,294,967,195", provoking an overcopy in the memcpy() function.</p>

<p>It is said that signed sanity checks 50% of the times works 100% of the time.</p>

<p><br /></p>

<h5 id="222-bad-sanity-check-1">2.2.2. Bad Sanity Check 1.</h5>

<p>Another example of signed sanity checks can be the following:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">my_header</span><span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_header_t</span><span class="p">;</span>

<span class="c1">// Under-allocate, over-copy, bad sanity check</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
        <span class="n">my_header_t</span> <span class="n">header</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_size</span><span class="p">;</span>
        <span class="n">header</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x6f6e6558</span><span class="p">;</span>
        <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x1000</span><span class="p">){</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Nice try *ATTACKER*! But I'm too clever for you!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"String self-reported size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Allocation size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"buf points to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">));</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"memcpy()ing 0x%08X bytes into buf of size 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"We copied input string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Again, cli argument from user gets passed to header.size (signed integer) and is used to first, alloc memory through an unsigned integer to a destination buffer which later is gonna be used in a memcpy() operation with user-controlled length:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//...</span>
<span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">));</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"memcpy()ing 0x%08X bytes into buf of size 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
<span class="c1">//...</span>
</code></pre></div></div>

<p>Here the thing is kind of more convulate than the previous example, but vulnerable in anyway.</p>

<p>A protection mechanism as an <em>if statement</em> to prevent header.size be bigger than certain value is implemented:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x1000</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Nice try *ATTACKER*! But I'm too clever for you!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>the issue is that again, header.size is signed datatype and this comparison does not protect against big absolute negative numbers being pass in to the execution flow.</p>

<p>Thus, if header.size was a value that satisfies:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>First, a one-byte allocation would be performed and <em>buf</em> pointer would point to that chunk, then , lets note that header.size has to be big absolute negative value by force since <em>sizeof(my_header_t) = 8</em> and would be pass as a size_t datatype (unsigned) to memcpy(), meaning that from a negative near-cero value, as an unsigned, it would become a big absolute value provoking an overflow.</p>

<p><br /></p>

<h5 id="223-bad-sanity-check-2">2.2.3. Bad Sanity Check 2.</h5>

<p>Let's consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">my_header</span><span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_header_t</span><span class="p">;</span>

<span class="c1">// Under-allocate, over-copy, bad sanity check</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
        <span class="n">my_header_t</span> <span class="n">header</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_size</span><span class="p">;</span>
        <span class="n">header</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x6f6e6558</span><span class="p">;</span>
        <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mh">0x100000000</span><span class="p">){</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Nice try *ATTACKER*! But I'm too clever for you!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"String self-reported size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Allocation size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"buf points to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">));</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"memcpy()ing 0x%08X bytes into buf of size 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"We copied input string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code is kind of similar to the one before, but instead of implement a one-value comparison, is establishing a comparison of an addition of two different-sign dataypes.</p>

<p>Here, enters what in C is known as implicit conversions, an arithemtic operation of two values of the same datatypes and different signs results in the signed value to get automatically converted to the unsigned type before the arithmetic opeation resolution.</p>

<p>This means that, header.size bits-pattern value is interpreted as unsigned, thus a near-to-cero negative value can be interpreted as big postiive number which in addition with sizeof(my_header_t) could trigger an integer overflow and become a small positive value bypassing the size constraint.</p>

<p>Then, this addition is again performed and assignated to alloc_size (unsigned integer) resulting in an under-allocation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alloc_size</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"String self-reported size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Allocation size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
</code></pre></div></div>

<p>And later, a memcpy operation over this small memory region is performed passing header.size as length again as size_t (unsigned), thus triggering an over-copy.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="3-integer-truncation">3. Integer Truncation.</h3>

<p>As we disscussed in <a href="https://gsanmi1.github.io/2025-12-05-IntegerOverflow-Underflow/">Integer Overflow</a> paper, every C value has associated a datatype which has a size and sometimes a sign (if is an integer subtype). Essentially, a value is a bit pattern stored in memory that acquires full definition when gets interpreted by the CPU following the instructions generated by the compiler.</p>

<p><em>Integer Truncation</em> is a phenomenon in which the bit-pattern of an integer gets chopped off when the value gets converted from a wider datatype to a narrower one transforming the data in a defined way.</p>

<p>When this size-datatype downgrade gets defined, the compiler generates an instruction to copy part of the bit-string of the value to another location, then when executed, the instruction makes the CPU strip off the bitchain lefting the lowerbits and operating with them as a new different value in the next instructions.</p>

<p>For example, consider the following conversion:</p>

<p>​<code class="language-plaintext highlighter-rouge">c
uint32_t wide = 0x0001FFFF;  // 131071 in decimal
uint16_t narrow = wide;      // narrow = 0xFFFF (65535)
​</code></p>

<p>The 32-bit value '0x0001FFFF' has the following bit pattern:</p>

<p>​<code class="language-plaintext highlighter-rouge">less
0000 0000 0000 0001 1111 1111 1111 1111
|______upper 16____||____lower 16_____|
      discarded           retained
​</code></p>

<p>When the C code gets compiled, the compiler would generate an instruction like the following:</p>

<pre><code class="language-assem">mov eax, dword ptr [rbp - 8h]           ; In which original value exists
mov word ptr [rbp - 10h], ax            ; Copying to a new location only the 16 retained bits
</code></pre>

<p>The original value was 131071, but after truncation it becomes 65535 — a completely different value, which can lead to serious vulnerabilities if the program logic assumes the full original value is preserved.</p>

<p><br /></p>

<h4 id="31-trivial-example">3.1. Trivial Example.</h4>

<p>Let's consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">my_header</span><span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_header_t</span><span class="p">;</span>

<span class="c1">// Under-allocate (via truncation), over-copy</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
        <span class="n">my_header_t</span> <span class="n">header</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">alloc_size</span><span class="p">;</span>
        <span class="n">header</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="mh">0x6f6e6558</span><span class="p">;</span>
        <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
        <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"String self-reported size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Allocation size = 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"buf points to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">));</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"memcpy()ing 0x%08X bytes into buf of size 0x%08X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"We copied input string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code is similar to the used in other examples but with the subtle differences that in this case, alloc_size is a short, not a int.</p>

<p>Thus, for example, consider that the user pass as the first cli parameter to the program (argv[1]), which is an int and occupies 4 bytes, have the value 0xFFFF0000 (two hex-digits per byte, 4 pairs of digits), then, this value would end up in header.size and later would be used in an arithmetic operation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_header_t</span><span class="p">);</span>
</code></pre></div></div>

<p>Note that, at a first glance, 0xFFFF0000 + 0x00000008 = 0xFFFF0008 and nothing wrong happens regards to the integer overflow subject we studied before. However this int-wide value is now assigned to an narrower datatype (unsigned short), when performing the assignation, the compiler truncates the value to a short, keeping the two rightmost bytes effectively wrapping it to 0x0008 which is then saved in <em>alloc_size</em>.</p>

<p>As a result, an under-allocation is performed and later, the complete int-wide value (header.size) is used to perfom an memcpy() operation, triggering an over-copy:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="4-signed-arithmetics">4. Signed-Arithmetics.</h3>

<h4 id="41-pointer-arithmetics-with-signed-integers">4.1. Pointer arithmetics with signed integers.</h4>
<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">//Pointer arithmetic + sign extension - pase.c</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">ptr1</span><span class="p">,</span> <span class="o">*</span> <span class="n">ptr2</span><span class="p">;</span>
        <span class="kt">short</span> <span class="n">size1</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">size2</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
        <span class="n">ptr1</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">size1</span><span class="p">;</span>
        <span class="n">ptr2</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">size2</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"buf =  %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"ptr1 = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"ptr2 = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr2</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Pointer arithmetics are being performed with signed integers which result to be negative values, the MAX_SIZE for an integer hexadecimal value always is 0x7FF…, both values are one bit over the maximum positive value and thus are small negative numbers, thus the arithmetic operation with pointer is not an addition, but a substraction, the pointer now points above the buffer an, for example, use it in a data-copy operation would result in an out-of-bounds.</p>

<p>As a result, any operation performed with a signed datatype can lead to a misscalculation resulting in a potential security issue and must be reviewed carefully.</p>

<p><br /></p>

<h4 id="42-signed-extension">4.2. Signed Extension.</h4>

<p>Another example on how signed-datatype poorly handled can generate issue is through the sign extension mechanismo. In which a signed datatypes gets converted to a bigger size datatype preserving the sign:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">signed</span> <span class="kt">char</span> <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>           <span class="c1">// Malicious input: -1</span>
<span class="kt">size_t</span> <span class="n">array_index</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>       <span class="c1">// Sign extended to large positive.</span>
<span class="c1">// On 64-bit: array_index = 0xFFFFFFFFFFFFFFFF (huge number!)</span>
</code></pre></div></div>

<p>If later this sign extension is used as an unsigned integer troubles can arise:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>    
<span class="n">buffer</span><span class="p">[</span><span class="n">array_index</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="p">;</span>     <span class="c1">// Out-of-bounds access!</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="5-exercises">5. Exercises.</h3>

<h4 id="51-cve-2019-15948">5.1. CVE-2019-15948.</h4>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////ACID: where ptr_ll_pkt points after assignment</span>
<span class="c1">// Pseudocode from Ghidra decompilation</span>
<span class="kt">void</span> <span class="nf">process_adv_ind_pdu</span><span class="p">(</span><span class="kt">int</span> <span class="n">ptr_some_struct</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">byte</span> <span class="n">bVar1</span><span class="p">;</span>
  <span class="n">byte</span> <span class="n">ll_len</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">uVar2</span><span class="p">;</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">ptr_ll_pkt</span><span class="p">;</span>
  <span class="n">undefined</span> <span class="n">local_40</span><span class="p">;</span>
  <span class="n">byte</span> <span class="n">local_3f</span><span class="p">;</span>
  <span class="n">undefined</span> <span class="n">auStack62</span> <span class="p">[</span><span class="mh">0x6</span><span class="p">];</span>
  <span class="n">undefined</span> <span class="n">local_38</span><span class="p">;</span>
  <span class="n">undefined</span> <span class="n">stack_buffer</span> <span class="p">[</span><span class="mh">0x1f</span><span class="p">];</span>
  <span class="n">undefined</span> <span class="n">local_18</span><span class="p">;</span>

  <span class="n">ptr_ll_pkt</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)(</span><span class="n">DAT_0005b528</span> <span class="o">+</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ushort</span> <span class="o">*</span><span class="p">)(</span><span class="n">ptr_some_struct</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">));</span>
  <span class="n">bVar1</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr_ll_pkt</span><span class="p">;</span>
  <span class="n">ll_len</span> <span class="o">=</span> <span class="n">ptr_ll_pkt</span><span class="p">[</span><span class="mh">0x1</span><span class="p">];</span>
  <span class="n">uVar2</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">bVar1</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
  <span class="n">local_3f</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span><span class="p">)(((</span><span class="n">uint</span><span class="p">)</span><span class="n">bVar1</span> <span class="o">&lt;&lt;</span> <span class="mh">0x19</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mh">0x1f</span><span class="p">);</span>
  <span class="n">FUN_00067554</span><span class="p">(</span><span class="n">auStack62</span><span class="p">,</span><span class="n">ptr_ll_pkt</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">,</span><span class="mh">0x6</span><span class="p">);</span>
  <span class="n">n</span> <span class="o">=</span> <span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">ll_len</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x6</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
  <span class="n">local_38</span> <span class="o">=</span> <span class="p">(</span><span class="n">undefined</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">stack_buffer</span><span class="p">,</span><span class="n">ptr_ll_pkt</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
  <span class="n">local_18</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">undefined</span> <span class="o">*</span><span class="p">)(</span><span class="n">ptr_some_struct</span> <span class="o">+</span> <span class="mh">0xa</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">bVar1</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">local_40</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uVar2</span> <span class="o">==</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">local_40</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
      <span class="n">local_38</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">uVar2</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">local_40</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uVar2</span> <span class="o">!=</span> <span class="mh">0x6</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">local_40</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">FUN_000398e2</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_40</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let's observe that at first, a memcpy() operation is taking place:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">stack_buffer</span><span class="p">,</span><span class="n">ptr_ll_pkt</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<p>Where,</p>

<ul>
  <li><em>stack_buffer</em> is stack-buffer of [\0x1f] slots.</li>
  <li><em>ptr_ll_pkt</em> is user-controlled source.</li>
  <li><em>n</em> is a user-controlled parameter with a fixed size.</li>
</ul>

<p>Let's make counts:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">ll_len</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x6</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
</code></pre></div></div>

<p><em>ll_len</em> is user-conttrolled, since is casted as a unsigned integer, then "(uint)ll_len &amp; 0x3f" is also casted as unsigned integer and also the substraction "((uint)ll_len &amp; 0x3f) - 0x6" is unsigned. Then, is <em>ll_len</em> is a value that makes 0 the term "((uint)ll_len &amp; 0x3f)", then, -0x6 is (as an unsigned integer), 0xFFFFFFFA which masked with 0xFF is 0xFA.</p>

<p>So <em>n</em> can have as maxim value 0xFA versus the size of the array which is 0x1F, thus a stack buffer overflow arises.</p>

<p><br /></p>

<h4 id="52-cve-2020-15999">5.2. CVE-2020-15999.</h4>

<p>Google Chrome uses the open source FreeType project, which renders fonts and PNG images embedded in fonts.</p>

<p>Consider the following C code. The code attemps to process PNG images in fonts. Retrieves the images width and height from the header stores them in an special structure, calculates the bitmap size and allocates it back in store for that size.</p>

<p>Then calls for another library function to copy data from the PNG int the allocate space before.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if CHAR_BIT == 8 &amp;&amp; UCHAR_MAX == 255
</span>   <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">png_byte</span><span class="p">;</span>
<span class="cp">#else
#  error "libpng requires 8-bit bytes"
#endif
</span>
<span class="k">typedef</span> <span class="kt">char</span>  <span class="n">FT_String</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">FT_Byte</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">char</span>  <span class="n">FT_Char</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">FT_Bool</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">short</span>  <span class="n">FT_FWord</span><span class="p">;</span>   <span class="cm">/* distance in FUnits */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">FT_UFWord</span><span class="p">;</span>  <span class="cm">/* unsigned distance */</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">short</span>  <span class="n">FT_Short</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">FT_UShort</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">int</span>  <span class="n">FT_Int</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">FT_UInt</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">long</span>  <span class="n">FT_Long</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">FT_ULong</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>  <span class="n">FT_Bitmap_</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">rows</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">width</span><span class="p">;</span>
  <span class="kt">int</span>             <span class="n">pitch</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>  <span class="n">buffer</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">num_grays</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">pixel_mode</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">palette_mode</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span>           <span class="n">palette</span><span class="p">;</span>
<span class="p">}</span> <span class="n">FT_Bitmap</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>  <span class="n">TT_SBit_MetricsRec_</span>
<span class="p">{</span>
  <span class="n">FT_UShort</span>  <span class="n">height</span><span class="p">;</span>
  <span class="n">FT_UShort</span>  <span class="n">width</span><span class="p">;</span>

  <span class="n">FT_Short</span>   <span class="n">horiBearingX</span><span class="p">;</span>
  <span class="n">FT_Short</span>   <span class="n">horiBearingY</span><span class="p">;</span>
  <span class="n">FT_UShort</span>  <span class="n">horiAdvance</span><span class="p">;</span>

  <span class="n">FT_Short</span>   <span class="n">vertBearingX</span><span class="p">;</span>
  <span class="n">FT_Short</span>   <span class="n">vertBearingY</span><span class="p">;</span>
  <span class="n">FT_UShort</span>  <span class="n">vertAdvance</span><span class="p">;</span>

<span class="p">}</span> <span class="n">TT_SBit_MetricsRec</span><span class="p">,</span> <span class="o">*</span><span class="n">TT_SBit_Metrics</span><span class="p">;</span>

<span class="c1">////ACID: data, png_len</span>
  <span class="n">FT_LOCAL_DEF</span><span class="p">(</span> <span class="n">FT_Error</span> <span class="p">)</span>
  <span class="n">Load_SBit_Png</span><span class="p">(</span> <span class="n">FT_GlyphSlot</span>     <span class="n">slot</span><span class="p">,</span>
                 <span class="n">FT_Int</span>           <span class="n">x_offset</span><span class="p">,</span>
                 <span class="n">FT_Int</span>           <span class="n">y_offset</span><span class="p">,</span>
                 <span class="n">FT_Int</span>           <span class="n">pix_bits</span><span class="p">,</span>
                 <span class="n">TT_SBit_Metrics</span>  <span class="n">metrics</span><span class="p">,</span>
                 <span class="n">FT_Memory</span>        <span class="n">memory</span><span class="p">,</span>
                 <span class="n">FT_Byte</span><span class="o">*</span>         <span class="n">data</span><span class="p">,</span>
                 <span class="n">FT_UInt</span>          <span class="n">png_len</span><span class="p">,</span>
                 <span class="n">FT_Bool</span>          <span class="n">populate_map_and_metrics</span><span class="p">,</span> <span class="c1">//KC: Assume true</span>
                 <span class="n">FT_Bool</span>          <span class="n">metrics_only</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">FT_Bitmap</span>    <span class="o">*</span><span class="n">map</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
    <span class="n">FT_Error</span>      <span class="n">error</span> <span class="o">=</span> <span class="n">FT_Err_Ok</span><span class="p">;</span>
    <span class="n">FT_StreamRec</span>  <span class="n">stream</span><span class="p">;</span>

    <span class="n">png_structp</span>  <span class="n">png</span><span class="p">;</span>
    <span class="n">png_infop</span>    <span class="n">info</span><span class="p">;</span>
    <span class="n">png_uint_32</span>  <span class="n">imgWidth</span><span class="p">,</span> <span class="n">imgHeight</span><span class="p">;</span>
    <span class="kt">int</span>         <span class="n">bitdepth</span><span class="p">,</span> <span class="n">color_type</span><span class="p">,</span> <span class="n">interlace</span><span class="p">;</span>
    <span class="n">FT_Int</span>      <span class="n">i</span><span class="p">;</span>
    <span class="n">png_byte</span><span class="o">*</span>  <span class="o">*</span><span class="n">rows</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* pacify compiler */</span>

    <span class="c1">// ...</span>

    <span class="n">FT_Stream_OpenMemory</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">png_len</span> <span class="p">);</span> <span class="c1">//KC: data ACID-&gt; stream</span>

    <span class="n">png</span> <span class="o">=</span> <span class="n">png_create_read_struct</span><span class="p">(</span> <span class="n">PNG_LIBPNG_VER_STRING</span><span class="p">,</span>
                                  <span class="o">&amp;</span><span class="n">error</span><span class="p">,</span>
                                  <span class="n">error_callback</span><span class="p">,</span>
                                  <span class="n">warning_callback</span> <span class="p">);</span>

    <span class="c1">// ...</span>

    <span class="n">png_set_read_fn</span><span class="p">(</span> <span class="n">png</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span> <span class="n">read_data_from_FT_Stream</span> <span class="p">);</span> <span class="c1">//KC: stream ACID-&gt; png</span>

    <span class="n">png_read_info</span><span class="p">(</span> <span class="n">png</span><span class="p">,</span> <span class="n">info</span> <span class="p">);</span>
    <span class="n">png_get_IHDR</span><span class="p">(</span> <span class="n">png</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span>
                  <span class="o">&amp;</span><span class="n">imgWidth</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imgHeight</span><span class="p">,</span>
                  <span class="o">&amp;</span><span class="n">bitdepth</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">color_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interlace</span><span class="p">,</span>
                  <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">error</span>                                    <span class="o">||</span>
         <span class="p">(</span> <span class="o">!</span><span class="n">populate_map_and_metrics</span>              <span class="o">&amp;&amp;</span>
           <span class="p">(</span> <span class="p">(</span><span class="n">FT_Int</span><span class="p">)</span><span class="n">imgWidth</span>  <span class="o">!=</span> <span class="n">metrics</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">||</span>
             <span class="p">(</span><span class="n">FT_Int</span><span class="p">)</span><span class="n">imgHeight</span> <span class="o">!=</span> <span class="n">metrics</span><span class="o">-&gt;</span><span class="n">height</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
      <span class="k">goto</span> <span class="n">DestroyExit</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">populate_map_and_metrics</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">metrics</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">=</span> <span class="p">(</span><span class="n">FT_UShort</span><span class="p">)</span><span class="n">imgWidth</span><span class="p">;</span>
      <span class="n">metrics</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">FT_UShort</span><span class="p">)</span><span class="n">imgHeight</span><span class="p">;</span>

      <span class="n">map</span><span class="o">-&gt;</span><span class="n">width</span>      <span class="o">=</span> <span class="n">metrics</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
      <span class="n">map</span><span class="o">-&gt;</span><span class="n">rows</span>       <span class="o">=</span> <span class="n">metrics</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
      <span class="n">map</span><span class="o">-&gt;</span><span class="n">pixel_mode</span> <span class="o">=</span> <span class="n">FT_PIXEL_MODE_BGRA</span><span class="p">;</span>
      <span class="n">map</span><span class="o">-&gt;</span><span class="n">pitch</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="mi">4</span> <span class="p">);</span>
      <span class="n">map</span><span class="o">-&gt;</span><span class="n">num_grays</span>  <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

      <span class="cm">/* reject too large bitmaps similarly to the rasterizer */</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">rows</span> <span class="o">&gt;</span> <span class="mh">0x7FFF</span> <span class="o">||</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&gt;</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">FT_THROW</span><span class="p">(</span> <span class="n">Array_Too_Large</span> <span class="p">);</span>
        <span class="k">goto</span> <span class="n">DestroyExit</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">populate_map_and_metrics</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* this doesn't overflow: 0x7FFF * 0x7FFF * 4 &lt; 2^32 */</span>
      <span class="n">FT_ULong</span>  <span class="n">size</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">rows</span> <span class="o">*</span> <span class="p">(</span><span class="n">FT_ULong</span><span class="p">)</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">pitch</span><span class="p">;</span>


      <span class="n">error</span> <span class="o">=</span> <span class="n">ft_glyphslot_alloc_bitmap</span><span class="p">(</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">error</span> <span class="p">)</span>
        <span class="k">goto</span> <span class="n">DestroyExit</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">FT_NEW_ARRAY</span><span class="p">(</span> <span class="n">rows</span><span class="p">,</span> <span class="n">imgHeight</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">//KC: realloc(rows, imgHeight*sizeof(ptr))</span>
    <span class="p">{</span>                                      <span class="c1">//KC: and memset() to 0</span>
      <span class="n">error</span> <span class="o">=</span> <span class="n">FT_THROW</span><span class="p">(</span> <span class="n">Out_Of_Memory</span> <span class="p">);</span>
      <span class="k">goto</span> <span class="n">DestroyExit</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">FT_Int</span><span class="p">)</span><span class="n">imgHeight</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
      <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span> <span class="n">y_offset</span> <span class="o">+</span> <span class="n">i</span> <span class="p">)</span> <span class="o">*</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">pitch</span> <span class="o">+</span> <span class="n">x_offset</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

    <span class="n">png_read_image</span><span class="p">(</span> <span class="n">png</span><span class="p">,</span> <span class="n">rows</span> <span class="p">);</span> <span class="c1">//KC: Uses the same imgWidth/Height from png_get_IHDR() to read the PNG into rows[]</span>
  <span class="p">}</span>

<span class="cm">/* Pointers to pointers; i.e. arrays */</span>
<span class="k">typedef</span> <span class="n">png_byte</span>        <span class="o">*</span> <span class="o">*</span> <span class="n">png_bytepp</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">png_struct_def</span>
<span class="p">{</span>
<span class="cp">#ifdef PNG_SETJMP_SUPPORTED
</span>   <span class="kt">jmp_buf</span> <span class="n">jmp_buf_local</span><span class="p">;</span>     <span class="cm">/* New name in 1.6.0 for jmp_buf in png_struct */</span>
   <span class="n">png_longjmp_ptr</span> <span class="n">longjmp_fn</span><span class="p">;</span><span class="cm">/* setjmp non-local goto function. */</span>
   <span class="kt">jmp_buf</span> <span class="o">*</span><span class="n">jmp_buf_ptr</span><span class="p">;</span>      <span class="cm">/* passed to longjmp_fn */</span>
   <span class="kt">size_t</span> <span class="n">jmp_buf_size</span><span class="p">;</span>       <span class="cm">/* size of the above, if allocated */</span>
<span class="cp">#endif
</span>   <span class="n">png_error_ptr</span> <span class="n">error_fn</span><span class="p">;</span>    <span class="cm">/* function for printing errors and aborting */</span>
<span class="cp">#ifdef PNG_WARNINGS_SUPPORTED
</span>   <span class="n">png_error_ptr</span> <span class="n">warning_fn</span><span class="p">;</span>  <span class="cm">/* function for printing warnings */</span>
<span class="cp">#endif
</span>   <span class="n">png_voidp</span> <span class="n">error_ptr</span><span class="p">;</span>       <span class="cm">/* user supplied struct for error functions */</span>
   <span class="n">png_rw_ptr</span> <span class="n">write_data_fn</span><span class="p">;</span>  <span class="cm">/* function for writing output data */</span>
   <span class="n">png_rw_ptr</span> <span class="n">read_data_fn</span><span class="p">;</span>   <span class="cm">/* function for reading input data */</span>
   <span class="n">png_voidp</span> <span class="n">io_ptr</span><span class="p">;</span>          <span class="cm">/* ptr to application struct for I/O functions */</span>

<span class="cp">#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
</span>   <span class="n">png_user_transform_ptr</span> <span class="n">read_user_transform_fn</span><span class="p">;</span> <span class="cm">/* user read transform */</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
</span>   <span class="n">png_user_transform_ptr</span> <span class="n">write_user_transform_fn</span><span class="p">;</span> <span class="cm">/* user write transform */</span>
<span class="cp">#endif
</span>
<span class="cm">/* These were added in libpng-1.0.2 */</span>
<span class="cp">#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
</span>   <span class="n">png_voidp</span> <span class="n">user_transform_ptr</span><span class="p">;</span> <span class="cm">/* user supplied struct for user transform */</span>
   <span class="n">png_byte</span> <span class="n">user_transform_depth</span><span class="p">;</span>    <span class="cm">/* bit depth of user transformed pixels */</span>
   <span class="n">png_byte</span> <span class="n">user_transform_channels</span><span class="p">;</span> <span class="cm">/* channels in user transformed pixels */</span>
<span class="cp">#endif
#endif
</span>
   <span class="n">png_uint_32</span> <span class="n">mode</span><span class="p">;</span>          <span class="cm">/* tells us where we are in the PNG file */</span>
   <span class="n">png_uint_32</span> <span class="n">flags</span><span class="p">;</span>         <span class="cm">/* flags indicating various things to libpng */</span>
   <span class="n">png_uint_32</span> <span class="n">transformations</span><span class="p">;</span> <span class="cm">/* which transformations to perform */</span>

   <span class="n">png_uint_32</span> <span class="n">zowner</span><span class="p">;</span>        <span class="cm">/* ID (chunk type) of zstream owner, 0 if none */</span>
   <span class="n">z_stream</span>    <span class="n">zstream</span><span class="p">;</span>       <span class="cm">/* decompression structure */</span>

<span class="cp">#ifdef PNG_WRITE_SUPPORTED
</span>   <span class="n">png_compression_bufferp</span> <span class="n">zbuffer_list</span><span class="p">;</span> <span class="cm">/* Created on demand during write */</span>
   <span class="n">uInt</span>                    <span class="n">zbuffer_size</span><span class="p">;</span> <span class="cm">/* size of the actual buffer */</span>

   <span class="kt">int</span> <span class="n">zlib_level</span><span class="p">;</span>            <span class="cm">/* holds zlib compression level */</span>
   <span class="kt">int</span> <span class="n">zlib_method</span><span class="p">;</span>           <span class="cm">/* holds zlib compression method */</span>
   <span class="kt">int</span> <span class="n">zlib_window_bits</span><span class="p">;</span>      <span class="cm">/* holds zlib compression window bits */</span>
   <span class="kt">int</span> <span class="n">zlib_mem_level</span><span class="p">;</span>        <span class="cm">/* holds zlib compression memory level */</span>
   <span class="kt">int</span> <span class="n">zlib_strategy</span><span class="p">;</span>         <span class="cm">/* holds zlib compression strategy */</span>
<span class="cp">#endif
</span><span class="cm">/* Added at libpng 1.5.4 */</span>
<span class="cp">#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
</span>   <span class="kt">int</span> <span class="n">zlib_text_level</span><span class="p">;</span>            <span class="cm">/* holds zlib compression level */</span>
   <span class="kt">int</span> <span class="n">zlib_text_method</span><span class="p">;</span>           <span class="cm">/* holds zlib compression method */</span>
   <span class="kt">int</span> <span class="n">zlib_text_window_bits</span><span class="p">;</span>      <span class="cm">/* holds zlib compression window bits */</span>
   <span class="kt">int</span> <span class="n">zlib_text_mem_level</span><span class="p">;</span>        <span class="cm">/* holds zlib compression memory level */</span>
   <span class="kt">int</span> <span class="n">zlib_text_strategy</span><span class="p">;</span>         <span class="cm">/* holds zlib compression strategy */</span>
<span class="cp">#endif
</span><span class="cm">/* End of material added at libpng 1.5.4 */</span>
<span class="cm">/* Added at libpng 1.6.0 */</span>
<span class="cp">#ifdef PNG_WRITE_SUPPORTED
</span>   <span class="kt">int</span> <span class="n">zlib_set_level</span><span class="p">;</span>        <span class="cm">/* Actual values set into the zstream on write */</span>
   <span class="kt">int</span> <span class="n">zlib_set_method</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">zlib_set_window_bits</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">zlib_set_mem_level</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">zlib_set_strategy</span><span class="p">;</span>
<span class="cp">#endif
</span>
   <span class="n">png_uint_32</span> <span class="n">width</span><span class="p">;</span>         <span class="cm">/* width of image in pixels */</span>
   <span class="n">png_uint_32</span> <span class="n">height</span><span class="p">;</span>        <span class="cm">/* height of image in pixels */</span>
   <span class="n">png_uint_32</span> <span class="n">num_rows</span><span class="p">;</span>      <span class="cm">/* number of rows in current pass */</span>
   <span class="n">png_uint_32</span> <span class="n">usr_width</span><span class="p">;</span>     <span class="cm">/* width of row at start of write */</span>
   <span class="kt">size_t</span> <span class="n">rowbytes</span><span class="p">;</span>           <span class="cm">/* size of row in bytes */</span>
   <span class="n">png_uint_32</span> <span class="n">iwidth</span><span class="p">;</span>        <span class="cm">/* width of current interlaced row in pixels */</span>
   <span class="n">png_uint_32</span> <span class="n">row_number</span><span class="p">;</span>    <span class="cm">/* current row in interlace pass */</span>
   <span class="n">png_uint_32</span> <span class="n">chunk_name</span><span class="p">;</span>    <span class="cm">/* PNG_CHUNK() id of current chunk */</span>
   <span class="n">png_bytep</span> <span class="n">prev_row</span><span class="p">;</span>        <span class="cm">/* buffer to save previous (unfiltered) row.
                               * While reading this is a pointer into
                               * big_prev_row; while writing it is separately
                               * allocated if needed.
                               */</span>
   <span class="n">png_bytep</span> <span class="n">row_buf</span><span class="p">;</span>         <span class="cm">/* buffer to save current (unfiltered) row.
                               * While reading, this is a pointer into
                               * big_row_buf; while writing it is separately
                               * allocated.
                               */</span>
<span class="cp">#ifdef PNG_WRITE_FILTER_SUPPORTED
</span>   <span class="n">png_bytep</span> <span class="n">try_row</span><span class="p">;</span>    <span class="cm">/* buffer to save trial row when filtering */</span>
   <span class="n">png_bytep</span> <span class="n">tst_row</span><span class="p">;</span>    <span class="cm">/* buffer to save best trial row when filtering */</span>
<span class="cp">#endif
</span>   <span class="kt">size_t</span> <span class="n">info_rowbytes</span><span class="p">;</span>      <span class="cm">/* Added in 1.5.4: cache of updated row bytes */</span>

   <span class="n">png_uint_32</span> <span class="n">idat_size</span><span class="p">;</span>     <span class="cm">/* current IDAT size for read */</span>
   <span class="n">png_uint_32</span> <span class="n">crc</span><span class="p">;</span>           <span class="cm">/* current chunk CRC value */</span>
   <span class="n">png_colorp</span> <span class="n">palette</span><span class="p">;</span>        <span class="cm">/* palette from the input file */</span>
   <span class="n">png_uint_16</span> <span class="n">num_palette</span><span class="p">;</span>   <span class="cm">/* number of color entries in palette */</span>

<span class="cm">/* Added at libpng-1.5.10 */</span>
<span class="cp">#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
</span>   <span class="kt">int</span> <span class="n">num_palette_max</span><span class="p">;</span>       <span class="cm">/* maximum palette index found in IDAT */</span>
<span class="cp">#endif
</span>
   <span class="n">png_uint_16</span> <span class="n">num_trans</span><span class="p">;</span>     <span class="cm">/* number of transparency values */</span>
   <span class="n">png_byte</span> <span class="n">compression</span><span class="p">;</span>      <span class="cm">/* file compression type (always 0) */</span>
   <span class="n">png_byte</span> <span class="n">filter</span><span class="p">;</span>           <span class="cm">/* file filter type (always 0) */</span>
   <span class="n">png_byte</span> <span class="n">interlaced</span><span class="p">;</span>       <span class="cm">/* PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */</span>
   <span class="n">png_byte</span> <span class="n">pass</span><span class="p">;</span>             <span class="cm">/* current interlace pass (0 - 6) */</span>
   <span class="n">png_byte</span> <span class="n">do_filter</span><span class="p">;</span>        <span class="cm">/* row filter flags (see PNG_FILTER_ in png.h ) */</span>
   <span class="n">png_byte</span> <span class="n">color_type</span><span class="p">;</span>       <span class="cm">/* color type of file */</span>
   <span class="n">png_byte</span> <span class="n">bit_depth</span><span class="p">;</span>        <span class="cm">/* bit depth of file */</span>
   <span class="n">png_byte</span> <span class="n">usr_bit_depth</span><span class="p">;</span>    <span class="cm">/* bit depth of users row: write only */</span>
   <span class="n">png_byte</span> <span class="n">pixel_depth</span><span class="p">;</span>      <span class="cm">/* number of bits per pixel */</span>
   <span class="n">png_byte</span> <span class="n">channels</span><span class="p">;</span>         <span class="cm">/* number of channels in file */</span>
<span class="cp">#ifdef PNG_WRITE_SUPPORTED
</span>   <span class="n">png_byte</span> <span class="n">usr_channels</span><span class="p">;</span>     <span class="cm">/* channels at start of write: write only */</span>
<span class="cp">#endif
</span>   <span class="n">png_byte</span> <span class="n">sig_bytes</span><span class="p">;</span>        <span class="cm">/* magic bytes read/written from start of file */</span>
   <span class="n">png_byte</span> <span class="n">maximum_pixel_depth</span><span class="p">;</span>
                              <span class="cm">/* pixel depth used for the row buffers */</span>
   <span class="n">png_byte</span> <span class="n">transformed_pixel_depth</span><span class="p">;</span>
                              <span class="cm">/* pixel depth after read/write transforms */</span>
<span class="cp">#if ZLIB_VERNUM &gt;= 0x1240
</span>   <span class="n">png_byte</span> <span class="n">zstream_start</span><span class="p">;</span>    <span class="cm">/* at start of an input zlib stream */</span>
<span class="cp">#endif </span><span class="cm">/* Zlib &gt;= 1.2.4 */</span><span class="cp">
#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
</span>   <span class="n">png_uint_16</span> <span class="n">filler</span><span class="p">;</span>           <span class="cm">/* filler bytes for pixel expansion */</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
</span>   <span class="n">png_byte</span> <span class="n">background_gamma_type</span><span class="p">;</span>
   <span class="n">png_fixed_point</span> <span class="n">background_gamma</span><span class="p">;</span>
   <span class="n">png_color_16</span> <span class="n">background</span><span class="p">;</span>   <span class="cm">/* background color in screen gamma space */</span>
<span class="cp">#ifdef PNG_READ_GAMMA_SUPPORTED
</span>   <span class="n">png_color_16</span> <span class="n">background_1</span><span class="p">;</span> <span class="cm">/* background normalized to gamma 1.0 */</span>
<span class="cp">#endif
#endif </span><span class="cm">/* bKGD */</span><span class="cp">
</span>
<span class="cp">#ifdef PNG_WRITE_FLUSH_SUPPORTED
</span>   <span class="n">png_flush_ptr</span> <span class="n">output_flush_fn</span><span class="p">;</span> <span class="cm">/* Function for flushing output */</span>
   <span class="n">png_uint_32</span> <span class="n">flush_dist</span><span class="p">;</span>    <span class="cm">/* how many rows apart to flush, 0 - no flush */</span>
   <span class="n">png_uint_32</span> <span class="n">flush_rows</span><span class="p">;</span>    <span class="cm">/* number of rows written since last flush */</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef PNG_READ_GAMMA_SUPPORTED
</span>   <span class="kt">int</span> <span class="n">gamma_shift</span><span class="p">;</span>      <span class="cm">/* number of "insignificant" bits in 16-bit gamma */</span>
   <span class="n">png_fixed_point</span> <span class="n">screen_gamma</span><span class="p">;</span> <span class="cm">/* screen gamma value (display_exponent) */</span>

   <span class="n">png_bytep</span> <span class="n">gamma_table</span><span class="p">;</span>     <span class="cm">/* gamma table for 8-bit depth files */</span>
   <span class="n">png_uint_16pp</span> <span class="n">gamma_16_table</span><span class="p">;</span> <span class="cm">/* gamma table for 16-bit depth files */</span>
<span class="cp">#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
</span>   <span class="n">png_bytep</span> <span class="n">gamma_from_1</span><span class="p">;</span>    <span class="cm">/* converts from 1.0 to screen */</span>
   <span class="n">png_bytep</span> <span class="n">gamma_to_1</span><span class="p">;</span>      <span class="cm">/* converts from file to 1.0 */</span>
   <span class="n">png_uint_16pp</span> <span class="n">gamma_16_from_1</span><span class="p">;</span> <span class="cm">/* converts from 1.0 to screen */</span>
   <span class="n">png_uint_16pp</span> <span class="n">gamma_16_to_1</span><span class="p">;</span> <span class="cm">/* converts from file to 1.0 */</span>
<span class="cp">#endif </span><span class="cm">/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */</span><span class="cp">
#endif
</span>
<span class="cp">#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_sBIT_SUPPORTED)
</span>   <span class="n">png_color_8</span> <span class="n">sig_bit</span><span class="p">;</span>       <span class="cm">/* significant bits in each available channel */</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
</span>   <span class="n">png_color_8</span> <span class="n">shift</span><span class="p">;</span>         <span class="cm">/* shift for significant bit transformation */</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) \
 || defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
</span>   <span class="n">png_bytep</span> <span class="n">trans_alpha</span><span class="p">;</span>           <span class="cm">/* alpha values for paletted files */</span>
   <span class="n">png_color_16</span> <span class="n">trans_color</span><span class="p">;</span>  <span class="cm">/* transparent color for non-paletted files */</span>
<span class="cp">#endif
</span>
   <span class="n">png_read_status_ptr</span> <span class="n">read_row_fn</span><span class="p">;</span>   <span class="cm">/* called after each row is decoded */</span>
   <span class="n">png_write_status_ptr</span> <span class="n">write_row_fn</span><span class="p">;</span> <span class="cm">/* called after each row is encoded */</span>
<span class="cp">#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
</span>   <span class="n">png_progressive_info_ptr</span> <span class="n">info_fn</span><span class="p">;</span> <span class="cm">/* called after header data fully read */</span>
   <span class="n">png_progressive_row_ptr</span> <span class="n">row_fn</span><span class="p">;</span>   <span class="cm">/* called after a prog. row is decoded */</span>
   <span class="n">png_progressive_end_ptr</span> <span class="n">end_fn</span><span class="p">;</span>   <span class="cm">/* called after image is complete */</span>
   <span class="n">png_bytep</span> <span class="n">save_buffer_ptr</span><span class="p">;</span>        <span class="cm">/* current location in save_buffer */</span>
   <span class="n">png_bytep</span> <span class="n">save_buffer</span><span class="p">;</span>            <span class="cm">/* buffer for previously read data */</span>
   <span class="n">png_bytep</span> <span class="n">current_buffer_ptr</span><span class="p">;</span>     <span class="cm">/* current location in current_buffer */</span>
   <span class="n">png_bytep</span> <span class="n">current_buffer</span><span class="p">;</span>         <span class="cm">/* buffer for recently used data */</span>
   <span class="n">png_uint_32</span> <span class="n">push_length</span><span class="p">;</span>          <span class="cm">/* size of current input chunk */</span>
   <span class="n">png_uint_32</span> <span class="n">skip_length</span><span class="p">;</span>          <span class="cm">/* bytes to skip in input data */</span>
   <span class="kt">size_t</span> <span class="n">save_buffer_size</span><span class="p">;</span>          <span class="cm">/* amount of data now in save_buffer */</span>
   <span class="kt">size_t</span> <span class="n">save_buffer_max</span><span class="p">;</span>           <span class="cm">/* total size of save_buffer */</span>
   <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">;</span>               <span class="cm">/* total amount of available input data */</span>
   <span class="kt">size_t</span> <span class="n">current_buffer_size</span><span class="p">;</span>       <span class="cm">/* amount of data now in current_buffer */</span>
   <span class="kt">int</span> <span class="n">process_mode</span><span class="p">;</span>                 <span class="cm">/* what push library is currently doing */</span>
   <span class="kt">int</span> <span class="n">cur_palette</span><span class="p">;</span>                  <span class="cm">/* current push library palette index */</span>

<span class="cp">#endif </span><span class="cm">/* PROGRESSIVE_READ */</span><span class="cp">
</span>
<span class="cp">#if defined(__TURBOC__) &amp;&amp; !defined(_Windows) &amp;&amp; !defined(__FLAT__)
</span><span class="cm">/* For the Borland special 64K segment handler */</span>
   <span class="n">png_bytepp</span> <span class="n">offset_table_ptr</span><span class="p">;</span>
   <span class="n">png_bytep</span> <span class="n">offset_table</span><span class="p">;</span>
   <span class="n">png_uint_16</span> <span class="n">offset_table_number</span><span class="p">;</span>
   <span class="n">png_uint_16</span> <span class="n">offset_table_count</span><span class="p">;</span>
   <span class="n">png_uint_16</span> <span class="n">offset_table_count_free</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef PNG_READ_QUANTIZE_SUPPORTED
</span>   <span class="n">png_bytep</span> <span class="n">palette_lookup</span><span class="p">;</span> <span class="cm">/* lookup table for quantizing */</span>
   <span class="n">png_bytep</span> <span class="n">quantize_index</span><span class="p">;</span> <span class="cm">/* index translation for palette files */</span>
<span class="cp">#endif
</span>
<span class="cm">/* Options */</span>
<span class="cp">#ifdef PNG_SET_OPTION_SUPPORTED
</span>   <span class="n">png_uint_32</span> <span class="n">options</span><span class="p">;</span>           <span class="cm">/* On/off state (up to 16 options) */</span>
<span class="cp">#endif
</span>
<span class="cp">#if PNG_LIBPNG_VER &lt; 10700
</span><span class="cm">/* To do: remove this from libpng-1.7 */</span>
<span class="cp">#ifdef PNG_TIME_RFC1123_SUPPORTED
</span>   <span class="kt">char</span> <span class="n">time_buffer</span><span class="p">[</span><span class="mi">29</span><span class="p">];</span> <span class="cm">/* String to hold RFC 1123 time text */</span>
<span class="cp">#endif
#endif
</span>
<span class="cm">/* New members added in libpng-1.0.6 */</span>

   <span class="n">png_uint_32</span> <span class="n">free_me</span><span class="p">;</span>    <span class="cm">/* flags items libpng is responsible for freeing */</span>

<span class="cp">#ifdef PNG_USER_CHUNKS_SUPPORTED
</span>   <span class="n">png_voidp</span> <span class="n">user_chunk_ptr</span><span class="p">;</span>
<span class="cp">#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
</span>   <span class="n">png_user_chunk_ptr</span> <span class="n">read_user_chunk_fn</span><span class="p">;</span> <span class="cm">/* user read chunk handler */</span>
<span class="cp">#endif
#endif
</span>
<span class="cp">#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
</span>   <span class="kt">int</span>          <span class="n">unknown_default</span><span class="p">;</span> <span class="cm">/* As PNG_HANDLE_* */</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_chunk_list</span><span class="p">;</span>  <span class="cm">/* Number of entries in the list */</span>
   <span class="n">png_bytep</span>    <span class="n">chunk_list</span><span class="p">;</span>      <span class="cm">/* List of png_byte[5]; the textual chunk name
                                  * followed by a PNG_HANDLE_* byte */</span>
<span class="cp">#endif
</span>
<span class="cm">/* New members added in libpng-1.0.3 */</span>
<span class="cp">#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
</span>   <span class="n">png_byte</span> <span class="n">rgb_to_gray_status</span><span class="p">;</span>
   <span class="cm">/* Added in libpng 1.5.5 to record setting of coefficients: */</span>
   <span class="n">png_byte</span> <span class="n">rgb_to_gray_coefficients_set</span><span class="p">;</span>
   <span class="cm">/* These were changed from png_byte in libpng-1.0.6 */</span>
   <span class="n">png_uint_16</span> <span class="n">rgb_to_gray_red_coeff</span><span class="p">;</span>
   <span class="n">png_uint_16</span> <span class="n">rgb_to_gray_green_coeff</span><span class="p">;</span>
   <span class="cm">/* deleted in 1.5.5: rgb_to_gray_blue_coeff; */</span>
<span class="cp">#endif
</span>
<span class="cm">/* New member added in libpng-1.6.36 */</span>
<span class="cp">#if defined(PNG_READ_EXPAND_SUPPORTED) &amp;&amp; \
    defined(PNG_ARM_NEON_IMPLEMENTATION)
</span>   <span class="n">png_bytep</span> <span class="n">riffled_palette</span><span class="p">;</span> <span class="cm">/* buffer for accelerated palette expansion */</span>
<span class="cp">#endif
</span>
<span class="cm">/* New member added in libpng-1.0.4 (renamed in 1.0.9) */</span>
<span class="cp">#if defined(PNG_MNG_FEATURES_SUPPORTED)
</span><span class="cm">/* Changed from png_byte to png_uint_32 at version 1.2.0 */</span>
   <span class="n">png_uint_32</span> <span class="n">mng_features_permitted</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cm">/* New member added in libpng-1.0.9, ifdef'ed out in 1.0.12, enabled in 1.2.0 */</span>
<span class="cp">#ifdef PNG_MNG_FEATURES_SUPPORTED
</span>   <span class="n">png_byte</span> <span class="n">filter_type</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cm">/* New members added in libpng-1.2.0 */</span>

<span class="cm">/* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */</span>
<span class="cp">#ifdef PNG_USER_MEM_SUPPORTED
</span>   <span class="n">png_voidp</span> <span class="n">mem_ptr</span><span class="p">;</span>             <span class="cm">/* user supplied struct for mem functions */</span>
   <span class="n">png_malloc_ptr</span> <span class="n">malloc_fn</span><span class="p">;</span>      <span class="cm">/* function for allocating memory */</span>
   <span class="n">png_free_ptr</span> <span class="n">free_fn</span><span class="p">;</span>          <span class="cm">/* function for freeing memory */</span>
<span class="cp">#endif
</span>
<span class="cm">/* New member added in libpng-1.0.13 and 1.2.0 */</span>
   <span class="n">png_bytep</span> <span class="n">big_row_buf</span><span class="p">;</span>         <span class="cm">/* buffer to save current (unfiltered) row */</span>

<span class="cp">#ifdef PNG_READ_QUANTIZE_SUPPORTED
</span><span class="cm">/* The following three members were added at version 1.0.14 and 1.2.4 */</span>
   <span class="n">png_bytep</span> <span class="n">quantize_sort</span><span class="p">;</span>          <span class="cm">/* working sort array */</span>
   <span class="n">png_bytep</span> <span class="n">index_to_palette</span><span class="p">;</span>       <span class="cm">/* where the original index currently is
                                        in the palette */</span>
   <span class="n">png_bytep</span> <span class="n">palette_to_index</span><span class="p">;</span>       <span class="cm">/* which original index points to this
                                         palette color */</span>
<span class="cp">#endif
</span>
<span class="cm">/* New members added in libpng-1.0.16 and 1.2.6 */</span>
   <span class="n">png_byte</span> <span class="n">compression_type</span><span class="p">;</span>

<span class="cp">#ifdef PNG_USER_LIMITS_SUPPORTED
</span>   <span class="n">png_uint_32</span> <span class="n">user_width_max</span><span class="p">;</span>
   <span class="n">png_uint_32</span> <span class="n">user_height_max</span><span class="p">;</span>

   <span class="cm">/* Added in libpng-1.4.0: Total number of sPLT, text, and unknown
    * chunks that can be stored (0 means unlimited).
    */</span>
   <span class="n">png_uint_32</span> <span class="n">user_chunk_cache_max</span><span class="p">;</span>

   <span class="cm">/* Total memory that a zTXt, sPLT, iTXt, iCCP, or unknown chunk
    * can occupy when decompressed.  0 means unlimited.
    */</span>
   <span class="n">png_alloc_size_t</span> <span class="n">user_chunk_malloc_max</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cm">/* New member added in libpng-1.0.25 and 1.2.17 */</span>
<span class="cp">#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
</span>   <span class="cm">/* Temporary storage for unknown chunk that the library doesn't recognize,
    * used while reading the chunk.
    */</span>
   <span class="n">png_unknown_chunk</span> <span class="n">unknown_chunk</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cm">/* New member added in libpng-1.2.26 */</span>
   <span class="kt">size_t</span> <span class="n">old_big_row_buf_size</span><span class="p">;</span>

<span class="cp">#ifdef PNG_READ_SUPPORTED
</span><span class="cm">/* New member added in libpng-1.2.30 */</span>
  <span class="n">png_bytep</span>        <span class="n">read_buffer</span><span class="p">;</span>      <span class="cm">/* buffer for reading chunk data */</span>
  <span class="n">png_alloc_size_t</span> <span class="n">read_buffer_size</span><span class="p">;</span> <span class="cm">/* current size of the buffer */</span>
<span class="cp">#endif
#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
</span>  <span class="n">uInt</span>             <span class="n">IDAT_read_size</span><span class="p">;</span>   <span class="cm">/* limit on read buffer size for IDAT */</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef PNG_IO_STATE_SUPPORTED
</span><span class="cm">/* New member added in libpng-1.4.0 */</span>
   <span class="n">png_uint_32</span> <span class="n">io_state</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cm">/* New member added in libpng-1.5.6 */</span>
   <span class="n">png_bytep</span> <span class="n">big_prev_row</span><span class="p">;</span>

<span class="cm">/* New member added in libpng-1.5.7 */</span>
   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_filter</span><span class="p">[</span><span class="n">PNG_FILTER_VALUE_LAST</span><span class="o">-</span><span class="mi">1</span><span class="p">])(</span><span class="n">png_row_infop</span> <span class="n">row_info</span><span class="p">,</span>
      <span class="n">png_bytep</span> <span class="n">row</span><span class="p">,</span> <span class="n">png_const_bytep</span> <span class="n">prev_row</span><span class="p">);</span>

<span class="cp">#ifdef PNG_READ_SUPPORTED
#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)
</span>   <span class="n">png_colorspace</span>   <span class="n">colorspace</span><span class="p">;</span>
<span class="cp">#endif
#endif
</span><span class="p">};</span>

<span class="cm">/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
 *
 * png_struct is the cache of information used while reading or writing a single
 * PNG file.  One of these is always required, although the simplified API
 * (below) hides the creation and destruction of it.
 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">png_struct_def</span> <span class="n">png_struct</span><span class="p">;</span>

<span class="cp">#    ifndef PNG_RESTRICT
#      define PNG_RESTRICT __restrict
#    endif
</span>
<span class="cm">/* Types with names ending 'p' are pointer types.  The corresponding types with
 * names ending 'rp' are identical pointer types except that the pointer is
 * marked 'restrict', which means that it is the only pointer to the object
 * passed to the function.  Applications should not use the 'restrict' types;
 * it is always valid to pass 'p' to a pointer with a function argument of the
 * corresponding 'rp' type.  Different compilers have different rules with
 * regard to type matching in the presence of 'restrict'.  For backward
 * compatibility libpng callbacks never have 'restrict' in their parameters and,
 * consequentially, writing portable application code is extremely difficult if
 * an attempt is made to use 'restrict'.
 */</span>
<span class="k">typedef</span> <span class="n">png_struct</span> <span class="o">*</span> <span class="n">PNG_RESTRICT</span> <span class="n">png_structrp</span><span class="p">;</span>


<span class="cm">/* Read the entire image.  If the image has an alpha channel or a tRNS
 * chunk, and you have called png_handle_alpha()[*], you will need to
 * initialize the image to the current image that PNG will be overlaying.
 * We set the num_rows again here, in case it was incorrectly set in
 * png_read_start_row() by a call to png_read_update_info() or
 * png_start_read_image() if png_set_interlace_handling() wasn't called
 * prior to either of these functions like it should have been.  You can
 * only call this function once.  If you desire to have an image for
 * each pass of a interlaced image, use png_read_rows() instead.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng
 */</span>
<span class="kt">void</span> <span class="n">PNGAPI</span>
<span class="nf">png_read_image</span><span class="p">(</span><span class="n">png_structrp</span> <span class="n">png_ptr</span><span class="p">,</span> <span class="n">png_bytepp</span> <span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">png_uint_32</span> <span class="n">i</span><span class="p">,</span> <span class="n">image_height</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">pass</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
   <span class="n">png_bytepp</span> <span class="n">rp</span><span class="p">;</span>

   <span class="n">png_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"in png_read_image"</span><span class="p">);</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">png_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef PNG_READ_INTERLACING_SUPPORTED
</span>   <span class="k">if</span> <span class="p">((</span><span class="n">png_ptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PNG_FLAG_ROW_INIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">pass</span> <span class="o">=</span> <span class="n">png_set_interlace_handling</span><span class="p">(</span><span class="n">png_ptr</span><span class="p">);</span>
      <span class="cm">/* And make sure transforms are initialized. */</span>
      <span class="n">png_start_read_image</span><span class="p">(</span><span class="n">png_ptr</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">else</span>
   <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">png_ptr</span><span class="o">-&gt;</span><span class="n">interlaced</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
          <span class="p">(</span><span class="n">png_ptr</span><span class="o">-&gt;</span><span class="n">transformations</span> <span class="o">&amp;</span> <span class="n">PNG_INTERLACE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="cm">/* Caller called png_start_read_image or png_read_update_info without
          * first turning on the PNG_INTERLACE transform.  We can fix this here,
          * but the caller should do it!
          */</span>
         <span class="n">png_warning</span><span class="p">(</span><span class="n">png_ptr</span><span class="p">,</span> <span class="s">"Interlace handling should be turned on when "</span>
             <span class="s">"using png_read_image"</span><span class="p">);</span>
         <span class="cm">/* Make sure this is set correctly */</span>
         <span class="n">png_ptr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">png_ptr</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/* Obtain the pass number, which also turns on the PNG_INTERLACE flag in
       * the above error case.
       */</span>
      <span class="n">pass</span> <span class="o">=</span> <span class="n">png_set_interlace_handling</span><span class="p">(</span><span class="n">png_ptr</span><span class="p">);</span>
   <span class="p">}</span>
<span class="cp">#else
</span>   <span class="k">if</span> <span class="p">(</span><span class="n">png_ptr</span><span class="o">-&gt;</span><span class="n">interlaced</span><span class="p">)</span>
      <span class="n">png_error</span><span class="p">(</span><span class="n">png_ptr</span><span class="p">,</span>
          <span class="s">"Cannot read interlaced image -- interlace handler disabled"</span><span class="p">);</span>

   <span class="n">pass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif
</span>
   <span class="n">image_height</span><span class="o">=</span><span class="n">png_ptr</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pass</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">rp</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">image_height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="n">png_read_row</span><span class="p">(</span><span class="n">png_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
         <span class="n">rp</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The key of this vulnerability, according to what we explain above resides on the following block:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//...</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">error</span>                                    <span class="o">||</span>
        <span class="p">(</span> <span class="o">!</span><span class="n">populate_map_and_metrics</span>              <span class="o">&amp;&amp;</span>
        <span class="p">(</span> <span class="p">(</span><span class="n">FT_Int</span><span class="p">)</span><span class="n">imgWidth</span>  <span class="o">!=</span> <span class="n">metrics</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">||</span>
        <span class="p">(</span><span class="n">FT_Int</span><span class="p">)</span><span class="n">imgHeight</span> <span class="o">!=</span> <span class="n">metrics</span><span class="o">-&gt;</span><span class="n">height</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
<span class="k">goto</span> <span class="n">DestroyExit</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">populate_map_and_metrics</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">metrics</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">=</span> <span class="p">(</span><span class="n">FT_UShort</span><span class="p">)</span><span class="n">imgWidth</span><span class="p">;</span>
<span class="n">metrics</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">FT_UShort</span><span class="p">)</span><span class="n">imgHeight</span><span class="p">;</span>
<span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The width and the height of the PNG which is used to allocate space gets truncated since gets both converted from <em>int</em> to <em>short</em> without correct validation. As we seen before, this could lead to an under-allocation and later to an over-copy.</p>

<p><br /></p>

<h4 id="53-cve-2020-17087">5.3. CVE-2020-17087.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////ACID:SourceBuffer, SourceLength</span>
<span class="n">NTSTATUS</span> <span class="nf">CfgAdtpFormatPropertyBlock</span><span class="p">(</span><span class="n">PBYTE</span> <span class="n">SourceBuffer</span><span class="p">,</span> <span class="n">USHORT</span> <span class="n">SourceLength</span><span class="p">,</span> <span class="n">PUNICODE_STRING</span> <span class="n">Destination</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CONST</span> <span class="n">USHORT</span> <span class="n">DestinationSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">USHORT</span><span class="p">)(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">SourceLength</span><span class="p">);</span>
	<span class="n">PWCHAR</span> <span class="n">OutputBuffer</span> <span class="o">=</span> <span class="n">BCryptAlloc</span><span class="p">(</span><span class="n">DestinationSize</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">USHORT</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SourceLength</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">OutputBuffer</span><span class="o">++</span> <span class="o">=</span> <span class="s">"0123456789abcdef"</span><span class="p">[</span><span class="o">*</span><span class="n">SourceBuffer</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">];</span>
		<span class="o">*</span><span class="n">OutputBuffer</span><span class="o">++</span> <span class="o">=</span> <span class="s">"0123456789abcdef"</span><span class="p">[</span><span class="o">*</span><span class="n">SourceBuffer</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">];</span>
		<span class="o">*</span><span class="n">OutputBuffer</span><span class="o">++</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>
		<span class="n">SourceBuffer</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

 	<span class="n">Destination</span><span class="o">-&gt;</span><span class="n">MaximumLength</span> <span class="o">=</span> <span class="n">DestinationSize</span><span class="p">;</span>
 	<span class="n">Destination</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">=</span> <span class="n">DestinationSize</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
 	<span class="n">Destination</span><span class="o">-&gt;</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">OutputBuffer</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This chunk of code is vulnerable to an overcopy due to underallocation result of integer overflow, OutputBuffer gets assignation in a for-loop when the break condition is i&lt; Source Length. But the allocated space for this Buffer is DestinationSize which is 6 times SourceLength, this could provoke (assuming BCryptAlloc does not prevent it) that if SourceLength is (MAX_SHORT_SIZE + 1) / 6, then an underallocation is performed and out-of-bounds write is done.</p>

<p><br /></p>

<h4 id="54-cve-2021-33909-sequoia">5.4. CVE-2021-33909. Sequoia.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////NOTE: Start reading the code at seq_read_iter()</span>

<span class="cm">/**
 * seq_has_overflowed - check if the buffer has overflowed
 * @m: the seq_file handle
 *
 * seq_files have a buffer which may overflow. When this happens a larger
 * buffer is reallocated and all the data will be printed again.
 * The overflow state is true when m-&gt;count == m-&gt;size.
 *
 * Returns true if the buffer received more than it can hold.
 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">seq_has_overflowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//------------------------------------------------------------------------</span>
<span class="mi">135</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">show_mountinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span> <span class="c1">//KC: called by "m-&gt;op-&gt;show(m, p)" </span>
<span class="mi">136</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">150</span>                 <span class="n">seq_dentry</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">,</span> <span class="s">" </span><span class="se">\t\n\\</span><span class="s">"</span><span class="p">);</span>
<span class="c1">//------------------------------------------------------------------------</span>
<span class="mi">523</span> <span class="kt">int</span> <span class="n">seq_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">esc</span><span class="p">)</span>
<span class="mi">524</span> <span class="p">{</span>
<span class="mi">525</span>         <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="mi">526</span>         <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">seq_get_buf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">529</span>         <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">530</span>                 <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dentry_path</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="c1">//------------------------------------------------------------------------</span>
<span class="mi">380</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dentry_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="mi">381</span> <span class="p">{</span>
<span class="mi">382</span>         <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">385</span>         <span class="k">if</span> <span class="p">(</span><span class="n">d_unlinked</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//KC: assume true</span>
<span class="mi">386</span>                 <span class="n">p</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
<span class="mi">387</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">prepend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">,</span> <span class="s">"//deleted"</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">//------------------------------------------------------------------------</span>
 <span class="mi">11</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">prepend</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buflen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">)</span>
 <span class="mi">12</span> <span class="p">{</span>
 <span class="mi">13</span>         <span class="o">*</span><span class="n">buflen</span> <span class="o">-=</span> <span class="n">namelen</span><span class="p">;</span>
 <span class="mi">14</span>         <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buflen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
 <span class="mi">15</span>                 <span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
 <span class="mi">16</span>         <span class="o">*</span><span class="n">buffer</span> <span class="o">-=</span> <span class="n">namelen</span><span class="p">;</span>
 <span class="mi">17</span>         <span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
<span class="c1">//------------------------------------------------------------------------</span>

<span class="c1">////ACID: Assume the attacker can control the underlying seq_file to cause the while(1) loop to occur as many times as they want</span>
<span class="mi">168</span> <span class="kt">ssize_t</span> <span class="n">seq_read_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="mi">169</span> <span class="p">{</span>
<span class="mi">170</span>         <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">205</span>         <span class="cm">/* grab buffer if we didn't have one */</span>
<span class="mi">206</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//KC: assume this is NULL on the first iteration</span>
<span class="mi">207</span>                 <span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">seq_buf_alloc</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span> <span class="c1">//KC: m-&gt;size is a size_t</span>
<span class="p">...</span>
<span class="mi">210</span>         <span class="p">}</span>
<span class="p">...</span>
<span class="mi">220</span>         <span class="c1">// get a non-empty record in the buffer</span>
<span class="p">...</span>
<span class="mi">223</span>         <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">227</span>                 <span class="n">err</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="c1">//KC: This calls to show_mountinfo()</span>
<span class="p">...</span>
<span class="mi">236</span>                 <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq_has_overflowed</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="c1">// got it</span>
<span class="mi">237</span>                         <span class="k">goto</span> <span class="n">Fill</span><span class="p">;</span>
<span class="mi">238</span>                 <span class="c1">// need a bigger buffer</span>
<span class="p">...</span>
<span class="mi">240</span>                 <span class="n">kvfree</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">242</span>                 <span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">seq_buf_alloc</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">246</span>         <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>German Sanmi</name></author><category term="Past Blogs" /><category term="Binary Exploitation" /><category term="memory-corruption" /><category term="exploits" /><summary type="html"><![CDATA[1. Definition. This section is an extension about Integers Overflow issues. We are going to cover three topics: Incorrect Signed Sanity Checks. Signed or unsigned integer truncation. Signed Integer extension issues. 2. Incorrect Signed Sanity Checks. 2.1. Definition. Incorrect Signed Sanity Checks refers to the idea of bad sanity checks implementation due to the unprevention of negative values being allowed and later cast into the execution flow as unsigned values effectively bypassing the sanitization measure. To be a bit more precise the issue arises when a signed integer is checked against an upper bound (len &lt; MAX_SIZE) but the check fails to account for negative values. When that signed integer is later used in a context that interprets it as unsigned (like memcpy(dst, src, len) where the len parameter is size_t), 2.2. Examples. 2.2.1 Trivial Example. Let's consider the following C code. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void main(int argc, char *argv[]){ char buf[100]; int size = strtoul(argv[1], NULL, 16); if(size &gt; 100){ printf("Nice try *ATTACKER*! But I'm too clever for you!!!\n"); return; } memcpy(buf, argv[2], size); printf("We got an input string: %s\n", buf); } First, we declare an array of maximum 100 bytes width and then we capture the cli first argument from the user interpreted as a hexadecimal value to size /(a signed integer). Then, in order to prevent a Linear Stack Buffer Overflow a comparative check is performed over size: if(size &gt; 100){ printf("Nice try *ATTACKER*! But I'm too clever for you!!!\n"); return; } If size was an unsigned integer, this check would work just fine since every value bigger than 100 would be succesfully blocked and then pass as the third argument (length) to memcpy() function. However, there is a subtle problem. On the signature of a function, there are defined parameter to pass to that function as datatypes. This means that, whenever you pass a value to a function, this values gets cast to the funtion's demanded datatype, for example, if we look over the memcpy() function definition: void * memcpy(void * destination, const void * source, size_t num); We can see that the third argument gets cast to a size_t datatype, which means that if a signed value lands as the length argument of memcpy() it will be interpreted as an unsigned integer. This link with the fact that size is a signed integer, so, lets consider that the user pass a negative value, for example, "0xFFFFFFFFFFFFFF9B" (-101), then the comparation -101 &gt; 100 is false, so the flow of execution goes towards memcpy, but when passed to memcpy "0xFFFFFFFFFFFFFF9B" is interpreted as an unsigned integer: "4,294,967,195", provoking an overcopy in the memcpy() function. It is said that signed sanity checks 50% of the times works 100% of the time. 2.2.2. Bad Sanity Check 1. Another example of signed sanity checks can be the following: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; typedef struct my_header{ unsigned int magic; int size; } my_header_t; // Under-allocate, over-copy, bad sanity check void main(int argc, char * argv[]){ my_header_t header; unsigned int alloc_size; header.magic = 0x6f6e6558; header.size = strtoul(argv[1], NULL, 16); if(header.size &gt; 0x1000){ printf("Nice try *ATTACKER*! But I'm too clever for you!!!\n"); return; } alloc_size = header.size + sizeof(my_header_t); printf("String self-reported size = 0x%08X\n", header.size); printf("Allocation size = 0x%08X\n", alloc_size); char * buf = malloc(alloc_size); if(buf == NULL) return; printf("buf points to %p\n", buf); memcpy(buf, &amp;header, sizeof(my_header_t)); buf += sizeof(my_header_t); printf("memcpy()ing 0x%08X bytes into buf of size 0x%08X\n", header.size, alloc_size); memcpy(buf, argv[2], header.size); printf("We copied input string: %s\n", buf); } Again, cli argument from user gets passed to header.size (signed integer) and is used to first, alloc memory through an unsigned integer to a destination buffer which later is gonna be used in a memcpy() operation with user-controlled length: //... header.size = strtoul(argv[1], NULL, 16); //... char * buf = malloc(alloc_size); memcpy(buf, &amp;header, sizeof(my_header_t)); buf += sizeof(my_header_t); printf("memcpy()ing 0x%08X bytes into buf of size 0x%08X\n", header.size, alloc_size); memcpy(buf, argv[2], header.size); //... Here the thing is kind of more convulate than the previous example, but vulnerable in anyway. A protection mechanism as an if statement to prevent header.size be bigger than certain value is implemented: if(header.size &gt; 0x1000){ printf("Nice try *ATTACKER*! But I'm too clever for you!!!\n"); return; } the issue is that again, header.size is signed datatype and this comparison does not protect against big absolute negative numbers being pass in to the execution flow. Thus, if header.size was a value that satisfies: header.size + sizeof(my_header_t) = 1 First, a one-byte allocation would be performed and buf pointer would point to that chunk, then , lets note that header.size has to be big absolute negative value by force since sizeof(my_header_t) = 8 and would be pass as a size_t datatype (unsigned) to memcpy(), meaning that from a negative near-cero value, as an unsigned, it would become a big absolute value provoking an overflow. 2.2.3. Bad Sanity Check 2. Let's consider the following C code: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; typedef struct my_header{ unsigned int magic; int size; } my_header_t; // Under-allocate, over-copy, bad sanity check void main(int argc, char * argv[]){ my_header_t header; unsigned int alloc_size; header.magic = 0x6f6e6558; header.size = strtoul(argv[1], NULL, 16); if(header.size + sizeof(my_header_t) &gt;= 0x100000000){ printf("Nice try *ATTACKER*! But I'm too clever for you!!!\n"); return; } alloc_size = header.size + sizeof(my_header_t); printf("String self-reported size = 0x%08X\n", header.size); printf("Allocation size = 0x%08X\n", alloc_size); char * buf = malloc(alloc_size); if(buf == NULL) return; printf("buf points to %p\n", buf); memcpy(buf, &amp;header, sizeof(my_header_t)); buf += sizeof(my_header_t); printf("memcpy()ing 0x%08X bytes into buf of size 0x%08X\n", header.size, alloc_size); memcpy(buf, argv[2], header.size); printf("We copied input string: %s\n", buf); } This code is kind of similar to the one before, but instead of implement a one-value comparison, is establishing a comparison of an addition of two different-sign dataypes. Here, enters what in C is known as implicit conversions, an arithemtic operation of two values of the same datatypes and different signs results in the signed value to get automatically converted to the unsigned type before the arithmetic opeation resolution. This means that, header.size bits-pattern value is interpreted as unsigned, thus a near-to-cero negative value can be interpreted as big postiive number which in addition with sizeof(my_header_t) could trigger an integer overflow and become a small positive value bypassing the size constraint. Then, this addition is again performed and assignated to alloc_size (unsigned integer) resulting in an under-allocation: alloc_size = header.size + sizeof(my_header_t); printf("String self-reported size = 0x%08X\n", header.size); printf("Allocation size = 0x%08X\n", alloc_size); char * buf = malloc(alloc_size); And later, a memcpy operation over this small memory region is performed passing header.size as length again as size_t (unsigned), thus triggering an over-copy. memcpy(buf, argv[2], header.size); 3. Integer Truncation. As we disscussed in Integer Overflow paper, every C value has associated a datatype which has a size and sometimes a sign (if is an integer subtype). Essentially, a value is a bit pattern stored in memory that acquires full definition when gets interpreted by the CPU following the instructions generated by the compiler. Integer Truncation is a phenomenon in which the bit-pattern of an integer gets chopped off when the value gets converted from a wider datatype to a narrower one transforming the data in a defined way. When this size-datatype downgrade gets defined, the compiler generates an instruction to copy part of the bit-string of the value to another location, then when executed, the instruction makes the CPU strip off the bitchain lefting the lowerbits and operating with them as a new different value in the next instructions. For example, consider the following conversion: ​c uint32_t wide = 0x0001FFFF; // 131071 in decimal uint16_t narrow = wide; // narrow = 0xFFFF (65535) ​ The 32-bit value '0x0001FFFF' has the following bit pattern: ​less 0000 0000 0000 0001 1111 1111 1111 1111 |______upper 16____||____lower 16_____| discarded retained ​ When the C code gets compiled, the compiler would generate an instruction like the following: mov eax, dword ptr [rbp - 8h] ; In which original value exists mov word ptr [rbp - 10h], ax ; Copying to a new location only the 16 retained bits The original value was 131071, but after truncation it becomes 65535 — a completely different value, which can lead to serious vulnerabilities if the program logic assumes the full original value is preserved. 3.1. Trivial Example. Let's consider the following C code: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; typedef struct my_header{ unsigned int magic; unsigned int size; } my_header_t; // Under-allocate (via truncation), over-copy void main(int argc, char * argv[]){ my_header_t header; unsigned short alloc_size; header.magic = 0x6f6e6558; header.size = strtoul(argv[1], NULL, 16); alloc_size = header.size + sizeof(my_header_t); printf("String self-reported size = 0x%08X\n", header.size); printf("Allocation size = 0x%08X\n", alloc_size); char * buf = malloc(alloc_size); if(buf == NULL) return; printf("buf points to %p\n", buf); memcpy(buf, &amp;header, sizeof(my_header_t)); buf += sizeof(my_header_t); printf("memcpy()ing 0x%08X bytes into buf of size 0x%08X\n", header.size, alloc_size); memcpy(buf, argv[2], header.size); printf("We copied input string: %s\n", buf); } This code is similar to the used in other examples but with the subtle differences that in this case, alloc_size is a short, not a int. Thus, for example, consider that the user pass as the first cli parameter to the program (argv[1]), which is an int and occupies 4 bytes, have the value 0xFFFF0000 (two hex-digits per byte, 4 pairs of digits), then, this value would end up in header.size and later would be used in an arithmetic operation: header.size = strtoul(argv[1], NULL, 16); alloc_size = header.size + sizeof(my_header_t); Note that, at a first glance, 0xFFFF0000 + 0x00000008 = 0xFFFF0008 and nothing wrong happens regards to the integer overflow subject we studied before. However this int-wide value is now assigned to an narrower datatype (unsigned short), when performing the assignation, the compiler truncates the value to a short, keeping the two rightmost bytes effectively wrapping it to 0x0008 which is then saved in alloc_size. As a result, an under-allocation is performed and later, the complete int-wide value (header.size) is used to perfom an memcpy() operation, triggering an over-copy: char * buf = malloc(alloc_size); //... memcpy(buf, argv[2], header.size); 4. Signed-Arithmetics. 4.1. Pointer arithmetics with signed integers. Consider the following code: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; //Pointer arithmetic + sign extension - pase.c int main(){ char buf[8]; char * ptr1, * ptr2; short size1 = 0x8000; int size2 = 0x80000000; ptr1 = buf + size1; ptr2 = buf + size2; printf("buf = %p\n", buf); printf("ptr1 = %p\n", ptr1); printf("ptr2 = %p\n", ptr2); return 0; } Pointer arithmetics are being performed with signed integers which result to be negative values, the MAX_SIZE for an integer hexadecimal value always is 0x7FF…, both values are one bit over the maximum positive value and thus are small negative numbers, thus the arithmetic operation with pointer is not an addition, but a substraction, the pointer now points above the buffer an, for example, use it in a data-copy operation would result in an out-of-bounds. As a result, any operation performed with a signed datatype can lead to a misscalculation resulting in a potential security issue and must be reviewed carefully. 4.2. Signed Extension. Another example on how signed-datatype poorly handled can generate issue is through the sign extension mechanismo. In which a signed datatypes gets converted to a bigger size datatype preserving the sign: signed char offset = -1; // Malicious input: -1 size_t array_index = offset; // Sign extended to large positive. // On 64-bit: array_index = 0xFFFFFFFFFFFFFFFF (huge number!) If later this sign extension is used as an unsigned integer troubles can arise: char buffer[100]; buffer[array_index] = 'X'; // Out-of-bounds access! 5. Exercises. 5.1. CVE-2019-15948. Consider the following code: ////ACID: where ptr_ll_pkt points after assignment // Pseudocode from Ghidra decompilation void process_adv_ind_pdu(int ptr_some_struct) { byte bVar1; byte ll_len; uint n; uint uVar2; byte *ptr_ll_pkt; undefined local_40; byte local_3f; undefined auStack62 [0x6]; undefined local_38; undefined stack_buffer [0x1f]; undefined local_18; ptr_ll_pkt = (byte *)(DAT_0005b528 + (uint)*(ushort *)(ptr_some_struct + 0x8)); bVar1 = *ptr_ll_pkt; ll_len = ptr_ll_pkt[0x1]; uVar2 = (uint)bVar1 &amp; 0xf; local_3f = (byte)(((uint)bVar1 &lt;&lt; 0x19) &gt;&gt; 0x1f); FUN_00067554(auStack62,ptr_ll_pkt + 0x2,0x6); n = ((uint)ll_len &amp; 0x3f) - 0x6 &amp; 0xff; local_38 = (undefined)n; memcpy(stack_buffer,ptr_ll_pkt + 0x8,n); local_18 = *(undefined *)(ptr_some_struct + 0xa); if ((bVar1 &amp; 0xf) == 0x0) { local_40 = 0x0; } else { if (uVar2 == 0x1) { local_40 = 0x1; local_38 = 0x0; } else { if (uVar2 == 0x2) { local_40 = 0x3; } else { if (uVar2 != 0x6) { return; } local_40 = 0x2; } } } FUN_000398e2(0x1,&amp;local_40); return; } Let's observe that at first, a memcpy() operation is taking place: memcpy(stack_buffer,ptr_ll_pkt + 0x8,n); Where, stack_buffer is stack-buffer of [\0x1f] slots. ptr_ll_pkt is user-controlled source. n is a user-controlled parameter with a fixed size. Let's make counts: n = ((uint)ll_len &amp; 0x3f) - 0x6 &amp; 0xff; ll_len is user-conttrolled, since is casted as a unsigned integer, then "(uint)ll_len &amp; 0x3f" is also casted as unsigned integer and also the substraction "((uint)ll_len &amp; 0x3f) - 0x6" is unsigned. Then, is ll_len is a value that makes 0 the term "((uint)ll_len &amp; 0x3f)", then, -0x6 is (as an unsigned integer), 0xFFFFFFFA which masked with 0xFF is 0xFA. So n can have as maxim value 0xFA versus the size of the array which is 0x1F, thus a stack buffer overflow arises. 5.2. CVE-2020-15999. Google Chrome uses the open source FreeType project, which renders fonts and PNG images embedded in fonts. Consider the following C code. The code attemps to process PNG images in fonts. Retrieves the images width and height from the header stores them in an special structure, calculates the bitmap size and allocates it back in store for that size. Then calls for another library function to copy data from the PNG int the allocate space before. #if CHAR_BIT == 8 &amp;&amp; UCHAR_MAX == 255 typedef unsigned char png_byte; #else # error "libpng requires 8-bit bytes" #endif typedef char FT_String; typedef unsigned char FT_Byte; typedef signed char FT_Char; typedef unsigned char FT_Bool; typedef signed short FT_FWord; /* distance in FUnits */ typedef unsigned short FT_UFWord; /* unsigned distance */ typedef signed short FT_Short; typedef unsigned short FT_UShort; typedef signed int FT_Int; typedef unsigned int FT_UInt; typedef signed long FT_Long; typedef unsigned long FT_ULong; typedef struct FT_Bitmap_ { unsigned int rows; unsigned int width; int pitch; unsigned char* buffer; unsigned short num_grays; unsigned char pixel_mode; unsigned char palette_mode; void* palette; } FT_Bitmap; typedef struct TT_SBit_MetricsRec_ { FT_UShort height; FT_UShort width; FT_Short horiBearingX; FT_Short horiBearingY; FT_UShort horiAdvance; FT_Short vertBearingX; FT_Short vertBearingY; FT_UShort vertAdvance; } TT_SBit_MetricsRec, *TT_SBit_Metrics; ////ACID: data, png_len FT_LOCAL_DEF( FT_Error ) Load_SBit_Png( FT_GlyphSlot slot, FT_Int x_offset, FT_Int y_offset, FT_Int pix_bits, TT_SBit_Metrics metrics, FT_Memory memory, FT_Byte* data, FT_UInt png_len, FT_Bool populate_map_and_metrics, //KC: Assume true FT_Bool metrics_only ) { FT_Bitmap *map = &amp;slot-&gt;bitmap; FT_Error error = FT_Err_Ok; FT_StreamRec stream; png_structp png; png_infop info; png_uint_32 imgWidth, imgHeight; int bitdepth, color_type, interlace; FT_Int i; png_byte* *rows = NULL; /* pacify compiler */ // ... FT_Stream_OpenMemory( &amp;stream, data, png_len ); //KC: data ACID-&gt; stream png = png_create_read_struct( PNG_LIBPNG_VER_STRING, &amp;error, error_callback, warning_callback ); // ... png_set_read_fn( png, &amp;stream, read_data_from_FT_Stream ); //KC: stream ACID-&gt; png png_read_info( png, info ); png_get_IHDR( png, info, &amp;imgWidth, &amp;imgHeight, &amp;bitdepth, &amp;color_type, &amp;interlace, NULL, NULL ); if ( error || ( !populate_map_and_metrics &amp;&amp; ( (FT_Int)imgWidth != metrics-&gt;width || (FT_Int)imgHeight != metrics-&gt;height ) ) ) goto DestroyExit; if ( populate_map_and_metrics ) { metrics-&gt;width = (FT_UShort)imgWidth; metrics-&gt;height = (FT_UShort)imgHeight; map-&gt;width = metrics-&gt;width; map-&gt;rows = metrics-&gt;height; map-&gt;pixel_mode = FT_PIXEL_MODE_BGRA; map-&gt;pitch = (int)( map-&gt;width * 4 ); map-&gt;num_grays = 256; /* reject too large bitmaps similarly to the rasterizer */ if ( map-&gt;rows &gt; 0x7FFF || map-&gt;width &gt; 0x7FFF ) { error = FT_THROW( Array_Too_Large ); goto DestroyExit; } } // ... if ( populate_map_and_metrics ) { /* this doesn't overflow: 0x7FFF * 0x7FFF * 4 &lt; 2^32 */ FT_ULong size = map-&gt;rows * (FT_ULong)map-&gt;pitch; error = ft_glyphslot_alloc_bitmap( slot, size ); if ( error ) goto DestroyExit; } if ( FT_NEW_ARRAY( rows, imgHeight ) ) //KC: realloc(rows, imgHeight*sizeof(ptr)) { //KC: and memset() to 0 error = FT_THROW( Out_Of_Memory ); goto DestroyExit; } for ( i = 0; i &lt; (FT_Int)imgHeight; i++ ) rows[i] = map-&gt;buffer + ( y_offset + i ) * map-&gt;pitch + x_offset * 4; png_read_image( png, rows ); //KC: Uses the same imgWidth/Height from png_get_IHDR() to read the PNG into rows[] } /* Pointers to pointers; i.e. arrays */ typedef png_byte * * png_bytepp; struct png_struct_def { #ifdef PNG_SETJMP_SUPPORTED jmp_buf jmp_buf_local; /* New name in 1.6.0 for jmp_buf in png_struct */ png_longjmp_ptr longjmp_fn;/* setjmp non-local goto function. */ jmp_buf *jmp_buf_ptr; /* passed to longjmp_fn */ size_t jmp_buf_size; /* size of the above, if allocated */ #endif png_error_ptr error_fn; /* function for printing errors and aborting */ #ifdef PNG_WARNINGS_SUPPORTED png_error_ptr warning_fn; /* function for printing warnings */ #endif png_voidp error_ptr; /* user supplied struct for error functions */ png_rw_ptr write_data_fn; /* function for writing output data */ png_rw_ptr read_data_fn; /* function for reading input data */ png_voidp io_ptr; /* ptr to application struct for I/O functions */ #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED png_user_transform_ptr read_user_transform_fn; /* user read transform */ #endif #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED png_user_transform_ptr write_user_transform_fn; /* user write transform */ #endif /* These were added in libpng-1.0.2 */ #ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \ defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) png_voidp user_transform_ptr; /* user supplied struct for user transform */ png_byte user_transform_depth; /* bit depth of user transformed pixels */ png_byte user_transform_channels; /* channels in user transformed pixels */ #endif #endif png_uint_32 mode; /* tells us where we are in the PNG file */ png_uint_32 flags; /* flags indicating various things to libpng */ png_uint_32 transformations; /* which transformations to perform */ png_uint_32 zowner; /* ID (chunk type) of zstream owner, 0 if none */ z_stream zstream; /* decompression structure */ #ifdef PNG_WRITE_SUPPORTED png_compression_bufferp zbuffer_list; /* Created on demand during write */ uInt zbuffer_size; /* size of the actual buffer */ int zlib_level; /* holds zlib compression level */ int zlib_method; /* holds zlib compression method */ int zlib_window_bits; /* holds zlib compression window bits */ int zlib_mem_level; /* holds zlib compression memory level */ int zlib_strategy; /* holds zlib compression strategy */ #endif /* Added at libpng 1.5.4 */ #ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED int zlib_text_level; /* holds zlib compression level */ int zlib_text_method; /* holds zlib compression method */ int zlib_text_window_bits; /* holds zlib compression window bits */ int zlib_text_mem_level; /* holds zlib compression memory level */ int zlib_text_strategy; /* holds zlib compression strategy */ #endif /* End of material added at libpng 1.5.4 */ /* Added at libpng 1.6.0 */ #ifdef PNG_WRITE_SUPPORTED int zlib_set_level; /* Actual values set into the zstream on write */ int zlib_set_method; int zlib_set_window_bits; int zlib_set_mem_level; int zlib_set_strategy; #endif png_uint_32 width; /* width of image in pixels */ png_uint_32 height; /* height of image in pixels */ png_uint_32 num_rows; /* number of rows in current pass */ png_uint_32 usr_width; /* width of row at start of write */ size_t rowbytes; /* size of row in bytes */ png_uint_32 iwidth; /* width of current interlaced row in pixels */ png_uint_32 row_number; /* current row in interlace pass */ png_uint_32 chunk_name; /* PNG_CHUNK() id of current chunk */ png_bytep prev_row; /* buffer to save previous (unfiltered) row. * While reading this is a pointer into * big_prev_row; while writing it is separately * allocated if needed. */ png_bytep row_buf; /* buffer to save current (unfiltered) row. * While reading, this is a pointer into * big_row_buf; while writing it is separately * allocated. */ #ifdef PNG_WRITE_FILTER_SUPPORTED png_bytep try_row; /* buffer to save trial row when filtering */ png_bytep tst_row; /* buffer to save best trial row when filtering */ #endif size_t info_rowbytes; /* Added in 1.5.4: cache of updated row bytes */ png_uint_32 idat_size; /* current IDAT size for read */ png_uint_32 crc; /* current chunk CRC value */ png_colorp palette; /* palette from the input file */ png_uint_16 num_palette; /* number of color entries in palette */ /* Added at libpng-1.5.10 */ #ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED int num_palette_max; /* maximum palette index found in IDAT */ #endif png_uint_16 num_trans; /* number of transparency values */ png_byte compression; /* file compression type (always 0) */ png_byte filter; /* file filter type (always 0) */ png_byte interlaced; /* PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */ png_byte pass; /* current interlace pass (0 - 6) */ png_byte do_filter; /* row filter flags (see PNG_FILTER_ in png.h ) */ png_byte color_type; /* color type of file */ png_byte bit_depth; /* bit depth of file */ png_byte usr_bit_depth; /* bit depth of users row: write only */ png_byte pixel_depth; /* number of bits per pixel */ png_byte channels; /* number of channels in file */ #ifdef PNG_WRITE_SUPPORTED png_byte usr_channels; /* channels at start of write: write only */ #endif png_byte sig_bytes; /* magic bytes read/written from start of file */ png_byte maximum_pixel_depth; /* pixel depth used for the row buffers */ png_byte transformed_pixel_depth; /* pixel depth after read/write transforms */ #if ZLIB_VERNUM &gt;= 0x1240 png_byte zstream_start; /* at start of an input zlib stream */ #endif /* Zlib &gt;= 1.2.4 */ #if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED) png_uint_16 filler; /* filler bytes for pixel expansion */ #endif #if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) ||\ defined(PNG_READ_ALPHA_MODE_SUPPORTED) png_byte background_gamma_type; png_fixed_point background_gamma; png_color_16 background; /* background color in screen gamma space */ #ifdef PNG_READ_GAMMA_SUPPORTED png_color_16 background_1; /* background normalized to gamma 1.0 */ #endif #endif /* bKGD */ #ifdef PNG_WRITE_FLUSH_SUPPORTED png_flush_ptr output_flush_fn; /* Function for flushing output */ png_uint_32 flush_dist; /* how many rows apart to flush, 0 - no flush */ png_uint_32 flush_rows; /* number of rows written since last flush */ #endif #ifdef PNG_READ_GAMMA_SUPPORTED int gamma_shift; /* number of "insignificant" bits in 16-bit gamma */ png_fixed_point screen_gamma; /* screen gamma value (display_exponent) */ png_bytep gamma_table; /* gamma table for 8-bit depth files */ png_uint_16pp gamma_16_table; /* gamma table for 16-bit depth files */ #if defined(PNG_READ_BACKGROUND_SUPPORTED) || \ defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \ defined(PNG_READ_RGB_TO_GRAY_SUPPORTED) png_bytep gamma_from_1; /* converts from 1.0 to screen */ png_bytep gamma_to_1; /* converts from file to 1.0 */ png_uint_16pp gamma_16_from_1; /* converts from 1.0 to screen */ png_uint_16pp gamma_16_to_1; /* converts from file to 1.0 */ #endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */ #endif #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_sBIT_SUPPORTED) png_color_8 sig_bit; /* significant bits in each available channel */ #endif #if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED) png_color_8 shift; /* shift for significant bit transformation */ #endif #if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) \ || defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) png_bytep trans_alpha; /* alpha values for paletted files */ png_color_16 trans_color; /* transparent color for non-paletted files */ #endif png_read_status_ptr read_row_fn; /* called after each row is decoded */ png_write_status_ptr write_row_fn; /* called after each row is encoded */ #ifdef PNG_PROGRESSIVE_READ_SUPPORTED png_progressive_info_ptr info_fn; /* called after header data fully read */ png_progressive_row_ptr row_fn; /* called after a prog. row is decoded */ png_progressive_end_ptr end_fn; /* called after image is complete */ png_bytep save_buffer_ptr; /* current location in save_buffer */ png_bytep save_buffer; /* buffer for previously read data */ png_bytep current_buffer_ptr; /* current location in current_buffer */ png_bytep current_buffer; /* buffer for recently used data */ png_uint_32 push_length; /* size of current input chunk */ png_uint_32 skip_length; /* bytes to skip in input data */ size_t save_buffer_size; /* amount of data now in save_buffer */ size_t save_buffer_max; /* total size of save_buffer */ size_t buffer_size; /* total amount of available input data */ size_t current_buffer_size; /* amount of data now in current_buffer */ int process_mode; /* what push library is currently doing */ int cur_palette; /* current push library palette index */ #endif /* PROGRESSIVE_READ */ #if defined(__TURBOC__) &amp;&amp; !defined(_Windows) &amp;&amp; !defined(__FLAT__) /* For the Borland special 64K segment handler */ png_bytepp offset_table_ptr; png_bytep offset_table; png_uint_16 offset_table_number; png_uint_16 offset_table_count; png_uint_16 offset_table_count_free; #endif #ifdef PNG_READ_QUANTIZE_SUPPORTED png_bytep palette_lookup; /* lookup table for quantizing */ png_bytep quantize_index; /* index translation for palette files */ #endif /* Options */ #ifdef PNG_SET_OPTION_SUPPORTED png_uint_32 options; /* On/off state (up to 16 options) */ #endif #if PNG_LIBPNG_VER &lt; 10700 /* To do: remove this from libpng-1.7 */ #ifdef PNG_TIME_RFC1123_SUPPORTED char time_buffer[29]; /* String to hold RFC 1123 time text */ #endif #endif /* New members added in libpng-1.0.6 */ png_uint_32 free_me; /* flags items libpng is responsible for freeing */ #ifdef PNG_USER_CHUNKS_SUPPORTED png_voidp user_chunk_ptr; #ifdef PNG_READ_USER_CHUNKS_SUPPORTED png_user_chunk_ptr read_user_chunk_fn; /* user read chunk handler */ #endif #endif #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED int unknown_default; /* As PNG_HANDLE_* */ unsigned int num_chunk_list; /* Number of entries in the list */ png_bytep chunk_list; /* List of png_byte[5]; the textual chunk name * followed by a PNG_HANDLE_* byte */ #endif /* New members added in libpng-1.0.3 */ #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED png_byte rgb_to_gray_status; /* Added in libpng 1.5.5 to record setting of coefficients: */ png_byte rgb_to_gray_coefficients_set; /* These were changed from png_byte in libpng-1.0.6 */ png_uint_16 rgb_to_gray_red_coeff; png_uint_16 rgb_to_gray_green_coeff; /* deleted in 1.5.5: rgb_to_gray_blue_coeff; */ #endif /* New member added in libpng-1.6.36 */ #if defined(PNG_READ_EXPAND_SUPPORTED) &amp;&amp; \ defined(PNG_ARM_NEON_IMPLEMENTATION) png_bytep riffled_palette; /* buffer for accelerated palette expansion */ #endif /* New member added in libpng-1.0.4 (renamed in 1.0.9) */ #if defined(PNG_MNG_FEATURES_SUPPORTED) /* Changed from png_byte to png_uint_32 at version 1.2.0 */ png_uint_32 mng_features_permitted; #endif /* New member added in libpng-1.0.9, ifdef'ed out in 1.0.12, enabled in 1.2.0 */ #ifdef PNG_MNG_FEATURES_SUPPORTED png_byte filter_type; #endif /* New members added in libpng-1.2.0 */ /* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */ #ifdef PNG_USER_MEM_SUPPORTED png_voidp mem_ptr; /* user supplied struct for mem functions */ png_malloc_ptr malloc_fn; /* function for allocating memory */ png_free_ptr free_fn; /* function for freeing memory */ #endif /* New member added in libpng-1.0.13 and 1.2.0 */ png_bytep big_row_buf; /* buffer to save current (unfiltered) row */ #ifdef PNG_READ_QUANTIZE_SUPPORTED /* The following three members were added at version 1.0.14 and 1.2.4 */ png_bytep quantize_sort; /* working sort array */ png_bytep index_to_palette; /* where the original index currently is in the palette */ png_bytep palette_to_index; /* which original index points to this palette color */ #endif /* New members added in libpng-1.0.16 and 1.2.6 */ png_byte compression_type; #ifdef PNG_USER_LIMITS_SUPPORTED png_uint_32 user_width_max; png_uint_32 user_height_max; /* Added in libpng-1.4.0: Total number of sPLT, text, and unknown * chunks that can be stored (0 means unlimited). */ png_uint_32 user_chunk_cache_max; /* Total memory that a zTXt, sPLT, iTXt, iCCP, or unknown chunk * can occupy when decompressed. 0 means unlimited. */ png_alloc_size_t user_chunk_malloc_max; #endif /* New member added in libpng-1.0.25 and 1.2.17 */ #ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED /* Temporary storage for unknown chunk that the library doesn't recognize, * used while reading the chunk. */ png_unknown_chunk unknown_chunk; #endif /* New member added in libpng-1.2.26 */ size_t old_big_row_buf_size; #ifdef PNG_READ_SUPPORTED /* New member added in libpng-1.2.30 */ png_bytep read_buffer; /* buffer for reading chunk data */ png_alloc_size_t read_buffer_size; /* current size of the buffer */ #endif #ifdef PNG_SEQUENTIAL_READ_SUPPORTED uInt IDAT_read_size; /* limit on read buffer size for IDAT */ #endif #ifdef PNG_IO_STATE_SUPPORTED /* New member added in libpng-1.4.0 */ png_uint_32 io_state; #endif /* New member added in libpng-1.5.6 */ png_bytep big_prev_row; /* New member added in libpng-1.5.7 */ void (*read_filter[PNG_FILTER_VALUE_LAST-1])(png_row_infop row_info, png_bytep row, png_const_bytep prev_row); #ifdef PNG_READ_SUPPORTED #if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED) png_colorspace colorspace; #endif #endif }; /* Basic control structions. Read libpng-manual.txt or libpng.3 for more info. * * png_struct is the cache of information used while reading or writing a single * PNG file. One of these is always required, although the simplified API * (below) hides the creation and destruction of it. */ typedef struct png_struct_def png_struct; # ifndef PNG_RESTRICT # define PNG_RESTRICT __restrict # endif /* Types with names ending 'p' are pointer types. The corresponding types with * names ending 'rp' are identical pointer types except that the pointer is * marked 'restrict', which means that it is the only pointer to the object * passed to the function. Applications should not use the 'restrict' types; * it is always valid to pass 'p' to a pointer with a function argument of the * corresponding 'rp' type. Different compilers have different rules with * regard to type matching in the presence of 'restrict'. For backward * compatibility libpng callbacks never have 'restrict' in their parameters and, * consequentially, writing portable application code is extremely difficult if * an attempt is made to use 'restrict'. */ typedef png_struct * PNG_RESTRICT png_structrp; /* Read the entire image. If the image has an alpha channel or a tRNS * chunk, and you have called png_handle_alpha()[*], you will need to * initialize the image to the current image that PNG will be overlaying. * We set the num_rows again here, in case it was incorrectly set in * png_read_start_row() by a call to png_read_update_info() or * png_start_read_image() if png_set_interlace_handling() wasn't called * prior to either of these functions like it should have been. You can * only call this function once. If you desire to have an image for * each pass of a interlaced image, use png_read_rows() instead. * * [*] png_handle_alpha() does not exist yet, as of this version of libpng */ void PNGAPI png_read_image(png_structrp png_ptr, png_bytepp image) { png_uint_32 i, image_height; int pass, j; png_bytepp rp; png_debug(1, "in png_read_image"); if (png_ptr == NULL) return; #ifdef PNG_READ_INTERLACING_SUPPORTED if ((png_ptr-&gt;flags &amp; PNG_FLAG_ROW_INIT) == 0) { pass = png_set_interlace_handling(png_ptr); /* And make sure transforms are initialized. */ png_start_read_image(png_ptr); } else { if (png_ptr-&gt;interlaced != 0 &amp;&amp; (png_ptr-&gt;transformations &amp; PNG_INTERLACE) == 0) { /* Caller called png_start_read_image or png_read_update_info without * first turning on the PNG_INTERLACE transform. We can fix this here, * but the caller should do it! */ png_warning(png_ptr, "Interlace handling should be turned on when " "using png_read_image"); /* Make sure this is set correctly */ png_ptr-&gt;num_rows = png_ptr-&gt;height; } /* Obtain the pass number, which also turns on the PNG_INTERLACE flag in * the above error case. */ pass = png_set_interlace_handling(png_ptr); } #else if (png_ptr-&gt;interlaced) png_error(png_ptr, "Cannot read interlaced image -- interlace handler disabled"); pass = 1; #endif image_height=png_ptr-&gt;height; for (j = 0; j &lt; pass; j++) { rp = image; for (i = 0; i &lt; image_height; i++) { png_read_row(png_ptr, *rp, NULL); rp++; } } } The key of this vulnerability, according to what we explain above resides on the following block: //... if ( error || ( !populate_map_and_metrics &amp;&amp; ( (FT_Int)imgWidth != metrics-&gt;width || (FT_Int)imgHeight != metrics-&gt;height ) ) ) goto DestroyExit; if ( populate_map_and_metrics ) { metrics-&gt;width = (FT_UShort)imgWidth; metrics-&gt;height = (FT_UShort)imgHeight; //... } The width and the height of the PNG which is used to allocate space gets truncated since gets both converted from int to short without correct validation. As we seen before, this could lead to an under-allocation and later to an over-copy. 5.3. CVE-2020-17087. Consider the following C code: ////ACID:SourceBuffer, SourceLength NTSTATUS CfgAdtpFormatPropertyBlock(PBYTE SourceBuffer, USHORT SourceLength, PUNICODE_STRING Destination) { CONST USHORT DestinationSize = (USHORT)(6 * SourceLength); PWCHAR OutputBuffer = BCryptAlloc(DestinationSize); for (USHORT i = 0; i &lt; SourceLength; i++) { *OutputBuffer++ = "0123456789abcdef"[*SourceBuffer &gt;&gt; 4]; *OutputBuffer++ = "0123456789abcdef"[*SourceBuffer &amp; 0xF]; *OutputBuffer++ = ' '; SourceBuffer++; } Destination-&gt;MaximumLength = DestinationSize; Destination-&gt;Length = DestinationSize - 2; Destination-&gt;Buffer = OutputBuffer; return STATUS_SUCCESS; } This chunk of code is vulnerable to an overcopy due to underallocation result of integer overflow, OutputBuffer gets assignation in a for-loop when the break condition is i&lt; Source Length. But the allocated space for this Buffer is DestinationSize which is 6 times SourceLength, this could provoke (assuming BCryptAlloc does not prevent it) that if SourceLength is (MAX_SHORT_SIZE + 1) / 6, then an underallocation is performed and out-of-bounds write is done. 5.4. CVE-2021-33909. Sequoia. Consider the following C code: ////NOTE: Start reading the code at seq_read_iter() /** * seq_has_overflowed - check if the buffer has overflowed * @m: the seq_file handle * * seq_files have a buffer which may overflow. When this happens a larger * buffer is reallocated and all the data will be printed again. * The overflow state is true when m-&gt;count == m-&gt;size. * * Returns true if the buffer received more than it can hold. */ static inline bool seq_has_overflowed(struct seq_file *m) { return m-&gt;count == m-&gt;size; } //------------------------------------------------------------------------ 135 static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt) //KC: called by "m-&gt;op-&gt;show(m, p)" 136 { ... 150 seq_dentry(m, mnt-&gt;mnt_root, " \t\n\\"); //------------------------------------------------------------------------ 523 int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc) 524 { 525 char *buf; 526 size_t size = seq_get_buf(m, &amp;buf); ... 529 if (size) { 530 char *p = dentry_path(dentry, buf, size); //------------------------------------------------------------------------ 380 char *dentry_path(struct dentry *dentry, char *buf, int buflen) 381 { 382 char *p = NULL; ... 385 if (d_unlinked(dentry)) { //KC: assume true 386 p = buf + buflen; 387 if (prepend(&amp;p, &amp;buflen, "//deleted", 10) != 0) //------------------------------------------------------------------------ 11 static int prepend(char **buffer, int *buflen, const char *str, int namelen) 12 { 13 *buflen -= namelen; 14 if (*buflen &lt; 0) 15 return -ENAMETOOLONG; 16 *buffer -= namelen; 17 memcpy(*buffer, str, namelen); //------------------------------------------------------------------------ ////ACID: Assume the attacker can control the underlying seq_file to cause the while(1) loop to occur as many times as they want 168 ssize_t seq_read_iter(struct kiocb *iocb, struct iov_iter *iter) 169 { 170 struct seq_file *m = iocb-&gt;ki_filp-&gt;private_data; ... 205 /* grab buffer if we didn't have one */ 206 if (!m-&gt;buf) { //KC: assume this is NULL on the first iteration 207 m-&gt;buf = seq_buf_alloc(m-&gt;size = PAGE_SIZE); //KC: m-&gt;size is a size_t ... 210 } ... 220 // get a non-empty record in the buffer ... 223 while (1) { ... 227 err = m-&gt;op-&gt;show(m, p); //KC: This calls to show_mountinfo() ... 236 if (!seq_has_overflowed(m)) // got it 237 goto Fill; 238 // need a bigger buffer ... 240 kvfree(m-&gt;buf); ... 242 m-&gt;buf = seq_buf_alloc(m-&gt;size &lt;&lt;= 1); ... 246 }]]></summary></entry><entry><title type="html">Passing Parameters.</title><link href="http://localhost:4000/posts/2025/12/04/Passing-Parameters/" rel="alternate" type="text/html" title="Passing Parameters." /><published>2025-12-04T10:00:00+01:00</published><updated>2025-12-04T10:00:00+01:00</updated><id>http://localhost:4000/posts/2025/12/04/Passing%20Parameters</id><content type="html" xml:base="http://localhost:4000/posts/2025/12/04/Passing-Parameters/"><![CDATA[<h3 id="1-parameter-definition">1. Parameter Definition.</h3>

<p>First, a <em>parameter</em> is simply data that gets placed in a specific location where the calling convention dictates the callee should look for it. This means that is data that a called function knows where to find it.</p>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="mh">0x11</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The func() function accepts a parameter which is defined in the signature as a signed integer.</p>

<p>Let's get the dissasembly, this is achieve through :</p>

<pre><code class="language-assem">0x00001129      f30f1efa       endbr64    ;  Intel CET instruction
0x0000112d      55             push rbp
0x0000112e      4889e5         mov rbp, rsp
0x00001131      897dec         mov dword [rbp - 0x14], edi ; arg1
0x00001134      8b45ec         mov eax, dword [rbp - 0x14]
0x00001137      8945fc         mov dword [rbp - 4], eax
0x0000113a      8b45fc         mov eax, dword [rbp - 4]
0x0000113d      5d             pop rbp
0x0000113e      c3             ret

int main (int argc, char **argv, char **envp);
0x0000113f      f30f1efa       endbr64
0x00001143      55             push rbp
0x00001144      4889e5         mov rbp, rsp
0x00001147      bf11000000     mov edi, 0x11               ; int64_t arg1
0x0000114c      e8d8ffffff     call sym.func
0x00001151      5d             pop rbp
0x00001152      c3             ret
</code></pre>

<ul>
  <li>
    <p>First, the return address:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0x0000112d      55             push rbp
  0x0000112e      4889e5         mov rbp, rsp
</code></pre></div>    </div>
  </li>
  <li>
    <p>Then, the parameter, main calls <em>func()</em> passing the hex value <em>0x11</em>. Since this is a Linux system (compiled with GCC in WSL) the parameter gets stored in RDI, then calls the function:</p>

    <pre><code class="language-assem">  0x00001147      bf11000000     mov edi, 0x11
  0x0000114c      e8d8ffffff     call sym.func
</code></pre>

    <p>This is a convention, according to our definition of a parameter, 0x11 is a value that, for convention, func knows where to find (in RDI).</p>
  </li>
  <li>
    <p>The flow of execution enters func() which assigns this parameter to a local variable for which resorts EDI:</p>

    <pre><code class="language-assem">  0x0000112d      55             push rbp
  0x0000112e      4889e5         mov rbp, rsp
  0x00001131      897dec         mov dword [rbp - 0x14], edi ; arg1
</code></pre>

    <p>Then returns the value by passing this following value to EAX in a convoluted way:</p>

    <pre><code class="language-assem">  0x00001134      8b45ec         mov eax, dword [rbp - 0x14]
  0x00001137      8945fc         mov dword [rbp - 4], eax
  0x0000113a      8b45fc         mov eax, dword [rbp - 4]
</code></pre>
  </li>
</ul>

<p><br /></p>

<h3 id="2-x64-calling-conventions">2. x64. Calling Conventions.</h3>

<p>Assembly doesn't have a built-in concept of "functions" like high-level languages do. Instead, it uses calling conventions; standardized rules for how to pass arguments and manage the stack when calling subroutines.</p>

<p>There are two main frameworks by platform:</p>

<p><strong>Windows x64 (Microsoft x64 ABI)</strong></p>

<ul>
  <li>First 4 arguments: Passed in registers RCX, RDX, R8, R9 (in that order)</li>
  <li>Additional arguments: Passed on the stack (right-to-left)</li>
  <li>Floating-point arguments: Use XMM0, XMM1, XMM2, XMM3</li>
  <li>Return value: RAX (RDX:RAX) for integers, XMM0 for floats</li>
  <li>A compiler example is MCVS 2019.</li>
</ul>

<p>Consider the main's code compiled in MCVS 2019:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000000140001020 48 83 EC 28          sub         rsp,28h  
0000000140001024 B9 11 00 00 00       mov         ecx,11h  &lt;--- ECX (RCX) to store 0x11
0000000140001029 E8 D2 FF FF FF       call        func (0140001000h)  
000000014000102E 48 83 C4 28          add         rsp,28h  
0000000140001032 C3                   ret 
</code></pre></div></div>

<p><br /></p>

<p><strong>System V AMD64 ABI (Linux, macOS)</strong></p>

<ul>
  <li>First 6 integer arguments: RDI, RSI, RDX, RCX, R8, R9</li>
  <li>First 8 float arguments: XMM0 through XMM7</li>
  <li>Additional arguments: Passed on the stack</li>
  <li>Return value: RAX (RDX:RAX) for integers, XMM0 for floats</li>
  <li>A compiler example is GCC.</li>
</ul>

<p><br /></p>

<p>In general:</p>

<ul>
  <li>Both caller and callee are responsible for balancing any register saves they perform (add to the stack), with restores (removal from the stack). Caller will typically save registers right before the call and restore right after the call and the callee will typically save registers at the beginning of the function and restore at the end of the function.</li>
</ul>

<p><br /></p>

<h3 id="3-shadow-store">3. Shadow Store.</h3>

<p>Shadow store (also called home space or shadow space) is a Windows x64-specific feature by which the caller must allocate 32 bytes (4 × 8-byte slots) on the stack before calling a function, the space corresponds to 4 register-passed parameters. Then, the callee can optionally use this space to "spill" (save) those register values if needed.</p>

<p>Is like a sort of a caller's "inverse"-stackframe for register-passed parameter to the callee exclusive of Microsoft x64 ABI calling-convention programs.</p>

<p>The term 'inverse' refers to the fact that the shadow space is created first before the CALL of the callee in terms of instruction execution order and also is above his own stackframe (if it exists).</p>

<p>This is, if a caller reserve a shadow space for a callee, then the callee access this space by going up in the stack (towards higher address), accessing the stack-context of the caller function (rbp+0x08), the stackframe would be created after the callee is invoked and everytime the callee wants to access his own stackframe he must go below the calleer in terms of stackdiagram (rbp-0x08)</p>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────────┐  Higher addresses
│                         │
│  Shadow space           │  ← Callee accesses via [rsp+8], [rsp+10], etc.
│  (caller allocated)     │     Going UP (positive offsets)
│                         │
├─────────────────────────┤  ← Return address pushed by CALL
│  return addr            │
├─────────────────────────┤  ← rsp after CALL, before callee prologue
│                         │
│  Callee's own frame     │  ← Callee accesses via [rsp-8] or [rbp-8]
│  (locals, saved regs)   │     Going DOWN (negative offsets)
│                         │
└─────────────────────────┘  Lower addresses
</code></pre></div></div>

<p><br /></p>

<h3 id="4-instruction-lea-load-effective-address">4. Instruction LEA. Load Effective Address.</h3>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="c1">//reminder: atoi() converts an</span>
    <span class="c1">//ASCII string to an integer</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">argc</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code declares a variable and then assigns to it a value passed by a command line argument and processed by <em>atoi()</em> (ASCII to Integer), which yields an integer from a provided string.</p>

<p>Then returns 2 times the number of argumets passed through the command line to the program plus 'a'.</p>

<p><br /></p>

<p>Then, we have the following dissasembly through MCVS 2019:</p>

<pre><code class="language-assem">0000000140001000 40 53                push        rbx  
0000000140001002 48 83 EC 20          sub         rsp,20h  
0000000140001006 8B D9                mov         ebx,ecx  
0000000140001008 48 8B 4A 08          mov         rcx,qword ptr [rdx+8]  
000000014000100C FF 15 66 31 00 00    call        qword ptr [__imp_atoi (0140004178h)]  
0000000140001012 8D 04 58             lea         eax,[rax+rbx*2]  
0000000140001015 48 83 C4 20          add         rsp,20h  
0000000140001019 5B                   pop         rbx  
</code></pre>

<p>Is worth to note before enter to explain LEA, that the code above is importing dynamically atoi() function from &lt;stdlib.h&gt; and because of that is trying to access to atoi() by dereferencing an external address through '_imp' directive.</p>

<p>Also, we could think that</p>

<pre><code class="language-asssem">0000000140001002 48 83 EC 20          sub         rsp,20h  
</code></pre>

<p>Is the prologue to the stackframe, buit is not. Since a callee is about to be called by the main function (and this program follows MC x64 ABI calling-conventions) a shadow space for register-passed parameters needs to be allocated.</p>

<p>The key to distinguish between is by context, if you look closer to the code:</p>

<ul>
  <li>
    <p>First, there is no need from stackframe since there is only one local variable (which also is never stored somepoint behind rbx)</p>
  </li>
  <li>
    <p>There is a callee and this is MC x64 ABI program so the rsp substraction needs to be the shadow space allocation</p>
  </li>
</ul>

<p><br /></p>

<p>Lets talk about LEA.</p>

<p>Often, in assembly the brackets [] is a directive which tells the system to dereference which is inside as a memory address, but is not the case with LEA.</p>

<p>With LEA an arithmeticv operation is gonna be pass to between brackets. LEA would solve that operation and then store that value in a register.</p>

<p>For example, in our code there is the line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000000140001012 8D 04 58             lea         eax,[rax+rbx*2] 
</code></pre></div></div>

<p>Which simply calculates "rax+rbx*2" and store that value on EAX.</p>

<p>So it just moves the value within the brackets (it resolves an operation if proceeds) int</p>

<p><br /></p>]]></content><author><name>German Sanmi</name></author><category term="Past Blogs" /><category term="Assembly" /><category term="x86" /><category term="reverse-engineering" /><summary type="html"><![CDATA[1. Parameter Definition. First, a parameter is simply data that gets placed in a specific location where the calling convention dictates the callee should look for it. This means that is data that a called function knows where to find it. Consider the following code: int func(int a){ int i = a; return i; } int main(){ return func(0x11); } The func() function accepts a parameter which is defined in the signature as a signed integer. Let's get the dissasembly, this is achieve through : 0x00001129 f30f1efa endbr64 ; Intel CET instruction 0x0000112d 55 push rbp 0x0000112e 4889e5 mov rbp, rsp 0x00001131 897dec mov dword [rbp - 0x14], edi ; arg1 0x00001134 8b45ec mov eax, dword [rbp - 0x14] 0x00001137 8945fc mov dword [rbp - 4], eax 0x0000113a 8b45fc mov eax, dword [rbp - 4] 0x0000113d 5d pop rbp 0x0000113e c3 ret int main (int argc, char **argv, char **envp); 0x0000113f f30f1efa endbr64 0x00001143 55 push rbp 0x00001144 4889e5 mov rbp, rsp 0x00001147 bf11000000 mov edi, 0x11 ; int64_t arg1 0x0000114c e8d8ffffff call sym.func 0x00001151 5d pop rbp 0x00001152 c3 ret First, the return address: 0x0000112d 55 push rbp 0x0000112e 4889e5 mov rbp, rsp Then, the parameter, main calls func() passing the hex value 0x11. Since this is a Linux system (compiled with GCC in WSL) the parameter gets stored in RDI, then calls the function: 0x00001147 bf11000000 mov edi, 0x11 0x0000114c e8d8ffffff call sym.func This is a convention, according to our definition of a parameter, 0x11 is a value that, for convention, func knows where to find (in RDI). The flow of execution enters func() which assigns this parameter to a local variable for which resorts EDI: 0x0000112d 55 push rbp 0x0000112e 4889e5 mov rbp, rsp 0x00001131 897dec mov dword [rbp - 0x14], edi ; arg1 Then returns the value by passing this following value to EAX in a convoluted way: 0x00001134 8b45ec mov eax, dword [rbp - 0x14] 0x00001137 8945fc mov dword [rbp - 4], eax 0x0000113a 8b45fc mov eax, dword [rbp - 4] 2. x64. Calling Conventions. Assembly doesn't have a built-in concept of "functions" like high-level languages do. Instead, it uses calling conventions; standardized rules for how to pass arguments and manage the stack when calling subroutines. There are two main frameworks by platform: Windows x64 (Microsoft x64 ABI) First 4 arguments: Passed in registers RCX, RDX, R8, R9 (in that order) Additional arguments: Passed on the stack (right-to-left) Floating-point arguments: Use XMM0, XMM1, XMM2, XMM3 Return value: RAX (RDX:RAX) for integers, XMM0 for floats A compiler example is MCVS 2019. Consider the main's code compiled in MCVS 2019: 0000000140001020 48 83 EC 28 sub rsp,28h 0000000140001024 B9 11 00 00 00 mov ecx,11h &lt;--- ECX (RCX) to store 0x11 0000000140001029 E8 D2 FF FF FF call func (0140001000h) 000000014000102E 48 83 C4 28 add rsp,28h 0000000140001032 C3 ret System V AMD64 ABI (Linux, macOS) First 6 integer arguments: RDI, RSI, RDX, RCX, R8, R9 First 8 float arguments: XMM0 through XMM7 Additional arguments: Passed on the stack Return value: RAX (RDX:RAX) for integers, XMM0 for floats A compiler example is GCC. In general: Both caller and callee are responsible for balancing any register saves they perform (add to the stack), with restores (removal from the stack). Caller will typically save registers right before the call and restore right after the call and the callee will typically save registers at the beginning of the function and restore at the end of the function. 3. Shadow Store. Shadow store (also called home space or shadow space) is a Windows x64-specific feature by which the caller must allocate 32 bytes (4 × 8-byte slots) on the stack before calling a function, the space corresponds to 4 register-passed parameters. Then, the callee can optionally use this space to "spill" (save) those register values if needed. Is like a sort of a caller's "inverse"-stackframe for register-passed parameter to the callee exclusive of Microsoft x64 ABI calling-convention programs. The term 'inverse' refers to the fact that the shadow space is created first before the CALL of the callee in terms of instruction execution order and also is above his own stackframe (if it exists). This is, if a caller reserve a shadow space for a callee, then the callee access this space by going up in the stack (towards higher address), accessing the stack-context of the caller function (rbp+0x08), the stackframe would be created after the callee is invoked and everytime the callee wants to access his own stackframe he must go below the calleer in terms of stackdiagram (rbp-0x08) ┌─────────────────────────┐ Higher addresses │ │ │ Shadow space │ ← Callee accesses via [rsp+8], [rsp+10], etc. │ (caller allocated) │ Going UP (positive offsets) │ │ ├─────────────────────────┤ ← Return address pushed by CALL │ return addr │ ├─────────────────────────┤ ← rsp after CALL, before callee prologue │ │ │ Callee's own frame │ ← Callee accesses via [rsp-8] or [rbp-8] │ (locals, saved regs) │ Going DOWN (negative offsets) │ │ └─────────────────────────┘ Lower addresses 4. Instruction LEA. Load Effective Address. Consider the following C code: int main(int argc, char** argv) { int a; //reminder: atoi() converts an //ASCII string to an integer a = atoi(argv[1]); return 2 * argc + a; } This code declares a variable and then assigns to it a value passed by a command line argument and processed by atoi() (ASCII to Integer), which yields an integer from a provided string. Then returns 2 times the number of argumets passed through the command line to the program plus 'a'. Then, we have the following dissasembly through MCVS 2019: 0000000140001000 40 53 push rbx 0000000140001002 48 83 EC 20 sub rsp,20h 0000000140001006 8B D9 mov ebx,ecx 0000000140001008 48 8B 4A 08 mov rcx,qword ptr [rdx+8] 000000014000100C FF 15 66 31 00 00 call qword ptr [__imp_atoi (0140004178h)] 0000000140001012 8D 04 58 lea eax,[rax+rbx*2] 0000000140001015 48 83 C4 20 add rsp,20h 0000000140001019 5B pop rbx Is worth to note before enter to explain LEA, that the code above is importing dynamically atoi() function from &lt;stdlib.h&gt; and because of that is trying to access to atoi() by dereferencing an external address through '_imp' directive. Also, we could think that 0000000140001002 48 83 EC 20 sub rsp,20h Is the prologue to the stackframe, buit is not. Since a callee is about to be called by the main function (and this program follows MC x64 ABI calling-conventions) a shadow space for register-passed parameters needs to be allocated. The key to distinguish between is by context, if you look closer to the code: First, there is no need from stackframe since there is only one local variable (which also is never stored somepoint behind rbx) There is a callee and this is MC x64 ABI program so the rsp substraction needs to be the shadow space allocation Lets talk about LEA. Often, in assembly the brackets [] is a directive which tells the system to dereference which is inside as a memory address, but is not the case with LEA. With LEA an arithmeticv operation is gonna be pass to between brackets. LEA would solve that operation and then store that value in a register. For example, in our code there is the line: 0000000140001012 8D 04 58 lea eax,[rax+rbx*2] Which simply calculates "rax+rbx*2" and store that value on EAX. So it just moves the value within the brackets (it resolves an operation if proceeds) int]]></summary></entry><entry><title type="html">Stackframe; Local variables, Arrays and Structures.</title><link href="http://localhost:4000/posts/2025/12/01/LocalVars_Arrays_structs/" rel="alternate" type="text/html" title="Stackframe; Local variables, Arrays and Structures." /><published>2025-12-01T10:00:00+01:00</published><updated>2025-12-01T10:00:00+01:00</updated><id>http://localhost:4000/posts/2025/12/01/LocalVars_Arrays_structs</id><content type="html" xml:base="http://localhost:4000/posts/2025/12/01/LocalVars_Arrays_structs/"><![CDATA[<h3 id="1-defintion">1. Defintion.</h3>

<p>Let's consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">calculate</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">temp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">calculate</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We have a C code which returns a calculated value using a local function, <em>calculate()</em> which receives two parameters as data and then use their own local variables to calculate and return the value (temp, result).</p>

<p>So let's begin from the start. <strong>Local variables</strong> are temporary storage locations used within a function's scope. Unlike global variables stored in the DATA segment, local variables are allocated on the stack and automatically destroyed when the function returns. Examples of local variables in the code above are <em>result</em> declared an later assigned or <em>temp</em> directly defined both within <em>calculate()</em> function.</p>

<p><br /></p>

<h3 id="2-local-variales-in-assembly">2. Local variales in assembly.</h3>

<p>Let's see how local variables are treated in assembly. We know that there is a structure called the stack in which things like local variables are pushed as part of the context of called function. The own system expands the stack in order to allocate in a sort order the elements that the function needs to properly works along with other things (saved registers, parameters and the return address), this expansion is what we call the <em>function's stackframe</em>.</p>

<p>The traslation to assembly of the code above would be:</p>

<pre><code class="language-assem">calculate:
0000000140001000 push   rbp
0000000140001001 mov    rbp, rsp
0000000140001004 sub    rsp, 10h
0000000140001008 mov    DWORD PTR [rbp-4], ecx      ; parameter a
000000014000100B mov    DWORD PTR [rbp-8], edx      ; parameter b
000000014000100E mov    DWORD PTR [rbp-0Ch], 5      ; temp = 5
0000000140001015 mov    eax, DWORD PTR [rbp-4]      ; load a
0000000140001018 add    eax, DWORD PTR [rbp-8]      ; add b
000000014000101B add    eax, DWORD PTR [rbp-0Ch]    ; add temp
000000014000101E mov    DWORD PTR [rbp-10h], eax    ; result = ...
0000000140001021 mov    eax, DWORD PTR [rbp-10h]    ; return result
0000000140001024 add    rsp, 10h
0000000140001028 pop    rbp
0000000140001029 ret

main:
0000000140001030 push   rbp
0000000140001031 mov    rbp, rsp
0000000140001034 sub    rsp, 20h
0000000140001038 mov    ecx, 0Ah                    ; first argument: 10
000000014000103D mov    edx, 14h                    ; second argument: 20
0000000140001042 call   calculate (0140001000h)
0000000140001047 mov    DWORD PTR [rbp-4], eax      ; x = result
000000014000104A mov    eax, DWORD PTR [rbp-4]      ; return x
000000014000104D add    rsp, 20h
0000000140001051 pop    rbp
0000000140001052 ret
</code></pre>

<p>Where the RPI would contain the address 0000000140001030 at the start of the program (the main's address).</p>

<p><br /></p>

<h3 id="3-stack-frame-creation">3. Stack Frame Creation.</h3>

<h4 id="31-brief-warning">3.1. Brief warning.</h4>

<p>Is worth mention that the creation of a stack frame using RBP is an optional procedure that's primarily a compiler convention rather than a hardware requirement in oposition like for example RIP manipulation by CALL/RET.</p>

<p>Note that despite CALL/RET perform operations over RIP, this is a hardware requirement and is done automatically by the CPU, you will never see reflected in the code the lines:</p>

<pre><code class="language-assem">push RIP + jmp target (CALL)
pop RIP + jmp RIP (RET)
</code></pre>

<p>But, instead we will see how RSP and RBP special-purpouse pointers get manipulated allong the following procedure. This is done for easier debugging, simpler code generation o dynamic stack allocation.</p>

<p><br /></p>

<h4 id="32-process-explanation">3.2. Process explanation.</h4>

<h5 id="321-stackframe-creation-prologue">3.2.1. Stackframe Creation Prologue.</h5>

<p>First, lets see how the stackframe for the local function is created.</p>

<p>The code starts executing main function which is at: 0000000140001030, then the execution flow continues until <em>calculate()</em> is called. Then, the CALL instruction intervenes pushing 0000000140001047 onto the top of the stack and then introduces on RIP register the calculate function's address: 0000000140001000. (Remember that RIP contains the address of the next instruction to be executed, it basically controls the execution flows of the code)</p>

<p>Once the execution flow enters <em>calculate()</em> as a local function the creation of his stackframe in the stack begins:</p>

<pre><code class="language-assem">0000000140001000 push   rbp
0000000140001001 mov    rbp, rsp
0000000140001004 sub    rsp, 10h
</code></pre>

<p>Let's check carefully the register within the code above:</p>

<ul>
  <li>
    <p>RBP -&gt; Base Pointer, points to the base of the current stackframe. Serves as a stable reference point for accessing local variables and parameters.</p>
  </li>
  <li>
    <p>RSP -&gt; Stack Pointer, points to the top of the stack.</p>
  </li>
</ul>

<p>So, first, we save the current RBP (the address of the current stackframe) pushing it on the stack and place a new <em>base stackframe</em> by copying the current RSP value (the lowest address pushed on the stack) onto RBP. Lastly, we lowered the RSP value in order to build a secure margin to the function context. Essentially, since the stack grows toward lower address and RSP points to the top of the stack, substracting RSP we are expanding the stack (this, despite being counter-intuitive, is neccesary due to processor's execution patterns and the compiler's code generation needs).</p>

<pre><code class="language-assem">
High Memory (Stack grows downward ↓)

┌─────────────────────────────────────────┐
│                  ...                    │
├─────────────────────────────────────────┤
│  Return address to main                 │  Pushed by CALL
├─────────────────────────────────────────┤ ← RSP before prologue
│  Saved RBP (old frame pointer)          │  Pushed by: push rbp
├─────────────────────────────────────────┤ ← RBP (current frame base)
│  [rbp-4]:  parameter a (10)             │
├─────────────────────────────────────────┤
│  [rbp-8]:  parameter b (20)             │
├─────────────────────────────────────────┤
│  [rbp-0Ch]: temp (5)                    │
├─────────────────────────────────────────┤
│  [rbp-10h]: result (35)                 │
├─────────────────────────────────────────┤ ← RSP (current stack top)
│                  ...                    │

Low Memory
</code></pre>

<p>Note that local variables as well as paramters are accesed using "r/mX" notation.</p>

<p><br /></p>

<h5 id="322-accessing-local-variables-and-stackframe-epilogue">3.2.2. Accessing local variables and Stackframe epilogue.</h5>

<p>Now that a stackframe has being created, then the local variables and parameters of the function are alocated within this stackframe.</p>

<p>Those are accessed using the RBP base pointer plus an offset. Let's check that:</p>

<pre><code class="language-asem">0000000140001008 mov    DWORD PTR [rbp-4], ecx      ; parameter a
000000014000100B mov    DWORD PTR [rbp-8], edx      ; parameter b
000000014000100E mov    DWORD PTR [rbp-0Ch], 5      ; temp = 5
0000000140001015 mov    eax, DWORD PTR [rbp-4]      ; load a
0000000140001018 add    eax, DWORD PTR [rbp-8]      ; add b
000000014000101B add    eax, DWORD PTR [rbp-0Ch]    ; add temp
</code></pre>

<p>First, the parameters of the function which by default are in RCX, RDX, R8, R9 gets stored inside te stackframe:</p>

<pre><code class="language-assem">0000000140001008 mov    DWORD PTR [rbp-4], ecx      ; parameter a
000000014000100B mov    DWORD PTR [rbp-8], edx      ; parameter b
</code></pre>

<p>Note that we are copying the contents of ECX (RCX variant in 32-bits) into a memory region behind RBP, the DWORD PTR term is used to refer that [rbp-4] is holding 32-bits data, is necesary since in the code 64-bits and 32-bits registers are mixed.</p>

<p>Then, the local variables which are defined inside the function gets his value through an immediate:</p>

<pre><code class="language-assem">000000014000100E mov    DWORD PTR [rbp-0Ch], 5      ; temp = 5
</code></pre>

<p>Then, the operations with the function values are performed, since data-copy between memory address is not allowed, the values with which the operations are going to be made must be passed to a register:</p>

<pre><code class="language-assem">0000000140001015 mov    eax, DWORD PTR [rbp-4]      ; load a
</code></pre>

<p>Then, with the value in a register, the operation is performed and is stored in <em>result</em> local variable:</p>

<pre><code class="language-assem">0000000140001018 add    eax, DWORD PTR [rbp-8]      ; add b
000000014000101B add    eax, DWORD PTR [rbp-0Ch]    ; add temp
000000014000101E mov    DWORD PTR [rbp-10h], eax    ; result = ...
</code></pre>

<p>Then, some redundance is performed and the epilogue of the stackframe is performed.</p>

<pre><code class="language-assem">0000000140001021 mov    eax, DWORD PTR [rbp-10h]    ; return result
0000000140001024 add    rsp, 10h
0000000140001028 pop    rbp
0000000140001029 ret
</code></pre>

<p>Note than the stackframe epilogue only consist in lift the RSP the same amount of memory that were lowered in the prologue, there is no need to zeroed or clean the data since is enough to label the memory as unused to be reutilized again. The memory isn't actually "erased", it just becomes invalid/unreliable. The values might still be there until overwritten by the next function call.</p>

<p>The RET instruction is not part of the stackframe epilogue, is the counterpart of CALL and it pops out the next value on the stack on RIP register.</p>

<p><br /></p>

<h4 id="33-conclusion">3.3. Conclusion.</h4>

<p>A few points taht are worth to have in mind are:</p>

<ul>
  <li>
    <p>Stackframe mechanism allocates space for the local variables. Modern x86-64 calling conventions require the stack to be 16-byte aligned before a CALL instruction. This means RSP must be divisible by 16. The compiler often allocates more space than strictly needed to maintain this alignment.</p>
  </li>
  <li>
    <p>Local variables are accessed using negative offsets from RBP: [rbp-4], [rbp-8], etc. The allocation and deallocation of the stackframe guarantee that local variable lifetime gets extended till the function termination. Without it, the local variable lifetime would also terminates with the local function termination but in a more caotic way and with more imprecissions.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="4-array-as-a-local-variable-imul-movsxzx">4. Array as a local variable. Imul, Movsx/zx.</h3>

<p>Lets consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">short</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">short</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mh">0xbabe</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mh">0xbal</span><span class="n">b0abledbl100d</span><span class="p">;</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The dissassembly is as follows:</p>

<pre><code class="language-assem">0000000140001000  sub         rsp,38h  
0000000140001004  mov         eax,0FFFFBABEh  
0000000140001009  mov         word ptr [rsp],ax  
000000014000100D  mov         rax,0BA1B0AB1EDB100Dh  
0000000140001017  mov         qword ptr [c],rax  
000000014000101C  mov         eax,4  
0000000140001021  imul        rax,rax,1  
0000000140001025  movsx       ecx,word ptr [rsp]  
0000000140001029  mov         dword ptr b[rax],ecx  
000000014000102D  mov         eax,4  
0000000140001032  imul        rax,rax,1  
0000000140001036  movsxd      rax,dword ptr b[rax]  
000000014000103B  add         rax,qword ptr [c]  
0000000140001040  mov         ecx,4  
0000000140001045  imul        rcx,rcx,4  
0000000140001049  mov         dword ptr b[rcx],eax  
000000014000104D  mov         eax,4  
0000000140001052  imul        rax,rax,4  
0000000140001056  movzx       eax,word ptr b[rax]  
000000014000105B  add         rsp,38h  
000000014000105F  ret  
</code></pre>

<p>We can see that there are three new instructions, <em>imul</em>, <em>movsx</em>, <em>movzx</em>.</p>

<p><br /></p>

<h4 id="41-imul---signed-multiply">4.1. IMUL - Signed Multiply.</h4>

<p>This is an instruction that have three forms in base of the number of operands used with (one, two or three) and is the signed version of MUL (Unsigned Multiply). Let's start by the simplest form:</p>

<ul>
  <li>
    <p><em>Two-operands</em> form: This is the more intuitive or predictable of the three forms. It just and extrapolation of the ADD/SUB instructions to the multiplication. It multiplies the destination by the source and store the result in the operand:</p>

    <pre><code class="language-assem">  imul dest, source --&gt; dest = dest * source
</code></pre>

    <p>An example of usage can be:</p>

    <pre><code class="language-assem">  imul reg, r/mX
</code></pre>

    <p>Note that the operands cannot be two memory address at the same time.</p>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p><em>Three-operands</em> form; This is an extension of the two-operands form but with an inmmediate acting as a scale of the source. The result is stored in the destination operand which is left out the operation:</p>

    <pre><code class="language-assem">  imul dest, source, immediate --&gt; dest = source * immediate
</code></pre>

    <pre><code class="language-assem">  imul eax, ebx, 5 --&gt; eax = ebx * 5
</code></pre>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p><em>One-operand</em> form; In this case, IMUL gets reduced to an unary operation which gets the <em>two-operands</em> form using AX/EAX/RAX register as destination everytime.</p>

    <p>This is more complicated than what appears at first time, because multiply data often results in a size much larger than the size of the operands involved in the multiplication. Let's see an example:</p>

    <pre><code class="language-assem">  imul r/m8
</code></pre>

    <p>This operation is multiplying an 8-bit size by an 8-bit size generating a value that occupies 16-bit as maximum, lets do the maths:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Maximum 8-bit value = 0b11111111 = 255
  Maximum 8^2-bit value =  255^2 = 65,025 &lt; 65,535 = 0b1111111111111111 = Maximum 16-bit value
</code></pre></div>    </div>

    <p><strong>The general rule: multiplying an N-bit number by an N-bit number produces at most a 2N-bit result.</strong></p>

    <p>This essentially means that if we try to save the value in an 8-bit register like AL, the assembly operation would result in a truncated value.</p>

    <p>So the solution, if the result of the operation cares, is in the majority of the cases to concatenate registers and store half of the bytes in one register and the other half in the other one. In the case of an 8-bit operation, remember that, in this case: AX = AH:AL –&gt; AX is the concatenation of AH (the most significant byte) and AL (the less significant byte)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  | &lt;-- AX (16 bits) -&gt; |
      AH (8) | AL (8)
</code></pre></div>    </div>

    <p>So, the operation would result in:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  imul r/m8 --&gt; AX = AH:AL = AL * r/m8
</code></pre></div>    </div>

    <p>The same would apply to other widths:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  | Form | Operation | Result location |
  |------|-----------|-----------------|
  | IMUL r/m8 | AL × operand | AX = AH:AL (16-bit) |
  | IMUL r/m16 | AX × operand | DX:AX (32-bit) |
  | IMUL r/m32 | EAX × operand | EDX:EAX (64-bit) |
  | IMUL r/m64 | RAX × operand | RDX:RAX (128-bit) |
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>This truncation mechanism only applies to the unary form of IMUL, in the binary o triary form truncation can happens.</strong></p>

<p><br /></p>

<h4 id="42-movzx-movsx---move-with-zerosign-extend">4.2. MOVZX, MOVSX - Move with zero/sign extend.</h4>

<p>This instructions move data from smaller register to a larger one and are very important when C performs a type conversion:</p>

<p><br /></p>

<p><strong>MOVZX (Move with Zeri Extend)</strong></p>

<ul>
  <li>Copies a smaller value to a larger destination</li>
  <li>Fills the upper bits with zeros</li>
  <li>Used for unsigned values</li>
  <li>Preserves the numeric value for unsigned integers</li>
</ul>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOVZX dest, source
</code></pre></div></div>

<p>An example of usage could be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOV AL, 0xFF        ; AL = 11111111b (255)
MOVZX EAX, AL       ; EAX = 00000000 00000000 00000000 11111111b (255)
</code></pre></div></div>

<p><br /></p>

<p><strong>MOVSX (Move with Sign Extend)</strong></p>

<ul>
  <li>Copies a smaller value to a larger destination</li>
  <li>Fills the upper bits by repeating the sign bit (MSB)</li>
  <li>Used for signed values (2's complement)</li>
  <li>Preserves the numeric value for signed integers</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOVSX dest, source
</code></pre></div></div>

<p>As an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOV AL, 0xFF        ; AL = 11111111b (-1 in signed)
MOVSX EAX, AL       ; EAX = 11111111 11111111 11111111 11111111b (-1)

MOV BL, 0x7F        ; BL = 01111111b (+127 in signed)
MOVSX EBX, BL       ; EBX = 00000000 00000000 00000000 01111111b (+127)
</code></pre></div></div>

<p><br /></p>

<p><strong>Explanation of the use of each instruction</strong></p>

<p>Then, for example, if we have a C code and we assign a <em>short</em> to a wider value like an <em>unsigned integer</em>, then we don't just use MOV, since that would preserve the size, we use MOVZX to convert the value to a positive size-extended version of it self (2 bytes –&gt; 4 bytes):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">;</span> <span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
<span class="n">mov</span>     <span class="n">word</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">10</span><span class="n">h</span><span class="p">],</span> <span class="mi">0</span><span class="n">FFFBh</span>    <span class="p">;</span> <span class="o">-</span><span class="mi">5</span> <span class="n">in</span> <span class="n">twos</span> <span class="nf">complement</span> <span class="p">(</span><span class="mi">16</span><span class="o">-</span><span class="n">bit</span><span class="p">)</span>

<span class="p">;</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">s</span>
<span class="n">movsx</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">10</span><span class="n">h</span><span class="p">]</span>       <span class="p">;</span> <span class="n">sign</span><span class="o">-</span><span class="n">extend</span> <span class="n">to</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span><span class="o">:</span> <span class="mh">0xFFFFFFFB</span>
<span class="n">mov</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">14</span><span class="n">h</span><span class="p">],</span> <span class="n">eax</span>      <span class="p">;</span> <span class="n">store</span> <span class="n">as</span> <span class="nf">unsigned</span> <span class="p">(</span><span class="n">interprets</span> <span class="n">as</span> <span class="mi">4294967291</span><span class="p">)</span>

<span class="p">;</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span>
<span class="n">movsx</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">10</span><span class="n">h</span><span class="p">]</span>       <span class="p">;</span> <span class="n">sign</span><span class="o">-</span><span class="n">extend</span> <span class="n">to</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span><span class="o">:</span> <span class="mh">0xFFFFFFFB</span>
<span class="n">mov</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">18</span><span class="n">h</span><span class="p">],</span> <span class="n">eax</span>      <span class="p">;</span> <span class="n">store</span> <span class="n">as</span> <span class="kt">signed</span> <span class="p">(</span><span class="n">interprets</span> <span class="n">as</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>If instead we assign to a <em>signed integer</em>, then we use MOVSX in order to extend the size of the value preserving the sign (or giving a sign if wasn't there before).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">;</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">us</span> <span class="o">=</span> <span class="mi">65531</span>
<span class="n">mov</span>     <span class="n">word</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">10</span><span class="n">h</span><span class="p">],</span> <span class="mi">0</span><span class="n">FFFBh</span>

<span class="p">;</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">us</span>
<span class="n">movzx</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">10</span><span class="n">h</span><span class="p">]</span>       <span class="p">;</span> <span class="n">zero</span><span class="o">-</span><span class="n">extend</span><span class="o">:</span> <span class="mh">0x0000FFFB</span> <span class="p">(</span><span class="mi">65531</span><span class="p">)</span>
<span class="n">mov</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">14</span><span class="n">h</span><span class="p">],</span> <span class="n">eax</span>

<span class="p">;</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">us</span>
<span class="n">movzx</span>   <span class="n">eax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">10</span><span class="n">h</span><span class="p">]</span>       <span class="p">;</span> <span class="n">zero</span><span class="o">-</span><span class="n">extend</span><span class="o">:</span> <span class="mh">0x0000FFFB</span> <span class="p">(</span><span class="mi">65531</span><span class="p">)</span>
<span class="n">mov</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">18</span><span class="n">h</span><span class="p">],</span> <span class="n">eax</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="43-understanding-arrays-in-assembly">4.3. Understanding arrays in assembly.</h4>

<p>Now that we understood IMUL, MOVSX and MOVZX instructions, we can introduce how assembly handles array structures.</p>

<p>Local variables gets accesed via directs stack offsets using RBP register as we see in previous examples. This is possible since the compiler knows the exact location of a local variable since this are defined (this is, they get a value) within the function.</p>

<p>How ever, a value within an array takes other perspective, lets consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set_element</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>On it, <em>i</em> is an unknown variable from the compiler perspective and thus it can't assign value parameter to a specific memory address as if were a local variable instead, it have to make that assignation dependant on the value of <em>i</em> which gets defined at runtime.</p>

<p>The formula is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base_array_address + (index × element_size)
</code></pre></div></div>

<p>Note that, an array is nothing but a linear chunk of memory, we need to multiply the index by the scale of the datatype in order to map the address in which the slot denoted by the index is in the stack. The later addition with 'base_array_address' is just an ordinary way to find an address thorough 'pointer + offset'</p>

<p>And it applies at every array, note that in the example provide in the code above (presented again just below), the array assignation is everytime through constants (known by the compiler) so in fact the compiler knows the offset to access that specific memory address and it could accessed through stack offsets but it doesn't because the standadrd method is what is explained above.</p>

<p>So, let's see how this formula is implemented in assembly when an array is presented.</p>

<p>Consider the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="n">buff</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code declares an array of chars of 10 slots, and a local variable then it performes an assignation and then returns. Note that arrays gets allocated in the stack despite the uses of them; stackframe expands enough to hold every declaration inside the function.</p>

<p>Consider the following disassembly:</p>

<pre><code class="language-assem">0000000140001000 48 83 EC 28          sub         rsp,28h  
0000000140001004 C6 04 24 41          mov         byte ptr [rsp],41h  
0000000140001008 B8 01 00 00 00       mov         eax,1  
000000014000100D 48 6B C0 05          imul        rax,rax,5  
0000000140001011 0F B6 0C 24          movzx       ecx,byte ptr [rsp]  
0000000140001015 88 4C 04 08          mov         byte ptr buff[rax],cl  
0000000140001019 33 C0                xor         eax,eax  
000000014000101B 48 83 C4 28          add         rsp,28h  
000000014000101F C3                   ret 
</code></pre>

<p>In order to be able to apply the formula mentioned above, we need first to calculate index address, which is performed in the following instruction:</p>

<pre><code class="language-assem">0000000140001008 B8 01 00 00 00       mov         eax,1 //Copy the size of the datatype (this time, char = 1) on the rax register.
000000014000100D 48 6B C0 05          imul        rax,rax,5 //Then perform the multiplication using imul with rax register and the index; 5.
</code></pre>

<p>Now RAX register contains the offset (5) to be used along with the base address of the buffer. There is no ADD instruction since the processor already perform automatically that addition when perform the memory access, it just calculates de offset, stored it in RAX and then uses RAX in the following instruction:</p>

<pre><code class="language-assem">0000000140001011 0F B6 0C 24          movzx       ecx,byte ptr [rsp]  
0000000140001015 88 4C 04 08          mov         byte ptr buff[rax],cl
</code></pre>

<p>Which is accesssing that offset from the base_address of the buffer (buff), when accesing that memory address, copy the byte <em>cl</em> and then goes on.</p>

<p>The <em>buff</em> is addressing mode, is resolved by the disassembler to mean "rsp + 0x8 + rax" (rsp + 0x8 is where the buffer starts on the stack). The full address computation would be:</p>

<pre><code class="language-assem">rsp + 0x8 + rax == [rsp + 0x8] + (5 * 1)
</code></pre>

<p>satisfying the equation mentioned above.</p>

<p>Also, is convenient to say that the code above is MCVS being extraordinary unefficient. Moder compilers like gcc would resolve the memory access to the <em>buff</em> as if were a local variable since the index is hardcoded and the compiler knows at compile-time what that index is so there's no need to implement IMUL operations and make the assignation dependant on an unknown variable.</p>

<p>If we compile the code above with gcc and open it with radare2 we would get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ r2 -e asm.sub.var=false -A -qc "s main; pdf" test
Warning: run r2 with -e bin.cache=true to fix relocations in disassembly
            ; DATA XREF from entry0 @ 0x1078
┌ 65: int main (int argc, char **argv, char **envp);
│           ; var int64_t var_13h @ rbp-0x13
│           ; var int64_t var_dh @ rbp-0xd
│           ; var int64_t var_8h @ rbp-0x8
│           0x00001149      f30f1efa       endbr64                               ; Intel CET Instruction
│           0x0000114d      55             push rbp                              ; Stackframe prologue
│           0x0000114e      4889e5         mov rbp, rsp
│           0x00001151      4883ec20       sub rsp, 0x20
│           0x00001155      64488b042528.  mov rax, qword fs:[0x28]              ; Stack canary (BOF security measure)
│           0x0000115e      488945f8       mov qword [rbp - 8], rax              
│           0x00001162      31c0           xor eax, eax
│           0x00001164      c645ed41       mov byte [rbp - 0x13], 0x41 ; 'A'     ; char a = 'A'
│           0x00001168      0fb645ed       movzx eax, byte [rbp - 0x13]          ; buff[5] = a;
│           0x0000116c      8845f3         mov byte [rbp - 0xd], al
│           0x0000116f      b800000000     mov eax, 0                            ; return 0
│           0x00001174      488b55f8       mov rdx, qword [rbp - 8]              ; Check stack canary
│           0x00001178      64482b142528.  sub rdx, qword fs:[0x28]
│       ┌─&lt; 0x00001181      7405           je 0x1188
│       │   0x00001183      e8c8feffff     call sym.imp.__stack_chk_fail
│       │   ; CODE XREF from main @ 0x1181
│       └─&gt; 0x00001188      c9             leave
└           0x00001189      c3             ret      
</code></pre></div></div>

<p>As we can see, since the index is hardcode, the compiler already knows where is the referenced slot of the array exists in the stack:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x00001168      0fb645ed       movzx eax, byte [rbp - 0x13]
0x0000116c      8845f3         mov byte [rbp - 0xd], al
</code></pre></div></div>

<p>So, in conclusion, both forms of handle arrays exists and are completely valid.</p>

<p><br /></p>

<h3 id="5-struct-local-variable">5. Struct Local Variable.</h3>

<p>Like <em>arrays</em>, <em>structs</em> in C are linear memory regions which are accesibles due to offset arithmetics but containing different datatypes elements.</p>

<p>An important concept on how the compiler deals with the allocation of memory for a structure is the <em>memory alignment principle</em> which leaks in <em>structure padding</em>.</p>

<p><br /></p>

<h4 id="51-mermoy-alignment-principle">5.1. Mermoy Alignment Principle.</h4>

<p>Memory alignment refers to how data is positioned in memory relative to addresses that are multiples of certain values (typically powers of 2).</p>

<p>The fundamental reason is architectural and we already ass through it; CPUs access and work data through some special integrated devices called <em>registers</em> which have the width of a <em>word</em> (8 bytes in x64 architectures), it don't fetch memory byte-by-byte. This mean that in a CPU cycle, the CPU reach exactly 8 bytes of data. So, consider the following example.</p>

<p>Let's suppouse we have 16 byes of data, this corresponds to two CPU cycles, this means, it takes (ideally) two times to the CPU to read the data stored in those bytes, then let's suppose we have a long integer (8 bytes) occuping the half of thos 16 bytes, 4 in one octet and 4 in other octet. In order to be able to read the long the CPU would need two times instead of the minimum required per the size of the data type:</p>

<p><br /></p>

<p>MEMORY LAYOUT: MISALIGNED LONG (8 bytes spanning two octets)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                ┌───────────────────────────────────────────────────────────────┐
                │                      16 BYTES OF MEMORY                       │
                ├───────────────────────────────┬───────────────────────────────┤
                │         FIRST OCTET           │        SECOND OCTET           │
                │    (CPU Cycle 1 - 8 bytes)    │   (CPU Cycle 2 - 8 bytes)     │
                ├───┬───┬───┬───┬───┬───┬───┬───┼───┬───┬───┬───┬───┬───┬───┬───┤
                │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │11 │12 │13 │14 │15 │
                ├───┴───┴───┴───┼───┴───┴───┴───┴───┴───┴───┴───┼───┴───┴───┴───┤
                │   (unused)    │◄──────── LONG (8 bytes) ─────►│   (unused)    │
                │   4 bytes     │     4 bytes   │    4 bytes    │    4 bytes    │
                └───────────────┴───────────────┴───────────────┴───────────────┘
                                                ▲
                                                │
                                    OCTET BOUNDARY (address 0x08)


                PROBLEM: To read the misaligned LONG, the CPU must:

                    ┌─────────────────┐         ┌─────────────────┐
                    │   CPU Cycle 1   │         │   CPU Cycle 2   │
                    │  Fetch bytes    │         │  Fetch bytes    │
                    │    0x00-0x07    │         │    0x08-0x0F    │
                    │                 │         │                 │
                    │  Extract bytes  │         │  Extract bytes  │
                    │    4, 5, 6, 7   │         │   8, 9, 10, 11  │
                    └────────┬────────┘         └────────┬────────┘
                            │                           │
                            └───────────┬───────────────┘
                                        ▼
                            ┌───────────────────────┐
                            │  Combine fragments    │
                            │  into complete LONG   │
                            └───────────────────────┘

            RESULT: 2 CPU cycles for data that should require only 1
</code></pre></div></div>

<p><br /></p>

<p>This is extremely inefficient, the solution: force the data storage to start in a multiple of a word's address.</p>

<p>Thus, if we know for example have two integers (4 bytes each) and a char intercalates between each integer, then the data in memory would be stored following the memory allignment principle:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ┌───────────────────────────────────────────────────────────────┐
            │                      16 BYTES OF MEMORY                       │
            ├───────────────────────────────┬───────────────────────────────┤
            │         FIRST WORD            │         SECOND WORD           │
            │         (8 bytes)             │          (8 bytes)            │
            ├───┬───┬───┬───┬───┬───┬───┬───┼───┬───┬───┬───┬───┬───┬───┬───┤
            │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │11 │12 │13 │14 │15 │
            ├───┴───┴───┴───┼───┼───┴───┴───┼───┴───┴───┴───┼───┴───┴───┴───┤
            │◄─ int a ─────►│ c │◄── gap ──►│◄─── int b ───►│  (available)  │
            │    4 bytes    │(1)│  3 bytes  │    4 bytes    │    4 bytes    │
            └───────────────┴───┴───────────┴───────────────┴───────────────┘
                                            ▲
                                            │
                            WORD BOUNDARY (address 0x08)
</code></pre></div></div>

<p>Observe two things:</p>

<ul>
  <li>
    <p>First, te char datatype is inside the first chunk because, per its size, the value fits in the gap leaved by the integer before inside the first word. This means that allignment don't force every data value to be stored in a brand new 8-multiple-address-start octet, just those data values that don't fit in the gap leave by other data stored before. This is the case of integer b (4 bytes can't be stored on a 3-bytes gap) so it corresponds to be stored in a new correspondly alligned octet.</p>
  </li>
  <li>
    <p>There exists unused bytes in memory (in our case, 5, 6 and 7) which corresponds to those bytes that fills gaps between alligned datatypes. Since memory has a linear nature, this bytes are lost and will never be reused until memory gets released more likely when program terminates most of the time.</p>
  </li>
</ul>

<p>Since the two reasons above, the rule gets slitly changed to a more efficient approach: <em>a data type should be stored at an address that's a multiple of its own size</em>. A 4-byte int at multiples of 4, an 8-byte long at multiples of 8, a 2-byte short at multiples of 2, and a 1-byte char anywhere (since every address is a multiple of 1). This is what we call <em>memory principle allignment</em>, and guarantee no data value gets stored between two CPU cycles.</p>

<p><br /></p>

<h4 id="52-structure-padding">5.2. Structure Padding.</h4>

<p>The <em>memory alignment principle</em> applies every time data is stored in memory however some C entities does not seems to be affected, local variables or arrays are some examples. Arrays are linear memory regions reserved for same datatype values, then a fixed-size array of a specific datatype will always occupies the same, and barely equal for local variables.</p>

<p>However, there is a problem when we talk about structures. We know that the size of a structure is the addition of the size of the fields that composes the struct.</p>

<p>So if we get the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">my_struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span> <span class="n">struct_1</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">struct_1</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"This struct is %ld bytes width"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">foo</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We should spect that the output would be something like:</p>

<pre><code class="language-less">OUTPUT:

    This struct is 9 bytes width

</code></pre>

<p>But if we compile the code and check the result we will find out that is not, the actual size is 12. This is because we are no taking in consideration the unsued 3 left bytes between the char and the second integer due to memory alignment. The real count is:</p>

<pre><code class="language-less">int a + char b + unused bytes + int c = 4 + 1 + 3 + 4 = 12
</code></pre>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                12 BYTES OF STRUCTURE MEMORY

    ├───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐               
    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │11 │               
    ├───┴───┴───┴───┼───┼───┴───┴───┼───┴───┴───┴───┤               
    │◄─── int a ───►│ b │◄─padding─►│◄─── int c ───►│               
    │    4 bytes    │(1)│  3 bytes  │    4 bytes    │               
    └───────────────┴───┴───────────┴───────────────┘               
                        ▲           ▲                               
                        │           │                               
                  offset 4      offset 8                            
                (4 % 1 = 0 ✓)  (8 % 4 = 0 ✓)                       
    ──────────────────────────────────────────────────
</code></pre></div></div>

<p>This effect is known as <em>structure padding</em>, when a C compiler automatically inserts extra bytes into a struct to align its members in memory.</p>

<p>Structure padding is a consecuence of the memory allignement and actually exists beyond structures, it affects on how memory gets alloced along a linear region in a huge amount of posibles combinations (nested structures, structures with arrays, arrays of structures, etc).</p>

<p><br /></p>

<h4 id="53-structures-dissasembly">5.3. Structures Dissasembly.</h4>

<p>Consider the following C code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">mystruct</span> <span class="p">{</span>
    <span class="kt">short</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mystruct_t</span><span class="p">;</span>

<span class="kt">short</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mystruct_t</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mh">0xbabe</span><span class="p">;</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="mh">0xba1b0ab1edb100d</span><span class="p">;</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">foo</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This C code defines an structure with several datatypes including an array. This the memory layout of this structure is:</p>

<p>-&gt; 2 bytes for short a
-&gt; 2 bytes for padding
-&gt; 4*6 contiguous bytes for each array entry
-&gt; 4 bytes for padding (since 24 mod 8 = 0 but array started in non-aligned address)
-&gt; 8 bytes (word) for long long c</p>

<p>In total, 40 bytes, note that the stackframe expands 0x38, which is enough for the structure.</p>

<p>If we compile the code in MCVS 2019, we obtain the following dissasembly:</p>

<pre><code class="language-less">0000000140001000 48 83 EC 38          sub         rsp,38h  
0000000140001004 B8 BE BA FF FF       mov         eax,0FFFFBABEh  
0000000140001009 66 89 04 24          mov         word ptr [rsp],ax  
000000014000100D 48 B8 0D 10 DB 1E AB B0 A1 0B mov         rax,0BA1B0AB1EDB100Dh  
0000000140001017 48 89 44 24 20       mov         qword ptr [rsp+20h],rax  
000000014000101C B8 04 00 00 00       mov         eax,4  
0000000140001021 48 6B C0 01          imul        rax,rax,1  
0000000140001025 0F BF 0C 24          movsx       ecx,word ptr [rsp]  
0000000140001029 89 4C 04 04          mov         dword ptr [rsp+rax+4],ecx  
000000014000102D B8 04 00 00 00       mov         eax,4  
0000000140001032 48 6B C0 01          imul        rax,rax,1  
0000000140001036 48 63 44 04 04       movsxd      rax,dword ptr [rsp+rax+4]  
000000014000103B 48 03 44 24 20       add         rax,qword ptr [rsp+20h]  
0000000140001040 B9 04 00 00 00       mov         ecx,4  
0000000140001045 48 6B C9 04          imul        rcx,rcx,4  
0000000140001049 89 44 0C 04          mov         dword ptr [rsp+rcx+4],eax  
000000014000104D B8 04 00 00 00       mov         eax,4  
0000000140001052 48 6B C0 04          imul        rax,rax,4  
0000000140001056 0F B7 44 04 04       movzx       eax,word ptr [rsp+rax+4]  
000000014000105B 48 83 C4 38          add         rsp,38h  
000000014000105F C3                   ret  
</code></pre>

<p>Now, lets read the assembly code:</p>

<ul>
  <li>
    <p>First, the stackframe prologue:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  sub         rsp,38h 
</code></pre></div>    </div>
  </li>
  <li>
    <p>Asignations and operations:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">foo</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mh">0xbabe</span><span class="p">;</span>
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0000000140001004 B8 BE BA FF FF       mov         eax,0FFFFBABEh  
  0000000140001009 66 89 04 24          mov         word ptr [rsp],ax
</code></pre></div>    </div>

    <p>First, the value "0FFFFBABEh" gets writted to eax, then 'ax' (the lower 16 bits of rax) are written to the left word of the contents of rsp. Remember that rsp points to the top of the stack, this means that the alocation in the stack has been done in opposite direction of the definition in the structure.</p>

    <p><br /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">foo</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="mh">0xba1b0ab1edb100d</span><span class="p">;</span>
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  000000014000100D 48 B8 0D 10 DB 1E AB B0 A1 0B   mov         rax,0BA1B0AB1EDB100Dh  
  0000000140001017 48 89 44 24 20                  mov         qword ptr [rsp+20h],rax  
</code></pre></div>    </div>

    <p>Then, the value "0BA1B0AB1EDB100Dh" gets stored and rax and then, on 'rsp + 0x20'. Let's do some counts here: 0x20 = 2*16^1 + 0*16^0 = 32 bytes, this would not be possible if there was no padding, since the teorically distant between those two fields is 28 bytes (24 + 4).</p>

    <p><br /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  000000014000101C B8 04 00 00 00       mov         eax,4  
  0000000140001021 48 6B C0 01          imul        rax,rax,1  
  0000000140001025 0F BF 0C 24          movsx       ecx,word ptr [rsp]  
  0000000140001029 89 4C 04 04          mov         dword ptr [rsp+rax+4],ecx  
</code></pre></div>    </div>

    <p>As we see in the array part, MCSV uses the IMUL method to calculate the offset throught the index and the datatype size and then solves 'base_address + index*element_size' (rsp+rax+4). Then it gets the value from rsp (a) and copy it on the rsp+rax+4 address.</p>

    <p>Note also that with this assignation, we are converting a <em>short</em> (a) to a <em>signed integer</em>, thus, when "rsp" is copied to "ecx" to later be copied to "rsp + rax + 4", MOVSX is being used in order to give the value a sign (if it was an unsigned int, MOVZX would be used instead).</p>

    <p><br /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">foo</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  000000014000102D B8 04 00 00 00       mov         eax,4  
  0000000140001032 48 6B C0 01          imul        rax,rax,1  
  0000000140001036 48 63 44 04 04       movsxd      rax,dword ptr [rsp+rax+4]  
  000000014000103B 48 03 44 24 20       add         rax,qword ptr [rsp+20h]  
  0000000140001040 B9 04 00 00 00       mov         ecx,4  
  0000000140001045 48 6B C9 04          imul        rcx,rcx,4  
  0000000140001049 89 44 0C 04          mov         dword ptr [rsp+rcx+4],eax 
</code></pre></div>    </div>

    <p>First, fetch "foo.b[1]" and stores its value in rax, then gets "foo.c" and adds that value to rax, now rax contains "foo.b[1] + foo.c" and this value gets stored on fourth slot of the array.</p>

    <p><br /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">return</span> <span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0000000140001056 0F B7 44 04 04       movzx       eax,word ptr [rsp+rax+4]  
  000000014000105B 48 83 C4 38          add         rsp,38h    ; Stackframe epilogue
  000000014000105F C3                   ret 
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="6-instruction-exercises">6. Instruction exercises.</h3>

<h4 id="61-movzx-exercises">6.1. MOVZX exercises</h4>

<p>What value is in r14 after this code executes?</p>

<pre><code class="language-assem">mov r12, 0x5B542050674CD692
movzx r14, r12b
</code></pre>

<p>First, "0x5B542050674CD692" value gets copied over r12, then r12b gets copied over r14. r12b is accessing the lowest byte of r12 register which is 0x92, copying onto r14 and zeroing the rest of uppers bytes, so r14 has 0x0000000000000092 value.</p>

<p><br /></p>

<p>What value is in r12w after this code executes?</p>

<pre><code class="language-assem">mov di, 0x4B39
mov r13w, 0x6396
movzx r12w, r13b
</code></pre>

<p>Then, it moves 2-bytes hexadecimal value to r13w which is the 16 lowest bits of r13 register, then moves the lowest byte of r13, which is 0x96, to the 16 lowest bits of r12 and zeroup the rest of bytes of the 16 bits within r12w. So de answer would be 0x0096</p>

<p><br /></p>

<p>What value is in rdx after this code executes?</p>

<pre><code class="language-assem">mov rdi, 0xBCE7AA1E4633FA15
add rdi, 0x4375165316635F7B
movzx rdx, dil
</code></pre>

<p>dil the lower byte of rdi has 0x90.</p>

<p><br /></p>

<h4 id="62-movsx-exercises">6.2. MOVSX exercises.</h4>

<p>What value is in esi after this code executes?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov rsp, 0xA440031B065793D1
movsx esi, sp
</code></pre></div></div>

<p>The first instruction moves 0xA440031B065793D1 over rsp. Then, moves with sign extension sp, which is the 16 lowest bits of rsp, to esi.</p>

<p>MOVSX is an isntruction that oneup or zeroup depending of the sign of the value. So first, we have to tell if the value is positive or negative:</p>

<pre><code class="language-assem">rsp (64 bits) --&gt; 0xA440031B065793D1; sp (16 bits) --&gt; 0x93D1 --&gt; 0b1001001111010001
</code></pre>

<p>Per the first byte convention, the value is negative and this means that this value would be extended like follows:</p>

<pre><code class="language-assem">sp --&gt; 0b1001001111010001 MOVSX esi --&gt; 0b1111111111111111001001111010001 -&gt; 0xFFFF93D1
</code></pre>

<p><br /></p>

<p>What value is in r10 after this code executes?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov r10d, 0x67C1ABD2
mov r8d, 0x7CBE1AFF
movsxd r10, r8d
</code></pre></div></div>

<p>As we did before, r8d contents (doubleword is double of a word, 32-bits) is being moved with sign extension to r10, so first lets check the sign converting it to binary:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x7CBE1AFF --&gt; 0b01111100101111100001101011111111
</code></pre></div></div>

<p>thus, the value is positive an the value in r10 must be zero-extended:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r10 --&gt; 0x000000007CBE1AFF
</code></pre></div></div>]]></content><author><name>German Sanmi</name></author><category term="Past Blogs" /><category term="Assembly" /><category term="x86" /><category term="reverse-engineering" /><summary type="html"><![CDATA[1. Defintion. Let's consider the following code: int calculate(int a, int b) { int result; int temp = 5; result = a + b + temp; return result; } int main() { int x = calculate(10, 20); return x; } We have a C code which returns a calculated value using a local function, calculate() which receives two parameters as data and then use their own local variables to calculate and return the value (temp, result). So let's begin from the start. Local variables are temporary storage locations used within a function's scope. Unlike global variables stored in the DATA segment, local variables are allocated on the stack and automatically destroyed when the function returns. Examples of local variables in the code above are result declared an later assigned or temp directly defined both within calculate() function. 2. Local variales in assembly. Let's see how local variables are treated in assembly. We know that there is a structure called the stack in which things like local variables are pushed as part of the context of called function. The own system expands the stack in order to allocate in a sort order the elements that the function needs to properly works along with other things (saved registers, parameters and the return address), this expansion is what we call the function's stackframe. The traslation to assembly of the code above would be: calculate: 0000000140001000 push rbp 0000000140001001 mov rbp, rsp 0000000140001004 sub rsp, 10h 0000000140001008 mov DWORD PTR [rbp-4], ecx ; parameter a 000000014000100B mov DWORD PTR [rbp-8], edx ; parameter b 000000014000100E mov DWORD PTR [rbp-0Ch], 5 ; temp = 5 0000000140001015 mov eax, DWORD PTR [rbp-4] ; load a 0000000140001018 add eax, DWORD PTR [rbp-8] ; add b 000000014000101B add eax, DWORD PTR [rbp-0Ch] ; add temp 000000014000101E mov DWORD PTR [rbp-10h], eax ; result = ... 0000000140001021 mov eax, DWORD PTR [rbp-10h] ; return result 0000000140001024 add rsp, 10h 0000000140001028 pop rbp 0000000140001029 ret main: 0000000140001030 push rbp 0000000140001031 mov rbp, rsp 0000000140001034 sub rsp, 20h 0000000140001038 mov ecx, 0Ah ; first argument: 10 000000014000103D mov edx, 14h ; second argument: 20 0000000140001042 call calculate (0140001000h) 0000000140001047 mov DWORD PTR [rbp-4], eax ; x = result 000000014000104A mov eax, DWORD PTR [rbp-4] ; return x 000000014000104D add rsp, 20h 0000000140001051 pop rbp 0000000140001052 ret Where the RPI would contain the address 0000000140001030 at the start of the program (the main's address). 3. Stack Frame Creation. 3.1. Brief warning. Is worth mention that the creation of a stack frame using RBP is an optional procedure that's primarily a compiler convention rather than a hardware requirement in oposition like for example RIP manipulation by CALL/RET. Note that despite CALL/RET perform operations over RIP, this is a hardware requirement and is done automatically by the CPU, you will never see reflected in the code the lines: push RIP + jmp target (CALL) pop RIP + jmp RIP (RET) But, instead we will see how RSP and RBP special-purpouse pointers get manipulated allong the following procedure. This is done for easier debugging, simpler code generation o dynamic stack allocation. 3.2. Process explanation. 3.2.1. Stackframe Creation Prologue. First, lets see how the stackframe for the local function is created. The code starts executing main function which is at: 0000000140001030, then the execution flow continues until calculate() is called. Then, the CALL instruction intervenes pushing 0000000140001047 onto the top of the stack and then introduces on RIP register the calculate function's address: 0000000140001000. (Remember that RIP contains the address of the next instruction to be executed, it basically controls the execution flows of the code) Once the execution flow enters calculate() as a local function the creation of his stackframe in the stack begins: 0000000140001000 push rbp 0000000140001001 mov rbp, rsp 0000000140001004 sub rsp, 10h Let's check carefully the register within the code above: RBP -&gt; Base Pointer, points to the base of the current stackframe. Serves as a stable reference point for accessing local variables and parameters. RSP -&gt; Stack Pointer, points to the top of the stack. So, first, we save the current RBP (the address of the current stackframe) pushing it on the stack and place a new base stackframe by copying the current RSP value (the lowest address pushed on the stack) onto RBP. Lastly, we lowered the RSP value in order to build a secure margin to the function context. Essentially, since the stack grows toward lower address and RSP points to the top of the stack, substracting RSP we are expanding the stack (this, despite being counter-intuitive, is neccesary due to processor's execution patterns and the compiler's code generation needs). High Memory (Stack grows downward ↓) ┌─────────────────────────────────────────┐ │ ... │ ├─────────────────────────────────────────┤ │ Return address to main │ Pushed by CALL ├─────────────────────────────────────────┤ ← RSP before prologue │ Saved RBP (old frame pointer) │ Pushed by: push rbp ├─────────────────────────────────────────┤ ← RBP (current frame base) │ [rbp-4]: parameter a (10) │ ├─────────────────────────────────────────┤ │ [rbp-8]: parameter b (20) │ ├─────────────────────────────────────────┤ │ [rbp-0Ch]: temp (5) │ ├─────────────────────────────────────────┤ │ [rbp-10h]: result (35) │ ├─────────────────────────────────────────┤ ← RSP (current stack top) │ ... │ Low Memory Note that local variables as well as paramters are accesed using "r/mX" notation. 3.2.2. Accessing local variables and Stackframe epilogue. Now that a stackframe has being created, then the local variables and parameters of the function are alocated within this stackframe. Those are accessed using the RBP base pointer plus an offset. Let's check that: 0000000140001008 mov DWORD PTR [rbp-4], ecx ; parameter a 000000014000100B mov DWORD PTR [rbp-8], edx ; parameter b 000000014000100E mov DWORD PTR [rbp-0Ch], 5 ; temp = 5 0000000140001015 mov eax, DWORD PTR [rbp-4] ; load a 0000000140001018 add eax, DWORD PTR [rbp-8] ; add b 000000014000101B add eax, DWORD PTR [rbp-0Ch] ; add temp First, the parameters of the function which by default are in RCX, RDX, R8, R9 gets stored inside te stackframe: 0000000140001008 mov DWORD PTR [rbp-4], ecx ; parameter a 000000014000100B mov DWORD PTR [rbp-8], edx ; parameter b Note that we are copying the contents of ECX (RCX variant in 32-bits) into a memory region behind RBP, the DWORD PTR term is used to refer that [rbp-4] is holding 32-bits data, is necesary since in the code 64-bits and 32-bits registers are mixed. Then, the local variables which are defined inside the function gets his value through an immediate: 000000014000100E mov DWORD PTR [rbp-0Ch], 5 ; temp = 5 Then, the operations with the function values are performed, since data-copy between memory address is not allowed, the values with which the operations are going to be made must be passed to a register: 0000000140001015 mov eax, DWORD PTR [rbp-4] ; load a Then, with the value in a register, the operation is performed and is stored in result local variable: 0000000140001018 add eax, DWORD PTR [rbp-8] ; add b 000000014000101B add eax, DWORD PTR [rbp-0Ch] ; add temp 000000014000101E mov DWORD PTR [rbp-10h], eax ; result = ... Then, some redundance is performed and the epilogue of the stackframe is performed. 0000000140001021 mov eax, DWORD PTR [rbp-10h] ; return result 0000000140001024 add rsp, 10h 0000000140001028 pop rbp 0000000140001029 ret Note than the stackframe epilogue only consist in lift the RSP the same amount of memory that were lowered in the prologue, there is no need to zeroed or clean the data since is enough to label the memory as unused to be reutilized again. The memory isn't actually "erased", it just becomes invalid/unreliable. The values might still be there until overwritten by the next function call. The RET instruction is not part of the stackframe epilogue, is the counterpart of CALL and it pops out the next value on the stack on RIP register. 3.3. Conclusion. A few points taht are worth to have in mind are: Stackframe mechanism allocates space for the local variables. Modern x86-64 calling conventions require the stack to be 16-byte aligned before a CALL instruction. This means RSP must be divisible by 16. The compiler often allocates more space than strictly needed to maintain this alignment. Local variables are accessed using negative offsets from RBP: [rbp-4], [rbp-8], etc. The allocation and deallocation of the stackframe guarantee that local variable lifetime gets extended till the function termination. Without it, the local variable lifetime would also terminates with the local function termination but in a more caotic way and with more imprecissions. 4. Array as a local variable. Imul, Movsx/zx. Lets consider the following C code: short main() { short a; int b[6]; long long c; a = 0xbabe; c = 0xbalb0abledbl100d; b[1] = a; b[4] = b [1] + c; return b[4]; } The dissassembly is as follows: 0000000140001000 sub rsp,38h 0000000140001004 mov eax,0FFFFBABEh 0000000140001009 mov word ptr [rsp],ax 000000014000100D mov rax,0BA1B0AB1EDB100Dh 0000000140001017 mov qword ptr [c],rax 000000014000101C mov eax,4 0000000140001021 imul rax,rax,1 0000000140001025 movsx ecx,word ptr [rsp] 0000000140001029 mov dword ptr b[rax],ecx 000000014000102D mov eax,4 0000000140001032 imul rax,rax,1 0000000140001036 movsxd rax,dword ptr b[rax] 000000014000103B add rax,qword ptr [c] 0000000140001040 mov ecx,4 0000000140001045 imul rcx,rcx,4 0000000140001049 mov dword ptr b[rcx],eax 000000014000104D mov eax,4 0000000140001052 imul rax,rax,4 0000000140001056 movzx eax,word ptr b[rax] 000000014000105B add rsp,38h 000000014000105F ret We can see that there are three new instructions, imul, movsx, movzx. 4.1. IMUL - Signed Multiply. This is an instruction that have three forms in base of the number of operands used with (one, two or three) and is the signed version of MUL (Unsigned Multiply). Let's start by the simplest form: Two-operands form: This is the more intuitive or predictable of the three forms. It just and extrapolation of the ADD/SUB instructions to the multiplication. It multiplies the destination by the source and store the result in the operand: imul dest, source --&gt; dest = dest * source An example of usage can be: imul reg, r/mX Note that the operands cannot be two memory address at the same time. Three-operands form; This is an extension of the two-operands form but with an inmmediate acting as a scale of the source. The result is stored in the destination operand which is left out the operation: imul dest, source, immediate --&gt; dest = source * immediate imul eax, ebx, 5 --&gt; eax = ebx * 5 One-operand form; In this case, IMUL gets reduced to an unary operation which gets the two-operands form using AX/EAX/RAX register as destination everytime. This is more complicated than what appears at first time, because multiply data often results in a size much larger than the size of the operands involved in the multiplication. Let's see an example: imul r/m8 This operation is multiplying an 8-bit size by an 8-bit size generating a value that occupies 16-bit as maximum, lets do the maths: Maximum 8-bit value = 0b11111111 = 255 Maximum 8^2-bit value = 255^2 = 65,025 &lt; 65,535 = 0b1111111111111111 = Maximum 16-bit value The general rule: multiplying an N-bit number by an N-bit number produces at most a 2N-bit result. This essentially means that if we try to save the value in an 8-bit register like AL, the assembly operation would result in a truncated value. So the solution, if the result of the operation cares, is in the majority of the cases to concatenate registers and store half of the bytes in one register and the other half in the other one. In the case of an 8-bit operation, remember that, in this case: AX = AH:AL –&gt; AX is the concatenation of AH (the most significant byte) and AL (the less significant byte) | &lt;-- AX (16 bits) -&gt; | AH (8) | AL (8) So, the operation would result in: imul r/m8 --&gt; AX = AH:AL = AL * r/m8 The same would apply to other widths: | Form | Operation | Result location | |------|-----------|-----------------| | IMUL r/m8 | AL × operand | AX = AH:AL (16-bit) | | IMUL r/m16 | AX × operand | DX:AX (32-bit) | | IMUL r/m32 | EAX × operand | EDX:EAX (64-bit) | | IMUL r/m64 | RAX × operand | RDX:RAX (128-bit) | This truncation mechanism only applies to the unary form of IMUL, in the binary o triary form truncation can happens. 4.2. MOVZX, MOVSX - Move with zero/sign extend. This instructions move data from smaller register to a larger one and are very important when C performs a type conversion: MOVZX (Move with Zeri Extend) Copies a smaller value to a larger destination Fills the upper bits with zeros Used for unsigned values Preserves the numeric value for unsigned integers MOVZX dest, source An example of usage could be: MOV AL, 0xFF ; AL = 11111111b (255) MOVZX EAX, AL ; EAX = 00000000 00000000 00000000 11111111b (255) MOVSX (Move with Sign Extend) Copies a smaller value to a larger destination Fills the upper bits by repeating the sign bit (MSB) Used for signed values (2's complement) Preserves the numeric value for signed integers MOVSX dest, source As an example: MOV AL, 0xFF ; AL = 11111111b (-1 in signed) MOVSX EAX, AL ; EAX = 11111111 11111111 11111111 11111111b (-1) MOV BL, 0x7F ; BL = 01111111b (+127 in signed) MOVSX EBX, BL ; EBX = 00000000 00000000 00000000 01111111b (+127) Explanation of the use of each instruction Then, for example, if we have a C code and we assign a short to a wider value like an unsigned integer, then we don't just use MOV, since that would preserve the size, we use MOVZX to convert the value to a positive size-extended version of it self (2 bytes –&gt; 4 bytes): ; short s = -5 mov word ptr [rsp+10h], 0FFFBh ; -5 in twos complement (16-bit) ; unsigned int u = s movsx eax, word ptr [rsp+10h] ; sign-extend to 32-bit: 0xFFFFFFFB mov dword ptr [rsp+14h], eax ; store as unsigned (interprets as 4294967291) ; int i = s movsx eax, word ptr [rsp+10h] ; sign-extend to 32-bit: 0xFFFFFFFB mov dword ptr [rsp+18h], eax ; store as signed (interprets as -5) If instead we assign to a signed integer, then we use MOVSX in order to extend the size of the value preserving the sign (or giving a sign if wasn't there before). ; unsigned short us = 65531 mov word ptr [rsp+10h], 0FFFBh ; unsigned int u = us movzx eax, word ptr [rsp+10h] ; zero-extend: 0x0000FFFB (65531) mov dword ptr [rsp+14h], eax ; int i = us movzx eax, word ptr [rsp+10h] ; zero-extend: 0x0000FFFB (65531) mov dword ptr [rsp+18h], eax 4.3. Understanding arrays in assembly. Now that we understood IMUL, MOVSX and MOVZX instructions, we can introduce how assembly handles array structures. Local variables gets accesed via directs stack offsets using RBP register as we see in previous examples. This is possible since the compiler knows the exact location of a local variable since this are defined (this is, they get a value) within the function. How ever, a value within an array takes other perspective, lets consider the following C code: void set_element(int arr[], int i, int value) { arr[i] = value; } On it, i is an unknown variable from the compiler perspective and thus it can't assign value parameter to a specific memory address as if were a local variable instead, it have to make that assignation dependant on the value of i which gets defined at runtime. The formula is: base_array_address + (index × element_size) Note that, an array is nothing but a linear chunk of memory, we need to multiply the index by the scale of the datatype in order to map the address in which the slot denoted by the index is in the stack. The later addition with 'base_array_address' is just an ordinary way to find an address thorough 'pointer + offset' And it applies at every array, note that in the example provide in the code above (presented again just below), the array assignation is everytime through constants (known by the compiler) so in fact the compiler knows the offset to access that specific memory address and it could accessed through stack offsets but it doesn't because the standadrd method is what is explained above. So, let's see how this formula is implemented in assembly when an array is presented. Consider the following code: int main(){ char buff[10]; char a = 'A'; buff[5] = a; return 0; } This code declares an array of chars of 10 slots, and a local variable then it performes an assignation and then returns. Note that arrays gets allocated in the stack despite the uses of them; stackframe expands enough to hold every declaration inside the function. Consider the following disassembly: 0000000140001000 48 83 EC 28 sub rsp,28h 0000000140001004 C6 04 24 41 mov byte ptr [rsp],41h 0000000140001008 B8 01 00 00 00 mov eax,1 000000014000100D 48 6B C0 05 imul rax,rax,5 0000000140001011 0F B6 0C 24 movzx ecx,byte ptr [rsp] 0000000140001015 88 4C 04 08 mov byte ptr buff[rax],cl 0000000140001019 33 C0 xor eax,eax 000000014000101B 48 83 C4 28 add rsp,28h 000000014000101F C3 ret In order to be able to apply the formula mentioned above, we need first to calculate index address, which is performed in the following instruction: 0000000140001008 B8 01 00 00 00 mov eax,1 //Copy the size of the datatype (this time, char = 1) on the rax register. 000000014000100D 48 6B C0 05 imul rax,rax,5 //Then perform the multiplication using imul with rax register and the index; 5. Now RAX register contains the offset (5) to be used along with the base address of the buffer. There is no ADD instruction since the processor already perform automatically that addition when perform the memory access, it just calculates de offset, stored it in RAX and then uses RAX in the following instruction: 0000000140001011 0F B6 0C 24 movzx ecx,byte ptr [rsp] 0000000140001015 88 4C 04 08 mov byte ptr buff[rax],cl Which is accesssing that offset from the base_address of the buffer (buff), when accesing that memory address, copy the byte cl and then goes on. The buff is addressing mode, is resolved by the disassembler to mean "rsp + 0x8 + rax" (rsp + 0x8 is where the buffer starts on the stack). The full address computation would be: rsp + 0x8 + rax == [rsp + 0x8] + (5 * 1) satisfying the equation mentioned above. Also, is convenient to say that the code above is MCVS being extraordinary unefficient. Moder compilers like gcc would resolve the memory access to the buff as if were a local variable since the index is hardcoded and the compiler knows at compile-time what that index is so there's no need to implement IMUL operations and make the assignation dependant on an unknown variable. If we compile the code above with gcc and open it with radare2 we would get: $ r2 -e asm.sub.var=false -A -qc "s main; pdf" test Warning: run r2 with -e bin.cache=true to fix relocations in disassembly ; DATA XREF from entry0 @ 0x1078 ┌ 65: int main (int argc, char **argv, char **envp); │ ; var int64_t var_13h @ rbp-0x13 │ ; var int64_t var_dh @ rbp-0xd │ ; var int64_t var_8h @ rbp-0x8 │ 0x00001149 f30f1efa endbr64 ; Intel CET Instruction │ 0x0000114d 55 push rbp ; Stackframe prologue │ 0x0000114e 4889e5 mov rbp, rsp │ 0x00001151 4883ec20 sub rsp, 0x20 │ 0x00001155 64488b042528. mov rax, qword fs:[0x28] ; Stack canary (BOF security measure) │ 0x0000115e 488945f8 mov qword [rbp - 8], rax │ 0x00001162 31c0 xor eax, eax │ 0x00001164 c645ed41 mov byte [rbp - 0x13], 0x41 ; 'A' ; char a = 'A' │ 0x00001168 0fb645ed movzx eax, byte [rbp - 0x13] ; buff[5] = a; │ 0x0000116c 8845f3 mov byte [rbp - 0xd], al │ 0x0000116f b800000000 mov eax, 0 ; return 0 │ 0x00001174 488b55f8 mov rdx, qword [rbp - 8] ; Check stack canary │ 0x00001178 64482b142528. sub rdx, qword fs:[0x28] │ ┌─&lt; 0x00001181 7405 je 0x1188 │ │ 0x00001183 e8c8feffff call sym.imp.__stack_chk_fail │ │ ; CODE XREF from main @ 0x1181 │ └─&gt; 0x00001188 c9 leave └ 0x00001189 c3 ret As we can see, since the index is hardcode, the compiler already knows where is the referenced slot of the array exists in the stack: 0x00001168 0fb645ed movzx eax, byte [rbp - 0x13] 0x0000116c 8845f3 mov byte [rbp - 0xd], al So, in conclusion, both forms of handle arrays exists and are completely valid. 5. Struct Local Variable. Like arrays, structs in C are linear memory regions which are accesibles due to offset arithmetics but containing different datatypes elements. An important concept on how the compiler deals with the allocation of memory for a structure is the memory alignment principle which leaks in structure padding. 5.1. Mermoy Alignment Principle. Memory alignment refers to how data is positioned in memory relative to addresses that are multiples of certain values (typically powers of 2). The fundamental reason is architectural and we already ass through it; CPUs access and work data through some special integrated devices called registers which have the width of a word (8 bytes in x64 architectures), it don't fetch memory byte-by-byte. This mean that in a CPU cycle, the CPU reach exactly 8 bytes of data. So, consider the following example. Let's suppouse we have 16 byes of data, this corresponds to two CPU cycles, this means, it takes (ideally) two times to the CPU to read the data stored in those bytes, then let's suppose we have a long integer (8 bytes) occuping the half of thos 16 bytes, 4 in one octet and 4 in other octet. In order to be able to read the long the CPU would need two times instead of the minimum required per the size of the data type: MEMORY LAYOUT: MISALIGNED LONG (8 bytes spanning two octets) ┌───────────────────────────────────────────────────────────────┐ │ 16 BYTES OF MEMORY │ ├───────────────────────────────┬───────────────────────────────┤ │ FIRST OCTET │ SECOND OCTET │ │ (CPU Cycle 1 - 8 bytes) │ (CPU Cycle 2 - 8 bytes) │ ├───┬───┬───┬───┬───┬───┬───┬───┼───┬───┬───┬───┬───┬───┬───┬───┤ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │11 │12 │13 │14 │15 │ ├───┴───┴───┴───┼───┴───┴───┴───┴───┴───┴───┴───┼───┴───┴───┴───┤ │ (unused) │◄──────── LONG (8 bytes) ─────►│ (unused) │ │ 4 bytes │ 4 bytes │ 4 bytes │ 4 bytes │ └───────────────┴───────────────┴───────────────┴───────────────┘ ▲ │ OCTET BOUNDARY (address 0x08) PROBLEM: To read the misaligned LONG, the CPU must: ┌─────────────────┐ ┌─────────────────┐ │ CPU Cycle 1 │ │ CPU Cycle 2 │ │ Fetch bytes │ │ Fetch bytes │ │ 0x00-0x07 │ │ 0x08-0x0F │ │ │ │ │ │ Extract bytes │ │ Extract bytes │ │ 4, 5, 6, 7 │ │ 8, 9, 10, 11 │ └────────┬────────┘ └────────┬────────┘ │ │ └───────────┬───────────────┘ ▼ ┌───────────────────────┐ │ Combine fragments │ │ into complete LONG │ └───────────────────────┘ RESULT: 2 CPU cycles for data that should require only 1 This is extremely inefficient, the solution: force the data storage to start in a multiple of a word's address. Thus, if we know for example have two integers (4 bytes each) and a char intercalates between each integer, then the data in memory would be stored following the memory allignment principle: ┌───────────────────────────────────────────────────────────────┐ │ 16 BYTES OF MEMORY │ ├───────────────────────────────┬───────────────────────────────┤ │ FIRST WORD │ SECOND WORD │ │ (8 bytes) │ (8 bytes) │ ├───┬───┬───┬───┬───┬───┬───┬───┼───┬───┬───┬───┬───┬───┬───┬───┤ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │11 │12 │13 │14 │15 │ ├───┴───┴───┴───┼───┼───┴───┴───┼───┴───┴───┴───┼───┴───┴───┴───┤ │◄─ int a ─────►│ c │◄── gap ──►│◄─── int b ───►│ (available) │ │ 4 bytes │(1)│ 3 bytes │ 4 bytes │ 4 bytes │ └───────────────┴───┴───────────┴───────────────┴───────────────┘ ▲ │ WORD BOUNDARY (address 0x08) Observe two things: First, te char datatype is inside the first chunk because, per its size, the value fits in the gap leaved by the integer before inside the first word. This means that allignment don't force every data value to be stored in a brand new 8-multiple-address-start octet, just those data values that don't fit in the gap leave by other data stored before. This is the case of integer b (4 bytes can't be stored on a 3-bytes gap) so it corresponds to be stored in a new correspondly alligned octet. There exists unused bytes in memory (in our case, 5, 6 and 7) which corresponds to those bytes that fills gaps between alligned datatypes. Since memory has a linear nature, this bytes are lost and will never be reused until memory gets released more likely when program terminates most of the time. Since the two reasons above, the rule gets slitly changed to a more efficient approach: a data type should be stored at an address that's a multiple of its own size. A 4-byte int at multiples of 4, an 8-byte long at multiples of 8, a 2-byte short at multiples of 2, and a 1-byte char anywhere (since every address is a multiple of 1). This is what we call memory principle allignment, and guarantee no data value gets stored between two CPU cycles. 5.2. Structure Padding. The memory alignment principle applies every time data is stored in memory however some C entities does not seems to be affected, local variables or arrays are some examples. Arrays are linear memory regions reserved for same datatype values, then a fixed-size array of a specific datatype will always occupies the same, and barely equal for local variables. However, there is a problem when we talk about structures. We know that the size of a structure is the addition of the size of the fields that composes the struct. So if we get the following C code: #include &lt;stdio.h&gt; typedef struct my_struct { int a; char b; int c; } struct_1; int main(){ struct_1 foo; printf("This struct is %ld bytes width", sizeof(foo)); return 0; } We should spect that the output would be something like: OUTPUT: This struct is 9 bytes width But if we compile the code and check the result we will find out that is not, the actual size is 12. This is because we are no taking in consideration the unsued 3 left bytes between the char and the second integer due to memory alignment. The real count is: int a + char b + unused bytes + int c = 4 + 1 + 3 + 4 = 12 12 BYTES OF STRUCTURE MEMORY ├───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │11 │ ├───┴───┴───┴───┼───┼───┴───┴───┼───┴───┴───┴───┤ │◄─── int a ───►│ b │◄─padding─►│◄─── int c ───►│ │ 4 bytes │(1)│ 3 bytes │ 4 bytes │ └───────────────┴───┴───────────┴───────────────┘ ▲ ▲ │ │ offset 4 offset 8 (4 % 1 = 0 ✓) (8 % 4 = 0 ✓) ────────────────────────────────────────────────── This effect is known as structure padding, when a C compiler automatically inserts extra bytes into a struct to align its members in memory. Structure padding is a consecuence of the memory allignement and actually exists beyond structures, it affects on how memory gets alloced along a linear region in a huge amount of posibles combinations (nested structures, structures with arrays, arrays of structures, etc). 5.3. Structures Dissasembly. Consider the following C code: typedef struct mystruct { short a; int b[6]; long long c; } mystruct_t; short main() { mystruct_t foo; foo.a = 0xbabe; foo.c = 0xba1b0ab1edb100d; foo.b[1] = foo.a; foo.b[4] = foo.b[1] + foo.c; return foo.b[4]; } This C code defines an structure with several datatypes including an array. This the memory layout of this structure is: -&gt; 2 bytes for short a -&gt; 2 bytes for padding -&gt; 4*6 contiguous bytes for each array entry -&gt; 4 bytes for padding (since 24 mod 8 = 0 but array started in non-aligned address) -&gt; 8 bytes (word) for long long c In total, 40 bytes, note that the stackframe expands 0x38, which is enough for the structure. If we compile the code in MCVS 2019, we obtain the following dissasembly: 0000000140001000 48 83 EC 38 sub rsp,38h 0000000140001004 B8 BE BA FF FF mov eax,0FFFFBABEh 0000000140001009 66 89 04 24 mov word ptr [rsp],ax 000000014000100D 48 B8 0D 10 DB 1E AB B0 A1 0B mov rax,0BA1B0AB1EDB100Dh 0000000140001017 48 89 44 24 20 mov qword ptr [rsp+20h],rax 000000014000101C B8 04 00 00 00 mov eax,4 0000000140001021 48 6B C0 01 imul rax,rax,1 0000000140001025 0F BF 0C 24 movsx ecx,word ptr [rsp] 0000000140001029 89 4C 04 04 mov dword ptr [rsp+rax+4],ecx 000000014000102D B8 04 00 00 00 mov eax,4 0000000140001032 48 6B C0 01 imul rax,rax,1 0000000140001036 48 63 44 04 04 movsxd rax,dword ptr [rsp+rax+4] 000000014000103B 48 03 44 24 20 add rax,qword ptr [rsp+20h] 0000000140001040 B9 04 00 00 00 mov ecx,4 0000000140001045 48 6B C9 04 imul rcx,rcx,4 0000000140001049 89 44 0C 04 mov dword ptr [rsp+rcx+4],eax 000000014000104D B8 04 00 00 00 mov eax,4 0000000140001052 48 6B C0 04 imul rax,rax,4 0000000140001056 0F B7 44 04 04 movzx eax,word ptr [rsp+rax+4] 000000014000105B 48 83 C4 38 add rsp,38h 000000014000105F C3 ret Now, lets read the assembly code: First, the stackframe prologue: sub rsp,38h Asignations and operations: foo.a = 0xbabe; 0000000140001004 B8 BE BA FF FF mov eax,0FFFFBABEh 0000000140001009 66 89 04 24 mov word ptr [rsp],ax First, the value "0FFFFBABEh" gets writted to eax, then 'ax' (the lower 16 bits of rax) are written to the left word of the contents of rsp. Remember that rsp points to the top of the stack, this means that the alocation in the stack has been done in opposite direction of the definition in the structure. foo.c = 0xba1b0ab1edb100d; 000000014000100D 48 B8 0D 10 DB 1E AB B0 A1 0B mov rax,0BA1B0AB1EDB100Dh 0000000140001017 48 89 44 24 20 mov qword ptr [rsp+20h],rax Then, the value "0BA1B0AB1EDB100Dh" gets stored and rax and then, on 'rsp + 0x20'. Let's do some counts here: 0x20 = 2*16^1 + 0*16^0 = 32 bytes, this would not be possible if there was no padding, since the teorically distant between those two fields is 28 bytes (24 + 4). foo.b[1] = foo.a; 000000014000101C B8 04 00 00 00 mov eax,4 0000000140001021 48 6B C0 01 imul rax,rax,1 0000000140001025 0F BF 0C 24 movsx ecx,word ptr [rsp] 0000000140001029 89 4C 04 04 mov dword ptr [rsp+rax+4],ecx As we see in the array part, MCSV uses the IMUL method to calculate the offset throught the index and the datatype size and then solves 'base_address + index*element_size' (rsp+rax+4). Then it gets the value from rsp (a) and copy it on the rsp+rax+4 address. Note also that with this assignation, we are converting a short (a) to a signed integer, thus, when "rsp" is copied to "ecx" to later be copied to "rsp + rax + 4", MOVSX is being used in order to give the value a sign (if it was an unsigned int, MOVZX would be used instead). foo.b[4] = foo.b[1] + foo.c; 000000014000102D B8 04 00 00 00 mov eax,4 0000000140001032 48 6B C0 01 imul rax,rax,1 0000000140001036 48 63 44 04 04 movsxd rax,dword ptr [rsp+rax+4] 000000014000103B 48 03 44 24 20 add rax,qword ptr [rsp+20h] 0000000140001040 B9 04 00 00 00 mov ecx,4 0000000140001045 48 6B C9 04 imul rcx,rcx,4 0000000140001049 89 44 0C 04 mov dword ptr [rsp+rcx+4],eax First, fetch "foo.b[1]" and stores its value in rax, then gets "foo.c" and adds that value to rax, now rax contains "foo.b[1] + foo.c" and this value gets stored on fourth slot of the array. return foo.b[4]; 0000000140001056 0F B7 44 04 04 movzx eax,word ptr [rsp+rax+4] 000000014000105B 48 83 C4 38 add rsp,38h ; Stackframe epilogue 000000014000105F C3 ret 6. Instruction exercises. 6.1. MOVZX exercises What value is in r14 after this code executes? mov r12, 0x5B542050674CD692 movzx r14, r12b First, "0x5B542050674CD692" value gets copied over r12, then r12b gets copied over r14. r12b is accessing the lowest byte of r12 register which is 0x92, copying onto r14 and zeroing the rest of uppers bytes, so r14 has 0x0000000000000092 value. What value is in r12w after this code executes? mov di, 0x4B39 mov r13w, 0x6396 movzx r12w, r13b Then, it moves 2-bytes hexadecimal value to r13w which is the 16 lowest bits of r13 register, then moves the lowest byte of r13, which is 0x96, to the 16 lowest bits of r12 and zeroup the rest of bytes of the 16 bits within r12w. So de answer would be 0x0096 What value is in rdx after this code executes? mov rdi, 0xBCE7AA1E4633FA15 add rdi, 0x4375165316635F7B movzx rdx, dil dil the lower byte of rdi has 0x90. 6.2. MOVSX exercises. What value is in esi after this code executes? mov rsp, 0xA440031B065793D1 movsx esi, sp The first instruction moves 0xA440031B065793D1 over rsp. Then, moves with sign extension sp, which is the 16 lowest bits of rsp, to esi. MOVSX is an isntruction that oneup or zeroup depending of the sign of the value. So first, we have to tell if the value is positive or negative: rsp (64 bits) --&gt; 0xA440031B065793D1; sp (16 bits) --&gt; 0x93D1 --&gt; 0b1001001111010001 Per the first byte convention, the value is negative and this means that this value would be extended like follows: sp --&gt; 0b1001001111010001 MOVSX esi --&gt; 0b1111111111111111001001111010001 -&gt; 0xFFFF93D1 What value is in r10 after this code executes? mov r10d, 0x67C1ABD2 mov r8d, 0x7CBE1AFF movsxd r10, r8d As we did before, r8d contents (doubleword is double of a word, 32-bits) is being moved with sign extension to r10, so first lets check the sign converting it to binary: 0x7CBE1AFF --&gt; 0b01111100101111100001101011111111 thus, the value is positive an the value in r10 must be zero-extended: r10 --&gt; 0x000000007CBE1AFF]]></summary></entry></feed>